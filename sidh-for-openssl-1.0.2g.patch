diff -Naur original/openssl-1.0.2g/apps/CA.pl sidh/openssl-1.0.2g/apps/CA.pl
--- original/openssl-1.0.2g/apps/CA.pl	2016-03-01 05:36:56.000000000 -0800
+++ sidh/openssl-1.0.2g/apps/CA.pl	1969-12-31 16:00:00.000000000 -0800
@@ -1,189 +0,0 @@
-#!/usr/bin/perl
-#
-# CA - wrapper around ca to make it easier to use ... basically ca requires
-#      some setup stuff to be done before you can use it and this makes
-#      things easier between now and when Eric is convinced to fix it :-)
-#
-# CA -newca ... will setup the right stuff
-# CA -newreq[-nodes] ... will generate a certificate request 
-# CA -sign ... will sign the generated request and output 
-#
-# At the end of that grab newreq.pem and newcert.pem (one has the key 
-# and the other the certificate) and cat them together and that is what
-# you want/need ... I'll make even this a little cleaner later.
-#
-#
-# 12-Jan-96 tjh    Added more things ... including CA -signcert which
-#                  converts a certificate to a request and then signs it.
-# 10-Jan-96 eay    Fixed a few more bugs and added the SSLEAY_CONFIG
-#		   environment variable so this can be driven from
-#		   a script.
-# 25-Jul-96 eay    Cleaned up filenames some more.
-# 11-Jun-96 eay    Fixed a few filename missmatches.
-# 03-May-96 eay    Modified to use 'ssleay cmd' instead of 'cmd'.
-# 18-Apr-96 tjh    Original hacking
-#
-# Tim Hudson
-# tjh@cryptsoft.com
-#
-
-# 27-Apr-98 snh    Translation into perl, fix existing CA bug.
-#
-#
-# Steve Henson
-# shenson@bigfoot.com
-
-# default openssl.cnf file has setup as per the following
-# demoCA ... where everything is stored
-
-my $openssl;
-if(defined $ENV{OPENSSL}) {
-	$openssl = $ENV{OPENSSL};
-} else {
-	$openssl = "openssl";
-	$ENV{OPENSSL} = $openssl;
-}
-
-$SSLEAY_CONFIG=$ENV{"SSLEAY_CONFIG"};
-$DAYS="-days 365";	# 1 year
-$CADAYS="-days 1095";	# 3 years
-$REQ="$openssl req $SSLEAY_CONFIG";
-$CA="$openssl ca $SSLEAY_CONFIG";
-$VERIFY="$openssl verify";
-$X509="$openssl x509";
-$PKCS12="$openssl pkcs12";
-
-$CATOP="./demoCA";
-$CAKEY="cakey.pem";
-$CAREQ="careq.pem";
-$CACERT="cacert.pem";
-
-$DIRMODE = 0777;
-
-$RET = 0;
-
-foreach (@ARGV) {
-	if ( /^(-\?|-h|-help)$/ ) {
-	    print STDERR "usage: CA -newcert|-newreq|-newreq-nodes|-newca|-sign|-verify\n";
-	    exit 0;
-	} elsif (/^-newcert$/) {
-	    # create a certificate
-	    system ("$REQ -new -x509 -keyout newkey.pem -out newcert.pem $DAYS");
-	    $RET=$?;
-	    print "Certificate is in newcert.pem, private key is in newkey.pem\n"
-	} elsif (/^-newreq$/) {
-	    # create a certificate request
-	    system ("$REQ -new -keyout newkey.pem -out newreq.pem $DAYS");
-	    $RET=$?;
-	    print "Request is in newreq.pem, private key is in newkey.pem\n";
-	} elsif (/^-newreq-nodes$/) {
-	    # create a certificate request
-	    system ("$REQ -new -nodes -keyout newkey.pem -out newreq.pem $DAYS");
-	    $RET=$?;
-	    print "Request is in newreq.pem, private key is in newkey.pem\n";
-	} elsif (/^-newca$/) {
-		# if explicitly asked for or it doesn't exist then setup the
-		# directory structure that Eric likes to manage things 
-	    $NEW="1";
-	    if ( "$NEW" || ! -f "${CATOP}/serial" ) {
-		# create the directory hierarchy
-		mkdir $CATOP, $DIRMODE;
-		mkdir "${CATOP}/certs", $DIRMODE;
-		mkdir "${CATOP}/crl", $DIRMODE ;
-		mkdir "${CATOP}/newcerts", $DIRMODE;
-		mkdir "${CATOP}/private", $DIRMODE;
-		open OUT, ">${CATOP}/index.txt";
-		close OUT;
-		open OUT, ">${CATOP}/crlnumber";
-		print OUT "01\n";
-		close OUT;
-	    }
-	    if ( ! -f "${CATOP}/private/$CAKEY" ) {
-		print "CA certificate filename (or enter to create)\n";
-		$FILE = <STDIN>;
-
-		chop $FILE;
-
-		# ask user for existing CA certificate
-		if ($FILE) {
-		    cp_pem($FILE,"${CATOP}/private/$CAKEY", "PRIVATE");
-		    cp_pem($FILE,"${CATOP}/$CACERT", "CERTIFICATE");
-		    $RET=$?;
-		} else {
-		    print "Making CA certificate ...\n";
-		    system ("$REQ -new -keyout " .
-			"${CATOP}/private/$CAKEY -out ${CATOP}/$CAREQ");
-		    system ("$CA -create_serial " .
-			"-out ${CATOP}/$CACERT $CADAYS -batch " . 
-			"-keyfile ${CATOP}/private/$CAKEY -selfsign " .
-			"-extensions v3_ca " .
-			"-infiles ${CATOP}/$CAREQ ");
-		    $RET=$?;
-		}
-	    }
-	} elsif (/^-pkcs12$/) {
-	    my $cname = $ARGV[1];
-	    $cname = "My Certificate" unless defined $cname;
-	    system ("$PKCS12 -in newcert.pem -inkey newkey.pem " .
-			"-certfile ${CATOP}/$CACERT -out newcert.p12 " .
-			"-export -name \"$cname\"");
-	    $RET=$?;
-	    print "PKCS #12 file is in newcert.p12\n";
-	    exit $RET;
-	} elsif (/^-xsign$/) {
-	    system ("$CA -policy policy_anything -infiles newreq.pem");
-	    $RET=$?;
-	} elsif (/^(-sign|-signreq)$/) {
-	    system ("$CA -policy policy_anything -out newcert.pem " .
-							"-infiles newreq.pem");
-	    $RET=$?;
-	    print "Signed certificate is in newcert.pem\n";
-	} elsif (/^(-signCA)$/) {
-	    system ("$CA -policy policy_anything -out newcert.pem " .
-					"-extensions v3_ca -infiles newreq.pem");
-	    $RET=$?;
-	    print "Signed CA certificate is in newcert.pem\n";
-	} elsif (/^-signcert$/) {
-	    system ("$X509 -x509toreq -in newreq.pem -signkey newreq.pem " .
-								"-out tmp.pem");
-	    system ("$CA -policy policy_anything -out newcert.pem " .
-							"-infiles tmp.pem");
-	    $RET = $?;
-	    print "Signed certificate is in newcert.pem\n";
-	} elsif (/^-verify$/) {
-	    if (shift) {
-		foreach $j (@ARGV) {
-		    system ("$VERIFY -CAfile $CATOP/$CACERT $j");
-		    $RET=$? if ($? != 0);
-		}
-		exit $RET;
-	    } else {
-		    system ("$VERIFY -CAfile $CATOP/$CACERT newcert.pem");
-		    $RET=$?;
-	    	    exit 0;
-	    }
-	} else {
-	    print STDERR "Unknown arg $_\n";
-	    print STDERR "usage: CA -newcert|-newreq|-newreq-nodes|-newca|-sign|-verify\n";
-	    exit 1;
-	}
-}
-
-exit $RET;
-
-sub cp_pem {
-my ($infile, $outfile, $bound) = @_;
-open IN, $infile;
-open OUT, ">$outfile";
-my $flag = 0;
-while (<IN>) {
-	$flag = 1 if (/^-----BEGIN.*$bound/) ;
-	print OUT $_ if ($flag);
-	if (/^-----END.*$bound/) {
-		close IN;
-		close OUT;
-		return;
-	}
-}
-}
-
diff -Naur original/openssl-1.0.2g/apps/Makefile sidh/openssl-1.0.2g/apps/Makefile
--- original/openssl-1.0.2g/apps/Makefile	2016-03-01 05:36:53.000000000 -0800
+++ sidh/openssl-1.0.2g/apps/Makefile	2016-07-20 08:28:03.311200611 -0700
@@ -237,20 +237,21 @@
 ca.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 ca.o: ../include/openssl/x509v3.h apps.h ca.c
 ciphers.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ciphers.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ciphers.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-ciphers.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ciphers.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ciphers.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ciphers.o: ../include/openssl/err.h ../include/openssl/evp.h
-ciphers.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ciphers.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ciphers.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-ciphers.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ciphers.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ciphers.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ciphers.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-ciphers.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ciphers.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ciphers.o: ../include/openssl/comp.h ../include/openssl/conf.h
+ciphers.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+ciphers.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ciphers.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ciphers.o: ../include/openssl/engine.h ../include/openssl/err.h
+ciphers.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ciphers.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ciphers.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ciphers.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+ciphers.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ciphers.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ciphers.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ciphers.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ciphers.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ciphers.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ciphers.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ciphers.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -419,20 +420,21 @@
 enc.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
 enc.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h enc.c
 engine.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-engine.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-engine.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-engine.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-engine.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-engine.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-engine.o: ../include/openssl/err.h ../include/openssl/evp.h
-engine.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-engine.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-engine.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-engine.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-engine.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-engine.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-engine.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-engine.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+engine.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+engine.o: ../include/openssl/comp.h ../include/openssl/conf.h
+engine.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+engine.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+engine.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+engine.o: ../include/openssl/engine.h ../include/openssl/err.h
+engine.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+engine.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+engine.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+engine.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+engine.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+engine.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+engine.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+engine.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+engine.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 engine.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 engine.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 engine.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -440,20 +442,21 @@
 engine.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 engine.o: ../include/openssl/x509v3.h apps.h engine.c
 errstr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-errstr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-errstr.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-errstr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-errstr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-errstr.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-errstr.o: ../include/openssl/err.h ../include/openssl/evp.h
-errstr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-errstr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-errstr.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-errstr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-errstr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-errstr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-errstr.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-errstr.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+errstr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+errstr.o: ../include/openssl/comp.h ../include/openssl/conf.h
+errstr.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+errstr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+errstr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+errstr.o: ../include/openssl/engine.h ../include/openssl/err.h
+errstr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+errstr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+errstr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+errstr.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+errstr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+errstr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+errstr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+errstr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+errstr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 errstr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 errstr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 errstr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -561,27 +564,29 @@
 ocsp.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 ocsp.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 ocsp.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-ocsp.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-ocsp.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-ocsp.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-ocsp.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-ocsp.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
-ocsp.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h ocsp.c
+ocsp.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+ocsp.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ocsp.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ocsp.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ocsp.o: ../include/openssl/tls1.h ../include/openssl/txt_db.h
+ocsp.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+ocsp.o: ../include/openssl/x509v3.h apps.h ocsp.c
 openssl.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-openssl.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-openssl.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-openssl.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-openssl.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-openssl.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-openssl.o: ../include/openssl/err.h ../include/openssl/evp.h
-openssl.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-openssl.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-openssl.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-openssl.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-openssl.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-openssl.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-openssl.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-openssl.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+openssl.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+openssl.o: ../include/openssl/comp.h ../include/openssl/conf.h
+openssl.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+openssl.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+openssl.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+openssl.o: ../include/openssl/engine.h ../include/openssl/err.h
+openssl.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+openssl.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+openssl.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+openssl.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+openssl.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+openssl.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+openssl.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+openssl.o: ../include/openssl/rand.h ../include/openssl/safestack.h
+openssl.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 openssl.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 openssl.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 openssl.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -783,20 +788,21 @@
 rsautl.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 rsautl.o: ../include/openssl/x509v3.h apps.h rsautl.c
 s_cb.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s_cb.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s_cb.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-s_cb.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s_cb.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s_cb.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-s_cb.o: ../include/openssl/err.h ../include/openssl/evp.h
-s_cb.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-s_cb.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-s_cb.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-s_cb.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s_cb.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s_cb.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s_cb.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s_cb.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s_cb.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s_cb.o: ../include/openssl/comp.h ../include/openssl/conf.h
+s_cb.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+s_cb.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s_cb.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s_cb.o: ../include/openssl/engine.h ../include/openssl/err.h
+s_cb.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s_cb.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s_cb.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+s_cb.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+s_cb.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s_cb.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s_cb.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s_cb.o: ../include/openssl/rand.h ../include/openssl/safestack.h
+s_cb.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s_cb.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s_cb.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s_cb.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -819,14 +825,14 @@
 s_client.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 s_client.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 s_client.o: ../include/openssl/rand.h ../include/openssl/safestack.h
-s_client.o: ../include/openssl/sha.h ../include/openssl/srp.h
-s_client.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-s_client.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-s_client.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-s_client.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-s_client.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
-s_client.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
-s_client.o: s_apps.h s_client.c timeouts.h
+s_client.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+s_client.o: ../include/openssl/srp.h ../include/openssl/srtp.h
+s_client.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+s_client.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+s_client.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+s_client.o: ../include/openssl/tls1.h ../include/openssl/txt_db.h
+s_client.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+s_client.o: ../include/openssl/x509v3.h apps.h s_apps.h s_client.c timeouts.h
 s_server.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 s_server.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 s_server.o: ../include/openssl/comp.h ../include/openssl/conf.h
@@ -844,21 +850,22 @@
 s_server.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 s_server.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 s_server.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-s_server.o: ../include/openssl/srp.h ../include/openssl/srtp.h
-s_server.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-s_server.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-s_server.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-s_server.o: ../include/openssl/tls1.h ../include/openssl/txt_db.h
-s_server.o: ../include/openssl/ui.h ../include/openssl/x509.h
-s_server.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
-s_server.o: s_apps.h s_server.c timeouts.h
+s_server.o: ../include/openssl/sidh.h ../include/openssl/srp.h
+s_server.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+s_server.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+s_server.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+s_server.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+s_server.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
+s_server.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+s_server.o: ../include/openssl/x509v3.h apps.h s_apps.h s_server.c timeouts.h
 s_socket.o: ../e_os.h ../e_os2.h ../include/openssl/asn1.h
-s_socket.o: ../include/openssl/bio.h ../include/openssl/buffer.h
-s_socket.o: ../include/openssl/comp.h ../include/openssl/conf.h
-s_socket.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-s_socket.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-s_socket.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-s_socket.o: ../include/openssl/engine.h ../include/openssl/evp.h
+s_socket.o: ../include/openssl/bio.h ../include/openssl/bn.h
+s_socket.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+s_socket.o: ../include/openssl/conf.h ../include/openssl/crypto.h
+s_socket.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+s_socket.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+s_socket.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+s_socket.o: ../include/openssl/err.h ../include/openssl/evp.h
 s_socket.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
 s_socket.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
 s_socket.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
@@ -866,28 +873,30 @@
 s_socket.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
 s_socket.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 s_socket.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-s_socket.o: ../include/openssl/sha.h ../include/openssl/srtp.h
-s_socket.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-s_socket.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-s_socket.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-s_socket.o: ../include/openssl/tls1.h ../include/openssl/txt_db.h
-s_socket.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-s_socket.o: ../include/openssl/x509v3.h apps.h s_apps.h s_socket.c
+s_socket.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+s_socket.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+s_socket.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+s_socket.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+s_socket.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+s_socket.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
+s_socket.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
+s_socket.o: s_apps.h s_socket.c
 s_time.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s_time.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s_time.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-s_time.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s_time.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s_time.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-s_time.o: ../include/openssl/err.h ../include/openssl/evp.h
-s_time.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-s_time.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-s_time.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-s_time.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s_time.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s_time.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s_time.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-s_time.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s_time.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s_time.o: ../include/openssl/comp.h ../include/openssl/conf.h
+s_time.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+s_time.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s_time.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s_time.o: ../include/openssl/engine.h ../include/openssl/err.h
+s_time.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s_time.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s_time.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+s_time.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+s_time.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s_time.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s_time.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s_time.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s_time.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s_time.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s_time.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s_time.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -895,20 +904,21 @@
 s_time.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 s_time.o: ../include/openssl/x509v3.h apps.h s_apps.h s_time.c
 sess_id.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-sess_id.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-sess_id.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-sess_id.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-sess_id.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-sess_id.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-sess_id.o: ../include/openssl/err.h ../include/openssl/evp.h
-sess_id.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-sess_id.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-sess_id.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-sess_id.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-sess_id.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-sess_id.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-sess_id.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
-sess_id.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+sess_id.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+sess_id.o: ../include/openssl/comp.h ../include/openssl/conf.h
+sess_id.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+sess_id.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+sess_id.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+sess_id.o: ../include/openssl/engine.h ../include/openssl/err.h
+sess_id.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+sess_id.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+sess_id.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+sess_id.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+sess_id.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+sess_id.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+sess_id.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+sess_id.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+sess_id.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 sess_id.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 sess_id.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 sess_id.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -952,11 +962,12 @@
 speed.o: ../include/openssl/rc4.h ../include/openssl/ripemd.h
 speed.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
 speed.o: ../include/openssl/seed.h ../include/openssl/sha.h
-speed.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-speed.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
-speed.o: ../include/openssl/ui_compat.h ../include/openssl/whrlpool.h
-speed.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-speed.o: ../include/openssl/x509v3.h apps.h speed.c testdsa.h testrsa.h
+speed.o: ../include/openssl/sidh.h ../include/openssl/stack.h
+speed.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
+speed.o: ../include/openssl/ui.h ../include/openssl/ui_compat.h
+speed.o: ../include/openssl/whrlpool.h ../include/openssl/x509.h
+speed.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h apps.h
+speed.o: speed.c testdsa.h testrsa.h
 spkac.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 spkac.o: ../include/openssl/buffer.h ../include/openssl/conf.h
 spkac.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
diff -Naur original/openssl-1.0.2g/apps/speed.c sidh/openssl-1.0.2g/apps/speed.c
--- original/openssl-1.0.2g/apps/speed.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/apps/speed.c	2016-07-20 08:28:03.311200611 -0700
@@ -79,6 +79,7 @@
 # define DSA_SECONDS     10
 # define ECDSA_SECONDS   10
 # define ECDH_SECONDS    10
+# define SIDH_SECONDS    10
 
 /* 11-Sep-92 Andrew Daviel   Support for Silicon Graphics IRIX added */
 /* 06-Apr-92 Luke Brennan    Support for VMS and add extra signal calls */
@@ -191,6 +192,9 @@
 # ifndef OPENSSL_NO_ECDH
 #  include <openssl/ecdh.h>
 # endif
+# ifndef OPENSSL_NO_SIDH
+#  include <openssl/sidh.h>
+# endif
 # include <openssl/modes.h>
 
 # ifdef OPENSSL_FIPS
@@ -249,6 +253,9 @@
 # define EC_NUM       16
 # define MAX_ECDH_SIZE 256
 
+# define SIDH_NUM     1
+# define MAX_SIDH_SIZE 256
+
 static const char *names[ALGOR_NUM] = {
     "md2", "mdc2", "md4", "md5", "hmac(md5)", "sha1", "rmd160", "rc4",
     "des cbc", "des ede3", "idea cbc", "seed cbc",
@@ -274,6 +281,9 @@
 # ifndef OPENSSL_NO_ECDH
 static double ecdh_results[EC_NUM][1];
 # endif
+# ifndef OPENSSL_NO_SIDH
+static double sidh_results[SIDH_NUM][3];
+# endif
 
 # if defined(OPENSSL_NO_DSA) && !(defined(OPENSSL_NO_ECDSA) && defined(OPENSSL_NO_ECDH))
 static const char rnd_seed[] =
@@ -349,7 +359,8 @@
 }
 # endif
 
-# ifndef OPENSSL_NO_ECDH
+#if defined(OPENSSL_NO_ECDH) && defined(OPENSSL_NO_SIDH)
+#else
 static const int KDF1_SHA1_len = 20;
 static void *KDF1_SHA1(const void *in, size_t inlen, void *out,
                        size_t *outlen)
@@ -364,7 +375,7 @@
     return NULL;
 #  endif                        /* OPENSSL_NO_SHA */
 }
-# endif                         /* OPENSSL_NO_ECDH */
+# endif	/* defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SIDH) */
 
 static void multiblock_speed(const EVP_CIPHER *evp_cipher);
 
@@ -632,6 +643,16 @@
     long ecdh_c[EC_NUM][2];
 # endif
 
+# ifndef OPENSSL_NO_SIDH
+    int sidh_keysize = 4512;
+    SIDH_CTX *sidh_ctx;
+    SIDH_PAIR *sidh_server_pair[SIDH_NUM];
+    SIDH_PAIR *sidh_client_pair[SIDH_NUM];
+    unsigned char sidh_secret_a[MAX_SIDH_SIZE], sidh_secret_b[MAX_SIDH_SIZE];
+    int sidh_secret_size_a, sidh_secret_size_b;
+    long sidh_c[SIDH_NUM][3];
+# endif
+
     int rsa_doit[RSA_NUM];
     int dsa_doit[DSA_NUM];
 # ifndef OPENSSL_NO_ECDSA
@@ -640,6 +661,9 @@
 # ifndef OPENSSL_NO_ECDH
     int ecdh_doit[EC_NUM];
 # endif
+# ifndef OPENSSL_NO_SIDH
+    int sidh_doit[SIDH_NUM];
+# endif
     int doit[ALGOR_NUM];
     int pr_header = 0;
     const EVP_CIPHER *evp_cipher = NULL;
@@ -669,6 +693,13 @@
         ecdh_b[i] = NULL;
     }
 # endif
+# ifndef OPENSSL_NO_SIDH
+    for (i=0; i<SIDH_NUM; i++)
+      {
+	sidh_server_pair[i] = NULL;
+	sidh_client_pair[i] = NULL;
+      }
+# endif
 
     if (bio_err == NULL)
         if ((bio_err = BIO_new(BIO_s_file())) != NULL)
@@ -710,6 +741,10 @@
     for (i = 0; i < EC_NUM; i++)
         ecdh_doit[i] = 0;
 # endif
+# ifndef OPENSSL_NO_SIDH
+    for (i = 0; i < SIDH_NUM; i++)
+      sidh_doit[i] = 0;
+# endif
 
     j = 0;
     argc--;
@@ -1063,6 +1098,14 @@
                 ecdh_doit[i] = 1;
         } else
 # endif
+#ifndef OPENSSL_NO_SIDH
+	  if (strcmp(*argv,"sidh") == 0)
+	    {
+	      for (i=0; i < SIDH_NUM; i++)
+		sidh_doit[i]=1;
+	    }
+	  else
+#endif
         {
             BIO_printf(bio_err, "Error: bad option or value\n");
             BIO_printf(bio_err, "\n");
@@ -1165,6 +1208,9 @@
                        "ecdhb163  ecdhb233  ecdhb283  ecdhb409  ecdhb571\n");
             BIO_printf(bio_err, "ecdh\n");
 # endif
+#ifndef OPENSSL_NO_SIDH
+	    BIO_printf(bio_err,"sidh\n");
+#endif
 
 # ifndef OPENSSL_NO_IDEA
             BIO_printf(bio_err, "idea     ");
@@ -1248,6 +1294,10 @@
         for (i = 0; i < EC_NUM; i++)
             ecdh_doit[i] = 1;
 # endif
+#ifndef OPENSSL_NO_SIDH
+	for (i=0; i<SIDH_NUM; i++)
+	  sidh_doit[i]=1;
+#endif
     }
     for (i = 0; i < ALGOR_NUM; i++)
         if (doit[i])
@@ -1530,6 +1580,12 @@
         }
     }
 #   endif
+#ifndef OPENSSL_NO_SIDH
+    for (i=0; i<=SIDH_NUM; i++) {
+      sidh_c[i][0]=count/1000;
+      sidh_c[i][1]=count/1000;
+    }
+#endif
 
 #   define COND(d) (count < (d))
 #   define COUNT(d) (d)
@@ -2354,6 +2410,104 @@
     if (rnd_fake)
         RAND_cleanup();
 # endif
+
+#ifndef OPENSSL_NO_SIDH
+    if (RAND_status() != 1)
+      {
+	RAND_seed(rnd_seed, sizeof rnd_seed);
+	rnd_fake = 1;
+      }
+    sidh_ctx = SIDH_CTX_new();
+    if (sidh_ctx == NULL)
+      {
+	BIO_printf(bio_err,"SIDH failure.\n");
+	ERR_print_errors(bio_err);
+	rsa_count=1;
+      }
+    else
+      {
+	for (j=0; j<SIDH_NUM; j++)
+	  {
+	    if (!sidh_doit[j]) continue;
+	    sidh_server_pair[j] = SIDH_PAIR_new();
+	    sidh_client_pair[j] = SIDH_PAIR_new();
+	    if ((sidh_server_pair[j] == NULL) || (sidh_client_pair[j] == NULL))
+	      {
+		BIO_printf(bio_err,"SIDH failure.\n");
+		ERR_print_errors(bio_err);
+		rsa_count=1;
+	      }
+	    else
+	      {
+
+		/* Time SIDH key generation */
+		pkey_print_message("sidh","key generation", sidh_c[j][0], sidh_keysize, SIDH_SECONDS);
+		Time_F(START);
+		for (count=0,run=1; COND(sidh_c[j][0]); count++)
+		  {
+		      SIDH_PAIR_generate_key_server(sidh_server_pair[j], sidh_ctx);
+		  }
+		d=Time_F(STOP);
+		BIO_printf(bio_err, mr ? "+R9:%ld:%d:%.2f\n" :"%ld n=%d SIDH key generations in %.2fs\n",
+			   count, sidh_keysize, d);
+		sidh_results[j][0]=d/(double)count;
+		rsa_count=count;
+
+		sidh_secret_size_b = KDF1_SHA1_len;
+		sidh_secret_size_a = KDF1_SHA1_len;
+		/* generate two SIDH key pairs */
+		if (!SIDH_PAIR_generate_key_server(sidh_server_pair[j], sidh_ctx) ||
+		    !SIDH_PAIR_generate_key_client(sidh_client_pair[j], sidh_ctx))
+		  {
+		    BIO_printf(bio_err,"SIDH key generation failure.\n");
+		    ERR_print_errors(bio_err);
+		    rsa_count=1;		
+		  }
+		else
+		  {
+		    /* Time SIDH Client shared secret generation */
+		    pkey_print_message("sidh", "Client shared secret", sidh_c[j][1], sidh_keysize, SIDH_SECONDS);
+		    Time_F(START);
+		    for (count=0,run=1; COND(sidh_c[j][1]); count++)
+		      {
+			SIDH_compute_key_client(sidh_secret_b, sidh_secret_size_b, 
+						SIDH_PAIR_get_publickey(sidh_server_pair[j]), sidh_client_pair[j], KDF1_SHA1, sidh_ctx);
+		      }
+		    d=Time_F(STOP);
+		    BIO_printf(bio_err, mr ? "+R10:%ld:%d:%.2f\n" :"%ld n=%d SIDH Client shared secret in %.2fs\n",
+			       count, sidh_keysize, d);
+		    sidh_results[j][1]=d/(double)count;
+		    rsa_count=count;
+
+		    /* Time SIDH Server shared secret generation */
+		    pkey_print_message("sidh", "Server shared secret", sidh_c[j][2], sidh_keysize, SIDH_SECONDS);
+		    Time_F(START);
+		    for (count=0,run=1; COND(sidh_c[j][2]); count++)
+		      {
+			SIDH_compute_key_server(sidh_secret_a, sidh_secret_size_a, 
+						SIDH_PAIR_get_publickey(sidh_client_pair[j]), sidh_server_pair[j], KDF1_SHA1, sidh_ctx);
+		      }
+		    d=Time_F(STOP);
+		    BIO_printf(bio_err, mr ? "+R11:%ld:%d:%.2f\n" :"%ld n=%d SIDH Server shared secret in %.2fs\n",
+			       count, sidh_keysize, d);
+		    sidh_results[j][2]=d/(double)count;
+		    rsa_count=count;
+
+		  }
+	      }
+
+	    if (rsa_count <= 1)
+	      {
+		/* if longer than 10s, don't do any more */
+		for (j++; j<SIDH_NUM; j++)
+		  sidh_doit[j]=0;
+	      }
+	  }
+      }
+
+    if (rnd_fake) RAND_cleanup();
+#endif
+
 # ifndef NO_FORK
  show_res:
 # endif
@@ -2493,6 +2647,30 @@
     }
 # endif
 
+#ifndef OPENSSL_NO_SIDH
+    j=1;
+    for (k=0; k<SIDH_NUM; k++)
+      {
+	if (!sidh_doit[k]) continue;
+	if (j && !mr)
+	  {
+	    printf("%19skeygen   keygen/s   Client shared      Client/s   Server shared    Server/s\n"," ");
+	    j=0;
+	  }
+	if (mr)
+	  fprintf(stdout,"+F6:%u:%u:%f:%f:%f\n",
+		  k, sidh_keysize,
+		  sidh_results[k][0], sidh_results[k][1], sidh_results[k][2]);
+	
+	else
+	  fprintf(stdout,"sidh n=%4u     %8.4fs    %8.1f   %8.4fs   %8.1f      %8.4fs   %8.1f\n",
+		  sidh_keysize,
+		  sidh_results[k][0], 1.0/sidh_results[k][0],
+		  sidh_results[k][1], 1.0/sidh_results[k][1],
+		  sidh_results[k][2], 1.0/sidh_results[k][2]);
+      }
+#endif
+
     mret = 0;
 
  end:
@@ -2525,6 +2703,17 @@
             EC_KEY_free(ecdh_b[i]);
     }
 # endif
+#ifndef OPENSSL_NO_SIDH
+    for (i=0; i<SIDH_NUM; i++)
+      {
+	if (sidh_server_pair[i] != NULL)
+	  SIDH_PAIR_free(sidh_server_pair[i]);
+	if (sidh_client_pair[i] != NULL)
+	  SIDH_PAIR_free(sidh_client_pair[i]);
+      }
+    if (sidh_ctx != NULL)
+      SIDH_CTX_free(sidh_ctx);
+#endif
 
     apps_shutdown();
     OPENSSL_EXIT(mret);
@@ -2751,6 +2940,24 @@
             }
 #  endif
 
+#ifndef OPENSSL_NO_SIDH
+	    else if(!strncmp(buf,"+F6:",4))
+	      {
+		int k;
+		double d;
+		
+		p=buf+4;
+		k=atoi(sstrsep(&p,sep));
+		sstrsep(&p,sep);
+		
+		d=atof(sstrsep(&p,sep));
+		if(n)
+		  sidh_results[k][0]=1/(1/sidh_results[k][0]+1/d);
+		else
+		  sidh_results[k][0]=d;
+	      }
+#endif
+
             else if (!strncmp(buf, "+H:", 3)) {
             } else
                 fprintf(stderr, "Unknown type '%s' from child %d\n", buf, n);
diff -Naur original/openssl-1.0.2g/crypto/err/err.h sidh/openssl-1.0.2g/crypto/err/err.h
--- original/openssl-1.0.2g/crypto/err/err.h	2016-03-01 05:35:05.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/err/err.h	2016-07-20 08:28:03.347200610 -0700
@@ -191,6 +191,7 @@
 # define ERR_LIB_COMP            41
 # define ERR_LIB_ECDSA           42
 # define ERR_LIB_ECDH            43
+# define ERR_LIB_SIDH            51
 # define ERR_LIB_STORE           44
 # define ERR_LIB_FIPS            45
 # define ERR_LIB_CMS             46
@@ -227,6 +228,7 @@
 # define COMPerr(f,r) ERR_PUT_error(ERR_LIB_COMP,(f),(r),__FILE__,__LINE__)
 # define ECDSAerr(f,r)  ERR_PUT_error(ERR_LIB_ECDSA,(f),(r),__FILE__,__LINE__)
 # define ECDHerr(f,r)  ERR_PUT_error(ERR_LIB_ECDH,(f),(r),__FILE__,__LINE__)
+# define SIDHerr(f,r)  ERR_PUT_error(ERR_LIB_SIDH,(f),(r),__FILE__,__LINE__)
 # define STOREerr(f,r) ERR_PUT_error(ERR_LIB_STORE,(f),(r),__FILE__,__LINE__)
 # define FIPSerr(f,r) ERR_PUT_error(ERR_LIB_FIPS,(f),(r),__FILE__,__LINE__)
 # define CMSerr(f,r) ERR_PUT_error(ERR_LIB_CMS,(f),(r),__FILE__,__LINE__)
@@ -289,6 +291,7 @@
 # define ERR_R_ECDH_LIB  ERR_LIB_ECDH/* 43 */
 # define ERR_R_STORE_LIB ERR_LIB_STORE/* 44 */
 # define ERR_R_TS_LIB    ERR_LIB_TS/* 45 */
+# define ERR_R_SIDH_LIB  ERR_LIB_SIDH/* 47 */
 
 # define ERR_R_NESTED_ASN1_ERROR                 58
 # define ERR_R_BAD_ASN1_OBJECT_HEADER            59
diff -Naur original/openssl-1.0.2g/crypto/err/openssl.ec sidh/openssl-1.0.2g/crypto/err/openssl.ec
--- original/openssl-1.0.2g/crypto/err/openssl.ec	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/err/openssl.ec	2016-07-20 08:28:03.347200610 -0700
@@ -30,6 +30,7 @@
 L COMP		crypto/comp/comp.h		crypto/comp/comp_err.c
 L ECDSA		crypto/ecdsa/ecdsa.h		crypto/ecdsa/ecs_err.c
 L ECDH		crypto/ecdh/ecdh.h		crypto/ecdh/ech_err.c
+L SIDH		crypto/sidh/sidh.h		crypto/sidh/sidhkex_err.c
 L STORE		crypto/store/store.h		crypto/store/str_err.c
 L TS		crypto/ts/ts.h			crypto/ts/ts_err.c
 L HMAC		crypto/hmac/hmac.h		crypto/hmac/hmac_err.c
diff -Naur original/openssl-1.0.2g/crypto/opensslconf.h sidh/openssl-1.0.2g/crypto/opensslconf.h
--- original/openssl-1.0.2g/crypto/opensslconf.h	2016-03-01 05:36:55.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/opensslconf.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,265 +0,0 @@
-/* opensslconf.h */
-/* WARNING: Generated automatically from opensslconf.h.in by Configure. */
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-/* OpenSSL was configured with the following options: */
-#ifndef OPENSSL_DOING_MAKEDEPEND
-
-
-#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
-# define OPENSSL_NO_EC_NISTP_64_GCC_128
-#endif
-#ifndef OPENSSL_NO_GMP
-# define OPENSSL_NO_GMP
-#endif
-#ifndef OPENSSL_NO_JPAKE
-# define OPENSSL_NO_JPAKE
-#endif
-#ifndef OPENSSL_NO_KRB5
-# define OPENSSL_NO_KRB5
-#endif
-#ifndef OPENSSL_NO_LIBUNBOUND
-# define OPENSSL_NO_LIBUNBOUND
-#endif
-#ifndef OPENSSL_NO_MD2
-# define OPENSSL_NO_MD2
-#endif
-#ifndef OPENSSL_NO_RC5
-# define OPENSSL_NO_RC5
-#endif
-#ifndef OPENSSL_NO_RFC3779
-# define OPENSSL_NO_RFC3779
-#endif
-#ifndef OPENSSL_NO_SCTP
-# define OPENSSL_NO_SCTP
-#endif
-#ifndef OPENSSL_NO_SSL_TRACE
-# define OPENSSL_NO_SSL_TRACE
-#endif
-#ifndef OPENSSL_NO_SSL2
-# define OPENSSL_NO_SSL2
-#endif
-#ifndef OPENSSL_NO_STORE
-# define OPENSSL_NO_STORE
-#endif
-#ifndef OPENSSL_NO_UNIT_TEST
-# define OPENSSL_NO_UNIT_TEST
-#endif
-#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
-# define OPENSSL_NO_WEAK_SSL_CIPHERS
-#endif
-
-#endif /* OPENSSL_DOING_MAKEDEPEND */
-
-#ifndef OPENSSL_NO_DYNAMIC_ENGINE
-# define OPENSSL_NO_DYNAMIC_ENGINE
-#endif
-
-/* The OPENSSL_NO_* macros are also defined as NO_* if the application
-   asks for it.  This is a transient feature that is provided for those
-   who haven't had the time to do the appropriate changes in their
-   applications.  */
-#ifdef OPENSSL_ALGORITHM_DEFINES
-# if defined(OPENSSL_NO_EC_NISTP_64_GCC_128) && !defined(NO_EC_NISTP_64_GCC_128)
-#  define NO_EC_NISTP_64_GCC_128
-# endif
-# if defined(OPENSSL_NO_GMP) && !defined(NO_GMP)
-#  define NO_GMP
-# endif
-# if defined(OPENSSL_NO_JPAKE) && !defined(NO_JPAKE)
-#  define NO_JPAKE
-# endif
-# if defined(OPENSSL_NO_KRB5) && !defined(NO_KRB5)
-#  define NO_KRB5
-# endif
-# if defined(OPENSSL_NO_LIBUNBOUND) && !defined(NO_LIBUNBOUND)
-#  define NO_LIBUNBOUND
-# endif
-# if defined(OPENSSL_NO_MD2) && !defined(NO_MD2)
-#  define NO_MD2
-# endif
-# if defined(OPENSSL_NO_RC5) && !defined(NO_RC5)
-#  define NO_RC5
-# endif
-# if defined(OPENSSL_NO_RFC3779) && !defined(NO_RFC3779)
-#  define NO_RFC3779
-# endif
-# if defined(OPENSSL_NO_SCTP) && !defined(NO_SCTP)
-#  define NO_SCTP
-# endif
-# if defined(OPENSSL_NO_SSL_TRACE) && !defined(NO_SSL_TRACE)
-#  define NO_SSL_TRACE
-# endif
-# if defined(OPENSSL_NO_SSL2) && !defined(NO_SSL2)
-#  define NO_SSL2
-# endif
-# if defined(OPENSSL_NO_STORE) && !defined(NO_STORE)
-#  define NO_STORE
-# endif
-# if defined(OPENSSL_NO_UNIT_TEST) && !defined(NO_UNIT_TEST)
-#  define NO_UNIT_TEST
-# endif
-# if defined(OPENSSL_NO_WEAK_SSL_CIPHERS) && !defined(NO_WEAK_SSL_CIPHERS)
-#  define NO_WEAK_SSL_CIPHERS
-# endif
-#endif
-
-/* crypto/opensslconf.h.in */
-
-/* Generate 80386 code? */
-#undef I386_ONLY
-
-#if !(defined(VMS) || defined(__VMS)) /* VMS uses logical names instead */
-#if defined(HEADER_CRYPTLIB_H) && !defined(OPENSSLDIR)
-#define ENGINESDIR "/usr/local/ssl/lib/engines"
-#define OPENSSLDIR "/usr/local/ssl"
-#endif
-#endif
-
-#undef OPENSSL_UNISTD
-#define OPENSSL_UNISTD <unistd.h>
-
-#undef OPENSSL_EXPORT_VAR_AS_FUNCTION
-
-#if defined(HEADER_IDEA_H) && !defined(IDEA_INT)
-#define IDEA_INT unsigned int
-#endif
-
-#if defined(HEADER_MD2_H) && !defined(MD2_INT)
-#define MD2_INT unsigned int
-#endif
-
-#if defined(HEADER_RC2_H) && !defined(RC2_INT)
-/* I need to put in a mod for the alpha - eay */
-#define RC2_INT unsigned int
-#endif
-
-#if defined(HEADER_RC4_H)
-#if !defined(RC4_INT)
-/* using int types make the structure larger but make the code faster
- * on most boxes I have tested - up to %20 faster. */
-/*
- * I don't know what does "most" mean, but declaring "int" is a must on:
- * - Intel P6 because partial register stalls are very expensive;
- * - elder Alpha because it lacks byte load/store instructions;
- */
-#define RC4_INT unsigned int
-#endif
-#if !defined(RC4_CHUNK)
-/*
- * This enables code handling data aligned at natural CPU word
- * boundary. See crypto/rc4/rc4_enc.c for further details.
- */
-#undef RC4_CHUNK
-#endif
-#endif
-
-#if (defined(HEADER_NEW_DES_H) || defined(HEADER_DES_H)) && !defined(DES_LONG)
-/* If this is set to 'unsigned int' on a DEC Alpha, this gives about a
- * %20 speed up (longs are 8 bytes, int's are 4). */
-#ifndef DES_LONG
-#define DES_LONG unsigned long
-#endif
-#endif
-
-#if defined(HEADER_BN_H) && !defined(CONFIG_HEADER_BN_H)
-#define CONFIG_HEADER_BN_H
-#undef BN_LLONG
-
-/* Should we define BN_DIV2W here? */
-
-/* Only one for the following should be defined */
-#undef SIXTY_FOUR_BIT_LONG
-#undef SIXTY_FOUR_BIT
-#define THIRTY_TWO_BIT
-#endif
-
-#if defined(HEADER_RC4_LOCL_H) && !defined(CONFIG_HEADER_RC4_LOCL_H)
-#define CONFIG_HEADER_RC4_LOCL_H
-/* if this is defined data[i] is used instead of *data, this is a %20
- * speedup on x86 */
-#undef RC4_INDEX
-#endif
-
-#if defined(HEADER_BF_LOCL_H) && !defined(CONFIG_HEADER_BF_LOCL_H)
-#define CONFIG_HEADER_BF_LOCL_H
-#undef BF_PTR
-#endif /* HEADER_BF_LOCL_H */
-
-#if defined(HEADER_DES_LOCL_H) && !defined(CONFIG_HEADER_DES_LOCL_H)
-#define CONFIG_HEADER_DES_LOCL_H
-#ifndef DES_DEFAULT_OPTIONS
-/* the following is tweaked from a config script, that is why it is a
- * protected undef/define */
-#ifndef DES_PTR
-#undef DES_PTR
-#endif
-
-/* This helps C compiler generate the correct code for multiple functional
- * units.  It reduces register dependancies at the expense of 2 more
- * registers */
-#ifndef DES_RISC1
-#undef DES_RISC1
-#endif
-
-#ifndef DES_RISC2
-#undef DES_RISC2
-#endif
-
-#if defined(DES_RISC1) && defined(DES_RISC2)
-#error YOU SHOULD NOT HAVE BOTH DES_RISC1 AND DES_RISC2 DEFINED!!!!!
-#endif
-
-/* Unroll the inner loop, this sometimes helps, sometimes hinders.
- * Very mucy CPU dependant */
-#ifndef DES_UNROLL
-#undef DES_UNROLL
-#endif
-
-/* These default values were supplied by
- * Peter Gutman <pgut001@cs.auckland.ac.nz>
- * They are only used if nothing else has been defined */
-#if !defined(DES_PTR) && !defined(DES_RISC1) && !defined(DES_RISC2) && !defined(DES_UNROLL)
-/* Special defines which change the way the code is built depending on the
-   CPU and OS.  For SGI machines you can use _MIPS_SZLONG (32 or 64) to find
-   even newer MIPS CPU's, but at the moment one size fits all for
-   optimization options.  Older Sparc's work better with only UNROLL, but
-   there's no way to tell at compile time what it is you're running on */
- 
-#if defined( __sun ) || defined ( sun )		/* Newer Sparc's */
-#  define DES_PTR
-#  define DES_RISC1
-#  define DES_UNROLL
-#elif defined( __ultrix )	/* Older MIPS */
-#  define DES_PTR
-#  define DES_RISC2
-#  define DES_UNROLL
-#elif defined( __osf1__ )	/* Alpha */
-#  define DES_PTR
-#  define DES_RISC2
-#elif defined ( _AIX )		/* RS6000 */
-  /* Unknown */
-#elif defined( __hpux )		/* HP-PA */
-  /* Unknown */
-#elif defined( __aux )		/* 68K */
-  /* Unknown */
-#elif defined( __dgux )		/* 88K (but P6 in latest boxes) */
-#  define DES_UNROLL
-#elif defined( __sgi )		/* Newer MIPS */
-#  define DES_PTR
-#  define DES_RISC2
-#  define DES_UNROLL
-#elif defined(i386) || defined(__i386__)	/* x86 boxes, should be gcc */
-#  define DES_PTR
-#  define DES_RISC1
-#  define DES_UNROLL
-#endif /* Systems-specific speed defines */
-#endif
-
-#endif /* DES_DEFAULT_OPTIONS */
-#endif /* HEADER_DES_LOCL_H */
-#ifdef  __cplusplus
-}
-#endif
diff -Naur original/openssl-1.0.2g/crypto/sidh/Makefile sidh/openssl-1.0.2g/crypto/sidh/Makefile
--- original/openssl-1.0.2g/crypto/sidh/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/Makefile	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,113 @@
+#
+# crypto/sidh/Makefile
+#
+
+DIR=	sidh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g -Wall
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+ifneq (,$(findstring SIDH_ASM,$(CFLAGS)))
+DO_SIDH_ASM=TRUE
+endif
+
+GENERAL=Makefile
+TEST=sidhkextest.c
+APPS=
+
+ifdef DO_SIDH_ASM
+ASM_OBJECTS=fp_x64_asm.o
+endif
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	sidhkex_key.c sidhkex_err.c
+
+LIBOBJ=	sidhkex_key.o sidhkex_err.o $(ASM_OBJECTS)
+
+SRC= $(LIBSRC)
+
+EXHEADER= sidh.h
+HEADER=	sidhkex_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+
+ifdef DO_SIDH_ASM
+fp_x64_asm.o:	sidhlib/AMD64/fp_x64_asm.S
+	$(CC) $(CFLAGS) -c -o $@ sidhlib/AMD64/fp_x64_asm.S
+endif
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+sidhkex_err.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sidhkex_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+sidhkex_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+sidhkex_err.o: ../../include/openssl/opensslconf.h
+sidhkex_err.o: ../../include/openssl/opensslv.h
+sidhkex_err.o: ../../include/openssl/ossl_typ.h
+sidhkex_err.o: ../../include/openssl/safestack.h ../../include/openssl/sidh.h
+sidhkex_err.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sidhkex_err.o: sidhkex_err.c
+sidhkex_key.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+sidhkex_key.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+sidhkex_key.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+sidhkex_key.o: ../../include/openssl/opensslconf.h
+sidhkex_key.o: ../../include/openssl/opensslv.h
+sidhkex_key.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rand.h
+sidhkex_key.o: ../../include/openssl/safestack.h ../../include/openssl/sidh.h
+sidhkex_key.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+sidhkex_key.o: sidhkex_key.c sidhkex_locl.h sidhlib/SIDH.c sidhlib/SIDH.h
+sidhkex_key.o: sidhlib/SIDH_internal.h sidhlib/SIDH_setup.c
+sidhkex_key.o: sidhlib/ec_isogeny.c sidhlib/fpx.c
+sidhkex_key.o: sidhlib/generic/../SIDH_internal.h sidhlib/generic/fp_generic.c
+sidhkex_key.o: sidhlib/kex.c sidhlib/validate.c
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidh.h sidh/openssl-1.0.2g/crypto/sidh/sidh.h
--- original/openssl-1.0.2g/crypto/sidh/sidh.h	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidh.h	2016-07-20 08:28:03.335200610 -0700
@@ -0,0 +1,103 @@
+/* crypto/sidh/sidh.h */
+#ifndef HEADER_SIDH_H
+#define HEADER_SIDH_H
+
+#include <openssl/opensslconf.h>
+
+#ifdef OPENSSL_NO_SIDH
+#error SIDH is disabled.
+#endif
+
+#include <openssl/ossl_typ.h>
+#include <openssl/bn.h>
+#include <openssl/err.h>
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Size of SIDH secret key = (CurveIsogeny_SIDHp751.owordbits + 7)/8
+ * Number of bytes in an element in [1, order]
+ */
+#define SIDH_SECRETKEY_LEN 48
+/*
+ * Number of bytes in a field element 
+ * PBYTES_SIDHp751 ((CurveIsogeny_SIDHp751.pwordbits + 7)/8)
+ * Size of SIDH public key = 3*2*PBYTES_SIDHp751
+ */
+#define SIDH_PUBKEY_LEN 576
+/* Size of SIDH shared key = 2*PBYTES_SIDHp751 */
+#define SIDH_SHAREDKEY_LEN 192
+
+typedef struct sidh_pub_st  SIDH_PUB;
+typedef struct sidh_pair_st SIDH_PAIR;
+typedef struct sidh_ctx_st  SIDH_CTX;
+
+/* Allocate and deallocate context, public keys, and key pairs structures */
+SIDH_CTX *SIDH_CTX_new(void);
+void SIDH_CTX_free(SIDH_CTX *ctx);
+
+SIDH_PUB *SIDH_PUB_new(void);
+SIDH_PUB *SIDH_PUB_copy(SIDH_PUB *dest, const SIDH_PUB *src);
+void SIDH_PUB_free(SIDH_PUB *pub);
+
+SIDH_PAIR *SIDH_PAIR_new(void);
+SIDH_PAIR *SIDH_PAIR_copy(SIDH_PAIR *dest, const SIDH_PAIR *src);
+SIDH_PAIR *SIDH_PAIR_dup(const SIDH_PAIR *pair);
+void SIDH_PAIR_free(SIDH_PAIR *pair);
+
+/* Generate key pair */
+int SIDH_PAIR_generate_key_server(SIDH_PAIR *key, SIDH_CTX *ctx);
+int SIDH_PAIR_generate_key_client(SIDH_PAIR *key, SIDH_CTX *ctx);
+
+/* Convert public keys and reconciliation data structures from/to binary */
+SIDH_PUB *o2i_SIDH_PUB(SIDH_PUB **pub, const unsigned char *in, long len);
+int i2o_SIDH_PUB(SIDH_PUB *pub, unsigned char **out);
+
+/* Get public key from a key pair */
+SIDH_PUB *SIDH_PAIR_get_publickey(SIDH_PAIR *pair);
+/* Does private key exist? */
+int SIDH_PAIR_has_privatekey(SIDH_PAIR *pair);
+
+/* Compute shared secret values */
+int SIDH_compute_key_server(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key, 
+			    void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx);
+int SIDH_compute_key_client(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key, 
+			    void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx);
+
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_SIDH_strings(void);
+
+/* Error codes for the SIDH functions. */
+
+/* Function codes. */
+#define SIDH_F_I2O_SIDH_PUB  			 100
+#define SIDH_F_O2I_SIDH_PUB  			 101
+#define SIDH_F_SIDH_COMPUTE_KEY_SERVER		 102
+#define SIDH_F_SIDH_COMPUTE_KEY_CLIENT		 103
+#define SIDH_F_SIDH_PAIR_COPY			 114
+#define SIDH_F_SIDH_PAIR_NEW			 105
+#define SIDH_F_SIDH_PUB_COPY			 106
+#define SIDH_F_SIDH_PUB_NEW			 107
+#define SIDH_F_SIDH_PAIR_GENERATE_KEY_SERVER     108
+#define SIDH_F_SIDH_PAIR_GENERATE_KEY_CLIENT     109
+#define SIDH_F_SIDH_CTX_NEW			 110
+
+/* Reason codes. */
+#define SIDH_R_INVALID_LENGTH			 100
+#define SIDH_R_KDF_FAILED			 101
+#define SIDH_R_RANDOM_FAILED			 102
+#define SIDH_R_KEX_FAILED			 103
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhkex_err.c sidh/openssl-1.0.2g/crypto/sidh/sidhkex_err.c
--- original/openssl-1.0.2g/crypto/sidh/sidhkex_err.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhkex_err.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,105 @@
+/* crypto/sidh/sidhkex_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/sidh.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_SIDH,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_SIDH,0,reason)
+
+static ERR_STRING_DATA SIDH_str_functs[]=
+  {
+{ERR_FUNC(SIDH_F_I2O_SIDH_PUB),	"i2o_SIDH_PUB"},
+{ERR_FUNC(SIDH_F_O2I_SIDH_PUB),	"o2i_SIDH_PUB"},
+{ERR_FUNC(SIDH_F_SIDH_COMPUTE_KEY_SERVER), "SIDH_compute_key_server"},
+{ERR_FUNC(SIDH_F_SIDH_COMPUTE_KEY_CLIENT), "SIDH_compute_key_client"},
+{ERR_FUNC(SIDH_F_SIDH_PAIR_COPY),	"SIDH_PAIR_copy"},
+{ERR_FUNC(SIDH_F_SIDH_PAIR_NEW),	"SIDH_PAIR_new"},
+{ERR_FUNC(SIDH_F_SIDH_PUB_COPY),	"SIDH_PUB_copy"},
+{ERR_FUNC(SIDH_F_SIDH_PUB_NEW),	"SIDH_PUB_new"},
+{ERR_FUNC(SIDH_F_SIDH_CTX_NEW),	"SIDH_CTX_new"},
+{0,NULL}
+};
+
+static ERR_STRING_DATA SIDH_str_reasons[]=
+	{
+{ERR_REASON(SIDH_R_INVALID_LENGTH)    ,"invalid length"},
+{ERR_REASON(SIDH_R_KDF_FAILED)        ,"kdf failed"},
+{ERR_REASON(SIDH_R_RANDOM_FAILED)     ,"random failed"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_SIDH_strings(void)
+	{
+#ifndef OPENSSL_NO_ERR
+
+	if (ERR_func_error_string(SIDH_str_functs[0].error) == NULL)
+		{
+		ERR_load_strings(0,SIDH_str_functs);
+		ERR_load_strings(0,SIDH_str_reasons);
+		}
+#endif
+	}
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhkex_key.c sidh/openssl-1.0.2g/crypto/sidh/sidhkex_key.c
--- original/openssl-1.0.2g/crypto/sidh/sidhkex_key.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhkex_key.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,395 @@
+/* crypto/sidh/sidhkex_key.c */
+
+#include <string.h>
+#include "sidhkex_locl.h"
+#include "sidhlib/fpx.c"
+#include "sidhlib/kex.c"
+#include "sidhlib/ec_isogeny.c"
+#include "sidhlib/SIDH.c"
+#include "sidhlib/SIDH_setup.c"
+#include "sidhlib/validate.c"
+#ifdef SIDH_ASM
+#include "sidhlib/AMD64/fp_x64.c"
+#else
+#include "sidhlib/generic/fp_generic.c"
+#endif
+
+/* Allocate and deallocate context data structure */
+
+SIDH_CTX *SIDH_CTX_new(void) {
+	SIDH_CTX *ret;
+	ret = (SIDH_CTX *)OPENSSL_malloc(sizeof(SIDH_CTX));
+	if (ret == NULL) {
+	  SIDHerr(SIDH_F_SIDH_CTX_NEW, ERR_R_MALLOC_FAILURE);
+	  return (NULL);
+	}
+	ret->pCurveIsogeny = SIDH_curve_allocate(&CurveIsogeny_SIDHp751);
+	if (ret->pCurveIsogeny == NULL) {
+	  SIDHerr(SIDH_F_SIDH_CTX_NEW, ERR_R_MALLOC_FAILURE);
+	  goto err;
+	}
+	if (SIDH_curve_initialize(ret->pCurveIsogeny, &CurveIsogeny_SIDHp751) != CRYPTO_SUCCESS) {
+	  goto err;
+	}
+
+	return (ret);
+  err:
+	if (ret != NULL) {
+	  if (ret->pCurveIsogeny != NULL) {
+	    SIDH_curve_free(ret->pCurveIsogeny);
+	    ret->pCurveIsogeny = NULL;
+	  }
+	  OPENSSL_free(ret);
+	}
+  	return (NULL);
+}
+
+void SIDH_CTX_free(SIDH_CTX *ctx) {
+	if (ctx == NULL) return;
+	if (ctx != NULL) {
+	  if (ctx->pCurveIsogeny != NULL) {
+	    SIDH_curve_free(ctx->pCurveIsogeny);
+	    ctx->pCurveIsogeny = NULL;
+	  }
+	  OPENSSL_cleanse((void *)ctx, sizeof(SIDH_CTX));
+	  OPENSSL_free(ctx);
+	}
+}
+
+
+/* Allocate and deallocate public key data structure */
+SIDH_PUB *SIDH_PUB_new() {
+  SIDH_PUB *ret;
+  ret = (SIDH_PUB *)OPENSSL_malloc(sizeof(SIDH_PUB));
+  if (ret == NULL) {
+    SIDHerr(SIDH_F_SIDH_PUB_NEW, ERR_R_MALLOC_FAILURE);
+    return NULL;
+  }
+
+  ret->pubKey = (unsigned char*) OPENSSL_malloc(SIDH_PUBKEY_LEN);
+  if (ret->pubKey == NULL) {
+    SIDHerr(SIDH_F_SIDH_PUB_NEW, ERR_R_MALLOC_FAILURE);
+    SIDH_PUB_free(ret);
+    return NULL;
+  }
+  ret->version = 1;
+  ret->flags = 0;
+  ret->references = 1;
+
+  return ret;
+}
+
+SIDH_PUB *SIDH_PUB_copy(SIDH_PUB *dest, const SIDH_PUB *src) {
+  if (dest == NULL || src == NULL) {
+    SIDHerr(SIDH_F_SIDH_PUB_COPY, ERR_R_PASSED_NULL_PARAMETER);
+    return NULL;
+  }
+  /* copy the public key */
+  if (src->pubKey) {
+    int pubKeySize = SIDH_PUBKEY_LEN;
+    if (!dest->pubKey) {
+      dest->pubKey = (unsigned char*) OPENSSL_malloc(pubKeySize);
+    }
+    memcpy(dest->pubKey, src->pubKey, pubKeySize);
+  }
+
+  /* copy the rest */
+  dest->version = src->version;
+  dest->flags = src->flags;
+
+  return dest;
+}
+
+void SIDH_PUB_free(SIDH_PUB *r) {
+  int i;
+
+  if (r == NULL) return;
+
+  i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);
+#ifdef REF_PRINT
+  REF_PRINT("SIDH_PUB", r);
+#endif
+  if (i > 0) return;
+#ifdef REF_CHECK
+  if (i < 0) {
+    fprintf(stderr, "SIDH_PUB_free, bad reference count\n");
+    abort();
+  }
+#endif
+  if (r->pubKey) {
+    int pubKeySize = SIDH_PUBKEY_LEN;
+    OPENSSL_cleanse(r->pubKey, pubKeySize);
+    OPENSSL_free(r->pubKey);
+  }
+  OPENSSL_cleanse((void *)r, sizeof(SIDH_PUB));
+  OPENSSL_free(r);
+}
+
+/* Allocate and deallocate public key / private key pair data structure */
+
+SIDH_PAIR *SIDH_PAIR_new(void) {
+  SIDH_PAIR *ret;
+
+  ret = (SIDH_PAIR *)OPENSSL_malloc(sizeof(SIDH_PAIR));
+  if (ret == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_NEW, ERR_R_MALLOC_FAILURE);
+    return (NULL);
+  }
+
+  ret->version = 1;
+  ret->flags = 0;
+  ret->references = 1;
+
+  /* init the public key */
+  ret->pub = NULL;
+  ret->pub = SIDH_PUB_new();
+  if (ret->pub == NULL) {
+    return NULL;
+  }
+  ret->secretKey = (unsigned char*) OPENSSL_malloc(SIDH_SECRETKEY_LEN);
+  return (ret);
+}
+
+SIDH_PAIR *SIDH_PAIR_copy(SIDH_PAIR *dest, const SIDH_PAIR *src) {
+  if (dest == NULL || src == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_COPY, ERR_R_PASSED_NULL_PARAMETER);
+    return NULL;
+  }
+
+  /* copy the public key */
+
+  if (src->pub) {
+    if (dest->pub){
+      SIDH_PUB_free(dest->pub);
+    }
+    dest->pub = SIDH_PUB_new();
+    if (dest->pub == NULL) {
+      return NULL;
+    }
+    if (!SIDH_PUB_copy(dest->pub, src->pub)) {
+      return NULL;
+    }
+  }
+
+  /* copy the private key */
+  if (src->secretKey) {
+    if (!dest->secretKey) {
+      dest->secretKey = (unsigned char*) OPENSSL_malloc(SIDH_SECRETKEY_LEN);
+      memcpy(dest->secretKey, src->secretKey, SIDH_SECRETKEY_LEN);
+    }
+  }
+
+  /* copy the rest */
+  dest->version   = src->version;
+  dest->flags = src->flags;
+
+  return dest;
+}
+
+SIDH_PAIR *SIDH_PAIR_dup(const SIDH_PAIR *pair) {
+  SIDH_PAIR *ret = SIDH_PAIR_new();
+  if (ret == NULL) {
+    return NULL;
+  }
+  if (SIDH_PAIR_copy(ret, pair) == NULL) {
+    SIDH_PAIR_free(ret);
+    return NULL;
+  }
+  return ret;
+}
+
+void SIDH_PAIR_free(SIDH_PAIR *r) {
+  int i;
+
+  if (r == NULL) return;
+
+  i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);
+#ifdef REF_PRINT
+  REF_PRINT("SIDH_PAIR", r);
+#endif
+  if (i > 0) return;
+#ifdef REF_CHECK
+  if (i < 0) {
+    fprintf(stderr, "SIDH_PAIR_free, bad reference count\n");
+    abort();
+  }
+#endif
+
+  SIDH_PUB_free(r->pub);
+  OPENSSL_cleanse(r->secretKey, SIDH_SECRETKEY_LEN);
+  OPENSSL_free(r->secretKey);
+  OPENSSL_cleanse((void *)r, sizeof(SIDH_PAIR));
+  OPENSSL_free(r);
+}
+
+/* Generate key pair */
+
+int SIDH_PAIR_generate_key_server(SIDH_PAIR *key, SIDH_CTX *ctx) {
+  if (key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_SERVER, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  if (KeyGeneration_A(key->secretKey, key->pub->pubKey, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_SERVER, SIDH_R_KEX_FAILED);
+    return 0;
+  }
+  return 1;
+}
+
+int SIDH_PAIR_generate_key_client(SIDH_PAIR *key, SIDH_CTX *ctx) {
+  if (key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_CLIENT, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+
+  if (KeyGeneration_B(key->secretKey, key->pub->pubKey, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+    SIDHerr(SIDH_F_SIDH_PAIR_GENERATE_KEY_CLIENT, SIDH_R_KEX_FAILED);
+    return 0;
+  }
+  return 1;
+}
+
+/* Convert pubkey data structures from/to binary */
+SIDH_PUB *o2i_SIDH_PUB(SIDH_PUB **pub, const unsigned char *in, long len) {
+  if (pub == NULL) {
+    SIDHerr(SIDH_F_O2I_SIDH_PUB, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  if (*pub == NULL && (*pub = SIDH_PUB_new()) == NULL) {
+    SIDHerr(SIDH_F_O2I_SIDH_PUB, ERR_R_MALLOC_FAILURE);
+    return 0;
+  }
+
+  int expected_len = SIDH_PUBKEY_LEN;
+  if (len != expected_len) {
+    SIDHerr(SIDH_F_O2I_SIDH_PUB, SIDH_R_INVALID_LENGTH);
+    return 0;
+  }
+  memcpy((*pub)->pubKey, in, len);
+  return *pub;
+}
+
+int i2o_SIDH_PUB(SIDH_PUB *pub, unsigned char **out) {
+  size_t buf_len = 0;
+  int new_buffer = 0;
+
+  if (pub == NULL) {
+    SIDHerr(SIDH_F_I2O_SIDH_PUB, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  buf_len = SIDH_PUBKEY_LEN;
+
+  if (out == NULL )
+    return buf_len;
+
+  if (*out == NULL) {
+    if ((*out = OPENSSL_malloc(buf_len)) == NULL) {
+      SIDHerr(SIDH_F_I2O_SIDH_PUB, ERR_R_MALLOC_FAILURE);
+      return 0;
+    }
+    new_buffer = 1;
+  }
+  memcpy(*out, pub->pubKey, buf_len);
+  if (!new_buffer) {
+    *out += buf_len;
+  }
+  return buf_len;
+}
+
+/* Get public key from a key pair */
+SIDH_PUB *SIDH_PAIR_get_publickey(SIDH_PAIR *pair) {
+  if (pair == NULL) return NULL;
+  return pair->pub;
+}
+
+/* Does private key exist? */
+int SIDH_PAIR_has_privatekey(SIDH_PAIR *pair) {
+  return pair->secretKey != NULL;
+}
+
+/* Compute shared secret values */
+int SIDH_compute_key_server(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key, 
+			       void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx) {
+  int ret = -1;
+  if (peer_pub_key == NULL || priv_pub_key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_SERVER, ERR_R_PASSED_NULL_PARAMETER);    
+    return ret;
+  }
+
+  unsigned int sharedSecretA_len = SIDH_SHAREDKEY_LEN;
+  unsigned char *sharedSecretA = NULL;
+
+  if (out != NULL) {
+    sharedSecretA = (unsigned char*)OPENSSL_malloc(sharedSecretA_len);
+    if (SecretAgreement_A(priv_pub_key->secretKey, peer_pub_key->pubKey, sharedSecretA, false, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+      goto err;
+    }
+    if (KDF != 0) {
+      if (KDF((unsigned char *) sharedSecretA, sharedSecretA_len, out, &outlen) == NULL) {
+	SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_SERVER, SIDH_R_KDF_FAILED);
+	goto err;
+      }
+      ret = outlen;
+    } else {
+      /* no KDF, just copy as much as we can */
+      if (outlen > sharedSecretA_len) {
+	outlen = sharedSecretA_len;
+      }
+      memcpy(out, (unsigned char *) sharedSecretA, outlen);
+      ret = outlen;
+    }
+  }
+  else {
+    ret = sharedSecretA_len;    
+  }
+
+ err:
+  if (sharedSecretA) {
+    clear_words((void*)sharedSecretA, NBYTES_TO_NWORDS(sharedSecretA_len));
+    OPENSSL_free(sharedSecretA);
+  }
+  return (ret);
+}
+
+int SIDH_compute_key_client(void *out, size_t outlen, const SIDH_PUB *peer_pub_key, const SIDH_PAIR *priv_pub_key,
+			       void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen), SIDH_CTX *ctx) {
+  int ret = -1;
+  if (peer_pub_key == NULL || priv_pub_key == NULL || ctx == NULL) {
+    SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_CLIENT, ERR_R_PASSED_NULL_PARAMETER);    
+    return ret;
+  }
+
+  unsigned int sharedSecretB_len = SIDH_SHAREDKEY_LEN;
+  unsigned char *sharedSecretB = NULL;
+
+  if (out != NULL) {
+    sharedSecretB = (unsigned char*)OPENSSL_malloc(sharedSecretB_len);
+    if (SecretAgreement_B(priv_pub_key->secretKey, peer_pub_key->pubKey, sharedSecretB, false, ctx->pCurveIsogeny) != CRYPTO_SUCCESS) {
+      goto err;
+    }
+    if (KDF != 0) {
+      if (KDF((unsigned char *) sharedSecretB, sharedSecretB_len, out, &outlen) == NULL) {
+        SIDHerr(SIDH_F_SIDH_COMPUTE_KEY_CLIENT, SIDH_R_KDF_FAILED);
+        goto err;
+      }
+      ret = outlen;
+    } else {
+    /* no KDF, just copy as much as we can */
+    if (outlen > sharedSecretB_len) {
+      outlen = sharedSecretB_len;
+    }
+    memcpy(out, (unsigned char *) sharedSecretB, outlen);
+    ret = outlen;
+    }
+  }
+  else {
+    ret = sharedSecretB_len;    
+  }
+
+ err:
+  if (sharedSecretB) {
+    clear_words((void*)sharedSecretB, NBYTES_TO_NWORDS(sharedSecretB_len));
+    OPENSSL_free(sharedSecretB);
+  }
+  return (ret);
+}
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhkex_locl.h sidh/openssl-1.0.2g/crypto/sidh/sidhkex_locl.h
--- original/openssl-1.0.2g/crypto/sidh/sidhkex_locl.h	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhkex_locl.h	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,44 @@
+/* crypto/sidh/sidhkex_locl.h */
+
+#ifndef HEADER_SIDHKEX_LOCL_H
+#define HEADER_SIDHKEX_LOCL_H
+
+#include <openssl/sidh.h>
+#include "sidhlib/SIDH_internal.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+  /*
+   * FIXME: maybe this should have the actual values of pubKey, and not the encoding
+   *        this way the i2o_ and o2i_ functions would actually do something.
+   */
+
+  struct sidh_pub_st {
+    int version;
+    unsigned char* pubKey;
+    int references;
+    int	flags;
+  };
+
+  struct sidh_pair_st {
+    int version;
+    SIDH_PUB *pub;
+    unsigned char* secretKey;
+    int references;
+    int	flags;
+  };
+
+  struct sidh_ctx_st {
+    int version;
+    PCurveIsogenyStruct pCurveIsogeny;
+    int references;
+    int flags;
+  };
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* HEADER_SIDHKEX_LOCL_H */
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhkextest.c sidh/openssl-1.0.2g/crypto/sidh/sidhkextest.c
--- original/openssl-1.0.2g/crypto/sidh/sidhkextest.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhkextest.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,212 @@
+/* crypto/sidh/sidhkextest.c */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "../e_os.h"
+
+#include <openssl/opensslconf.h>
+#include <openssl/crypto.h>
+#include <openssl/bio.h>
+#include <openssl/bn.h>
+#include <openssl/objects.h>
+#include <openssl/rand.h>
+#include <openssl/sha.h>
+#include <openssl/err.h>
+
+#ifdef OPENSSL_NO_SIDH
+int main(int argc, char *argv[]) {
+	printf("No SIDH support\n");
+	return (0);
+}
+#else
+#include <openssl/sidh.h>
+
+#ifdef OPENSSL_SYS_WIN16
+#define MS_CALLBACK	_far _loadds
+#else
+#define MS_CALLBACK
+#endif
+
+static const char rnd_seed[] = "string to make the random number generator think it has entropy";
+
+static const int KDF1_SHA1_len = 20;
+static void *KDF1_SHA1(const void *in, size_t inlen, void *out, size_t *outlen) {
+#ifndef OPENSSL_NO_SHA
+	if (*outlen < SHA_DIGEST_LENGTH)
+		return NULL;
+	else
+		*outlen = SHA_DIGEST_LENGTH;
+	return SHA1(in, inlen, out);
+#else
+	return NULL;
+#endif
+}
+
+static int test_sidhkex(BIO *out, int single) {
+
+	SIDH_PAIR *server = NULL;
+	SIDH_PAIR *client = NULL;
+	SIDH_PUB *server_reconstructed = NULL, *client_reconstructed = NULL;
+	SIDH_CTX *ctx = NULL;
+
+	unsigned char *server_pub_buffer = NULL, *client_pub_buffer = NULL;
+	size_t server_pub_len = 0, client_pub_len = 0;
+
+	unsigned char *server_sharedkey_buffer = NULL, *client_sharedkey_buffer = NULL;
+	size_t server_sharedkey_len = 0, client_sharedkey_len = 0;
+
+	int i, ret = 0;
+
+	ctx = SIDH_CTX_new();
+	server = SIDH_PAIR_new();
+	server_reconstructed = SIDH_PUB_new();
+	client = SIDH_PAIR_new();
+	client_reconstructed = SIDH_PUB_new();
+	if ((ctx == NULL) || (server == NULL) || (client == NULL) || (server_reconstructed == NULL) || (client_reconstructed == NULL) ) {
+	  goto err;
+	}
+
+	if (single) BIO_puts(out, "Testing key generation\n");
+
+	if (!SIDH_PAIR_generate_key_server(server, ctx)) goto err;
+	if (!SIDH_PAIR_generate_key_client(client, ctx)) goto err;
+	server_pub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(server), &server_pub_buffer);
+	if (single) BIO_printf(out, "  pub_A (%i bytes) = ", (int)server_pub_len);
+	if (server_pub_len <= 0) {
+		fprintf(stderr, "Error in SIDH routines\n");
+		ret = 0;
+		goto err;
+	}
+	if (single) {
+		for (i = 0; i < server_pub_len; i++) {
+			BIO_printf(out, "%02X", server_pub_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	if (single) BIO_puts(out, "Testing Client shared secret generation\n");
+
+	if (o2i_SIDH_PUB(&server_reconstructed, server_pub_buffer, server_pub_len) == NULL) {
+		fprintf(stderr, "Error in SIDH routines (Server public key reconstruction)\n");
+		ret = 0;
+		goto err;
+	}
+
+	client_sharedkey_len = KDF1_SHA1_len;
+	client_sharedkey_buffer = (unsigned char *)OPENSSL_malloc(client_sharedkey_len);
+	client_sharedkey_len = SIDH_compute_key_client(client_sharedkey_buffer, client_sharedkey_len, 
+							  server_reconstructed, client, KDF1_SHA1, ctx);
+	if (single) {
+		BIO_printf(out, "  key_B (%i bytes) = ", (int)client_sharedkey_len);
+		for (i = 0; i < client_sharedkey_len; i++) {
+			BIO_printf(out, "%02X", client_sharedkey_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	client_pub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(client), &client_pub_buffer);
+	if (single) {
+		BIO_printf(out, "\n  pub_B (%i bytes) = ", (int)client_pub_len);
+		for (i = 0; i < client_pub_len; i++) {
+			BIO_printf(out, "%02X", client_pub_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	if (single) BIO_puts(out, "Reconstructing Client's values\n");
+
+	if (o2i_SIDH_PUB(&client_reconstructed, client_pub_buffer, client_pub_len) == NULL) {
+		fprintf(stderr, "Error in SIDH routines (Client public key reconstruction)\n");
+		ret = 0;
+		goto err;
+	}
+
+	if (single) BIO_puts(out, "Testing Server shared secret generation\n");
+
+	server_sharedkey_len = KDF1_SHA1_len;
+	server_sharedkey_buffer = (unsigned char *)OPENSSL_malloc(server_sharedkey_len);
+	server_sharedkey_len = SIDH_compute_key_server(server_sharedkey_buffer, server_sharedkey_len, client_reconstructed, server, KDF1_SHA1, ctx);
+	if (single) {
+		BIO_printf(out, "  key_A (%i bytes) = ", (int)server_sharedkey_len);
+		for (i = 0; i < server_sharedkey_len; i++) {
+			BIO_printf(out, "%02X", server_sharedkey_buffer[i]);
+		}
+		BIO_puts(out, "\n");
+	}
+
+	if ((client_sharedkey_len != server_sharedkey_len) || (memcmp(server_sharedkey_buffer, client_sharedkey_buffer, server_sharedkey_len) != 0)) {
+		BIO_printf(out, " failed\n\n");
+		fprintf(stderr, "Error in SIDH routines (mismatched shared secrets)\n");
+		ret = 0;
+	}
+	else {
+		if (single) BIO_printf(out, "ok!\n");
+		ret = 1;
+	}
+err:
+	ERR_print_errors_fp(stderr);
+
+	OPENSSL_free(client_sharedkey_buffer);
+	OPENSSL_free(server_sharedkey_buffer);
+	OPENSSL_free(server_pub_buffer);
+	OPENSSL_free(client_pub_buffer);
+	SIDH_PUB_free(server_reconstructed);
+	SIDH_PUB_free(client_reconstructed);
+	SIDH_PAIR_free(client);
+	SIDH_PAIR_free(server);
+	SIDH_CTX_free(ctx);
+	return (ret);
+}
+
+int main(int argc, char *argv[]) {
+	int ret = 1;
+	BIO *out;
+
+	CRYPTO_malloc_debug_init();
+	CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
+	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+#ifdef OPENSSL_SYS_WIN32
+	CRYPTO_malloc_init();
+#endif
+
+	RAND_seed(rnd_seed, sizeof rnd_seed);
+
+	out = BIO_new(BIO_s_file());
+	if (out == NULL) EXIT(1);
+	BIO_set_fp(out, stdout, BIO_NOCLOSE);
+
+	if (argc == 1) {
+		if (!test_sidhkex(out, 1)) goto err;
+	} else {
+		int iterations = 0;
+		int failures = 0;
+		time_t starttime = time(NULL);
+		while (1) {
+			iterations++;
+			if (test_sidhkex(out, 0) == 1) {
+			} else {
+				failures++;
+			}
+			if ((iterations % 100) == 0) {
+				BIO_printf(out, "Iterations: %d, failures: %d, elapsed time: %ld\n", iterations, failures, time(NULL) - starttime);
+			}
+		}
+	}
+
+	ret = 0;
+
+err:
+	ERR_print_errors_fp(stderr);
+	BIO_free(out);
+	CRYPTO_cleanup_all_ex_data();
+	ERR_remove_thread_state(NULL);
+	CRYPTO_mem_leaks_fp(stderr);
+	EXIT(ret);
+	return (ret);
+}
+
+#endif
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S sidh/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64_asm.S	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,1864 @@
+//*******************************************************************************************
+// SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+//       exchange providing 128 bits of quantum security and 192 bits of classical security.
+//
+//    Copyright (c) Microsoft Corporation. All rights reserved.
+//
+//
+// Abstract: field arithmetic in x64 assembly for Linux 
+//
+//*******************************************************************************************  
+
+.intel_syntax noprefix 
+
+// Registers that are used for parameter passing:
+#define reg_p1  rdi
+#define reg_p2  rsi
+#define reg_p3  rdx
+
+// p751 + 1
+#define p751p1_5   0xEEB0000000000000
+#define p751p1_6   0xE3EC968549F878A8
+#define p751p1_7   0xDA959B1A13F7CC76
+#define p751p1_8   0x084E9867D6EBE876
+#define p751p1_9   0x8562B5045CB25748
+#define p751p1_10  0x0E12909F97BADC66
+#define p751p1_11  0x00006FE5D541F71C
+
+#define p751_0     0xFFFFFFFFFFFFFFFF
+#define p751_5     0xEEAFFFFFFFFFFFFF
+#define p751_6     0xE3EC968549F878A8
+#define p751_7     0xDA959B1A13F7CC76
+#define p751_8     0x084E9867D6EBE876
+#define p751_9     0x8562B5045CB25748
+#define p751_10    0x0E12909F97BADC66
+#define p751_11    0x00006FE5D541F71C
+
+#define p751x2_0   0xFFFFFFFFFFFFFFFE
+#define p751x2_1   0xFFFFFFFFFFFFFFFF
+#define p751x2_5   0xDD5FFFFFFFFFFFFF
+#define p751x2_6   0xC7D92D0A93F0F151
+#define p751x2_7   0xB52B363427EF98ED
+#define p751x2_8   0x109D30CFADD7D0ED
+#define p751x2_9   0x0AC56A08B964AE90
+#define p751x2_10  0x1C25213F2F75B8CD
+#define p751x2_11  0x0000DFCBAA83EE38
+
+
+.text
+//***********************************************************************
+//  Field addition
+//  Operation: c [reg_p3] = a [reg_p1] + b [reg_p2]
+//*********************************************************************** 
+.global fpadd751_asm
+fpadd751_asm:
+  push   r12
+  push   r13
+  push   r14
+  push   r15
+  
+  mov    r8, [reg_p1]
+  mov    r9, [reg_p1+8]
+  mov    r10, [reg_p1+16]
+  mov    r11, [reg_p1+24]
+  mov    r12, [reg_p1+32]
+  mov    r13, [reg_p1+40]
+  mov    r14, [reg_p1+48]
+  mov    r15, [reg_p1+56] 
+  mov    rcx, [reg_p1+64]
+  add    r8, [reg_p2] 
+  adc    r9, [reg_p2+8] 
+  adc    r10, [reg_p2+16] 
+  adc    r11, [reg_p2+24] 
+  adc    r12, [reg_p2+32] 
+  adc    r13, [reg_p2+40] 
+  adc    r14, [reg_p2+48] 
+  adc    r15, [reg_p2+56]
+  adc    rcx, [reg_p2+64] 
+  mov    rax, [reg_p1+72]
+  adc    rax, [reg_p2+72] 
+  mov    [reg_p3+72], rax
+  mov    rax, [reg_p1+80]
+  adc    rax, [reg_p2+80] 
+  mov    [reg_p3+80], rax
+  mov    rax, [reg_p1+88]
+  adc    rax, [reg_p2+88] 
+  mov    [reg_p3+88], rax
+
+  movq   rax, p751x2_0
+  sub    r8, rax
+  movq   rax, p751x2_1
+  sbb    r9, rax
+  sbb    r10, rax
+  sbb    r11, rax
+  sbb    r12, rax
+  movq   rax, p751x2_5
+  sbb    r13, rax
+  movq   rax, p751x2_6
+  sbb    r14, rax
+  movq   rax, p751x2_7
+  sbb    r15, rax
+  movq   rax, p751x2_8
+  sbb    rcx, rax
+  mov    [reg_p3], r8
+  mov    [reg_p3+8], r9
+  mov    [reg_p3+16], r10
+  mov    [reg_p3+24], r11
+  mov    [reg_p3+32], r12
+  mov    [reg_p3+40], r13
+  mov    [reg_p3+48], r14
+  mov    [reg_p3+56], r15
+  mov    [reg_p3+64], rcx
+  mov    r8, [reg_p3+72]
+  mov    r9, [reg_p3+80]
+  mov    r10, [reg_p3+88]
+  movq   rax, p751x2_9
+  sbb    r8, rax
+  movq   rax, p751x2_10
+  sbb    r9, rax
+  movq   rax, p751x2_11
+  sbb    r10, rax
+  mov    [reg_p3+72], r8
+  mov    [reg_p3+80], r9
+  mov    [reg_p3+88], r10
+  movq   rax, 0
+  sbb    rax, 0
+  
+  mov    rsi, p751x2_0
+  and    rsi, rax
+  mov    r8, p751x2_1
+  and    r8, rax
+  movq   r9, p751x2_5
+  and    r9, rax
+  movq   r10, p751x2_6
+  and    r10, rax
+  movq   r11, p751x2_7
+  and    r11, rax
+  movq   r12, p751x2_8
+  and    r12, rax
+  movq   r13, p751x2_9
+  and    r13, rax
+  movq   r14, p751x2_10
+  and    r14, rax
+  movq   r15, p751x2_11
+  and    r15, rax
+  
+  mov    rax, [reg_p3]
+  add    rax, rsi  
+  mov    [reg_p3], rax
+  mov    rax, [reg_p3+8]
+  adc    rax, r8 
+  mov    [reg_p3+8], rax  
+  mov    rax, [reg_p3+16]
+  adc    rax, r8 
+  mov    [reg_p3+16], rax  
+  mov    rax, [reg_p3+24]  
+  adc    rax, r8 
+  mov    [reg_p3+24], rax 
+  mov    rax, [reg_p3+32]  
+  adc    rax, r8 
+  mov    [reg_p3+32], rax 
+  mov    rax, [reg_p3+40]    
+  adc    rax, r9 
+  mov    [reg_p3+40], rax 
+  mov    rax, [reg_p3+48]   
+  adc    rax, r10 
+  mov    [reg_p3+48], rax 
+  mov    rax, [reg_p3+56]   
+  adc    rax, r11  
+  mov    [reg_p3+56], rax 
+  mov    rax, [reg_p3+64]  
+  adc    rax, r12 
+  mov    [reg_p3+64], rax 
+  mov    rax, [reg_p3+72]   
+  adc    rax, r13 
+  mov    [reg_p3+72], rax 
+  mov    rax, [reg_p3+80]   
+  adc    rax, r14 
+  mov    [reg_p3+80], rax 
+  mov    rax, [reg_p3+88]   
+  adc    rax, r15
+  mov    [reg_p3+88], rax 
+  
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
+
+
+//***********************************************************************
+//  Field subtraction
+//  Operation: c [reg_p3] = a [reg_p1] - b [reg_p2]
+//*********************************************************************** 
+.global fpsub751_asm
+fpsub751_asm:
+  push   r12
+  push   r13
+  push   r14
+  push   r15
+  
+  mov    r8, [reg_p1]
+  mov    r9, [reg_p1+8]
+  mov    r10, [reg_p1+16]
+  mov    r11, [reg_p1+24]
+  mov    r12, [reg_p1+32]
+  mov    r13, [reg_p1+40]
+  mov    r14, [reg_p1+48]
+  mov    r15, [reg_p1+56] 
+  mov    rcx, [reg_p1+64]
+  sub    r8, [reg_p2] 
+  sbb    r9, [reg_p2+8] 
+  sbb    r10, [reg_p2+16] 
+  sbb    r11, [reg_p2+24] 
+  sbb    r12, [reg_p2+32] 
+  sbb    r13, [reg_p2+40] 
+  sbb    r14, [reg_p2+48] 
+  sbb    r15, [reg_p2+56]
+  sbb    rcx, [reg_p2+64] 
+  mov    [reg_p3], r8
+  mov    [reg_p3+8], r9
+  mov    [reg_p3+16], r10
+  mov    [reg_p3+24], r11
+  mov    [reg_p3+32], r12
+  mov    [reg_p3+40], r13
+  mov    [reg_p3+48], r14
+  mov    [reg_p3+56], r15
+  mov    [reg_p3+64], rcx
+  mov    rax, [reg_p1+72]
+  sbb    rax, [reg_p2+72] 
+  mov    [reg_p3+72], rax
+  mov    rax, [reg_p1+80]
+  sbb    rax, [reg_p2+80] 
+  mov    [reg_p3+80], rax
+  mov    rax, [reg_p1+88]
+  sbb    rax, [reg_p2+88] 
+  mov    [reg_p3+88], rax
+  movq   rax, 0
+  sbb    rax, 0
+  
+  mov    rsi, p751x2_0
+  and    rsi, rax
+  mov    r8, p751x2_1
+  and    r8, rax
+  movq   r9, p751x2_5
+  and    r9, rax
+  movq   r10, p751x2_6
+  and    r10, rax
+  movq   r11, p751x2_7
+  and    r11, rax
+  movq   r12, p751x2_8
+  and    r12, rax
+  movq   r13, p751x2_9
+  and    r13, rax
+  movq   r14, p751x2_10
+  and    r14, rax
+  movq   r15, p751x2_11
+  and    r15, rax
+  
+  mov    rax, [reg_p3]
+  add    rax, rsi  
+  mov    [reg_p3], rax
+  mov    rax, [reg_p3+8]
+  adc    rax, r8 
+  mov    [reg_p3+8], rax  
+  mov    rax, [reg_p3+16]
+  adc    rax, r8 
+  mov    [reg_p3+16], rax  
+  mov    rax, [reg_p3+24]  
+  adc    rax, r8 
+  mov    [reg_p3+24], rax 
+  mov    rax, [reg_p3+32]  
+  adc    rax, r8 
+  mov    [reg_p3+32], rax 
+  mov    rax, [reg_p3+40]    
+  adc    rax, r9 
+  mov    [reg_p3+40], rax 
+  mov    rax, [reg_p3+48]   
+  adc    rax, r10 
+  mov    [reg_p3+48], rax 
+  mov    rax, [reg_p3+56]   
+  adc    rax, r11  
+  mov    [reg_p3+56], rax 
+  mov    rax, [reg_p3+64]  
+  adc    rax, r12 
+  mov    [reg_p3+64], rax 
+  mov    rax, [reg_p3+72]   
+  adc    rax, r13 
+  mov    [reg_p3+72], rax 
+  mov    rax, [reg_p3+80]   
+  adc    rax, r14 
+  mov    [reg_p3+80], rax 
+  mov    rax, [reg_p3+88]   
+  adc    rax, r15
+  mov    [reg_p3+88], rax 
+  
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
+
+
+//***********************************************************************
+//  Integer multiplication
+//  Based on Karatsuba method
+//  Operation: c [reg_p3] = a [reg_p1] * b [reg_p2]
+//  NOTE: a=c or b=c are not allowed
+//***********************************************************************
+.global mul751_asm
+mul751_asm:
+  push   r12
+  push   r13
+  push   r14
+  mov    rcx, reg_p3
+  
+  // rcx[0-5] <- AH+AL
+  xor    rax, rax
+  mov    r8, [reg_p1+48]
+  mov    r9, [reg_p1+56]
+  mov    r10, [reg_p1+64]
+  mov    r11, [reg_p1+72]
+  mov    r12, [reg_p1+80]
+  mov    r13, [reg_p1+88]
+  add    r8, [reg_p1] 
+  adc    r9, [reg_p1+8] 
+  adc    r10, [reg_p1+16] 
+  adc    r11, [reg_p1+24] 
+  adc    r12, [reg_p1+32] 
+  adc    r13, [reg_p1+40] 
+  push   r15  
+  mov    [rcx], r8
+  mov    [rcx+8], r9
+  mov    [rcx+16], r10
+  mov    [rcx+24], r11
+  mov    [rcx+32], r12
+  mov    [rcx+40], r13
+  sbb    rax, 0 
+  sub    rsp, 96           // Allocating space in stack
+       
+  // rcx[6-11] <- BH+BL
+  xor    rdx, rdx
+  mov    r8, [reg_p2+48]
+  mov    r9, [reg_p2+56]
+  mov    r10, [reg_p2+64]
+  mov    r11, [reg_p2+72]
+  mov    r12, [reg_p2+80]
+  mov    r13, [reg_p2+88]
+  add    r8, [reg_p2] 
+  adc    r9, [reg_p2+8] 
+  adc    r10, [reg_p2+16] 
+  adc    r11, [reg_p2+24] 
+  adc    r12, [reg_p2+32] 
+  adc    r13, [reg_p2+40] 
+  mov    [rcx+48], r8
+  mov    [rcx+56], r9
+  mov    [rcx+64], r10
+  mov    [rcx+72], r11
+  mov    [rcx+80], r12
+  mov    [rcx+88], r13
+  sbb    rdx, 0 
+  mov    [rsp+80], rax
+  mov    [rsp+88], rdx
+  
+  // (rsp[0-8],r10,r8,r9) <- (AH+AL)*(BH+BL)
+  mov    r11, [rcx]
+  mov    rax, r8 
+  mul    r11
+  mov    [rsp], rax        // c0
+  mov    r14, rdx
+  
+  xor    r15, r15
+  mov    rax, r9
+  mul    r11
+  xor    r9, r9
+  add    r14, rax
+  adc    r9, rdx
+  
+  mov    r12, [rcx+8] 
+  mov    rax, r8 
+  mul    r12
+  add    r14, rax
+  mov    [rsp+8], r14      // c1 
+  adc    r9, rdx
+  adc    r15, 0
+  
+  xor    r8, r8
+  mov    rax, r10 
+  mul    r11
+  add    r9, rax
+  mov    r13, [rcx+48] 
+  adc    r15, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+16] 
+  mul    r13
+  add    r9, rax
+  adc    r15, rdx 
+  mov    rax, [rcx+56] 
+  adc    r8, 0
+  
+  mul    r12
+  add    r9, rax
+  mov    [rsp+16], r9      // c2 
+  adc    r15, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [rcx+72] 
+  mul    r11
+  add    r15, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+24] 
+  mul    r13
+  add    r15, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, r10 
+  mul    r12
+  add    r15, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r14, [rcx+16] 
+  mov    rax, [rcx+56] 
+  mul    r14
+  add    r15, rax
+  mov    [rsp+24], r15     // c3 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [rcx+80] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+64] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r15, [rcx+48] 
+  mov    rax, [rcx+32] 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r13, [rcx+24] 
+  mov    rax, [rcx+56] 
+  mul    r13
+  add    r8, rax
+  mov    [rsp+32], r8      // c4 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [rcx+88] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+64] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+40] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+80] 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r15, [rcx+32] 
+  mov    rax, [rcx+56] 
+  mul    r15
+  add    r9, rax
+  mov    [rsp+40], r9      // c5 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [rcx+64] 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+88] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+80] 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r11, [rcx+40] 
+  mov    rax, [rcx+56] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r13
+  add    r10, rax
+  mov    [rsp+48], r10     // c6 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [rcx+88] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+64] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+80]
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [rcx+72] 
+  mul    r15
+  add    r8, rax
+  mov    [rsp+56], r8      // c7 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [rcx+72] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+80] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [rcx+88] 
+  mul    r13
+  add    r9, rax
+  mov    [rsp+64], r9      // c8 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [rcx+88]
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [rcx+80] 
+  mul    r11
+  add    r10, rax          // c9 
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [rcx+88] 
+  mul    r11
+  add    r8, rax           // c10 
+  adc    r9, rdx           // c11 
+  
+  mov    rax, [rsp+88]
+  mov    rdx, [rcx]
+  and    r12, rax
+  and    r14, rax
+  and    rdx, rax
+  and    r13, rax
+  and    r15, rax
+  and    r11, rax
+  mov    rax, [rsp+48]
+  add    rdx, rax
+  mov    rax, [rsp+56]
+  adc    r12, rax
+  mov    rax, [rsp+64]
+  adc    r14, rax
+  adc    r13, r10
+  adc    r15, r8
+  adc    r11, r9
+  mov    rax, [rsp+80]
+  mov    [rsp+48], rdx
+  mov    [rsp+56], r12
+  mov    [rsp+64], r14
+  mov    [rsp+72], r13
+  mov    [rsp+80], r15
+  mov    [rsp+88], r11
+  
+  mov    r8, [rcx+48]
+  mov    r9, [rcx+56]
+  mov    r10, [rcx+64]
+  mov    r11, [rcx+72]
+  mov    r12, [rcx+80]
+  mov    r13, [rcx+88]
+  and    r8, rax
+  and    r9, rax
+  and    r10, rax
+  and    r11, rax
+  and    r12, rax
+  and    r13, rax
+  mov    rax, [rsp+48]
+  add    r8, rax
+  mov    rax, [rsp+56]
+  adc    r9, rax
+  mov    rax, [rsp+64]
+  adc    r10, rax
+  mov    rax, [rsp+72]
+  adc    r11, rax
+  mov    rax, [rsp+80]
+  adc    r12, rax
+  mov    rax, [rsp+88]
+  adc    r13, rax
+  mov    [rsp+48], r8
+  mov    [rsp+56], r9
+  mov    [rsp+72], r11
+  
+  // rcx[0-11] <- AL*BL
+  mov    r11, [reg_p1]
+  mov    rax, [reg_p2] 
+  mul    r11
+  xor    r9, r9
+  mov    [rcx], rax        // c0
+  mov    [rsp+64], r10
+  mov    r8, rdx
+
+  mov    rax, [reg_p2+8]
+  mul    r11
+  xor    r10, r10
+  add    r8, rax
+  mov    [rsp+80], r12
+  adc    r9, rdx
+
+  mov    r12, [reg_p1+8] 
+  mov    rax, [reg_p2] 
+  mul    r12
+  add    r8, rax
+  mov    [rcx+8], r8       // c1 
+  adc    r9, rdx
+  mov    [rsp+88], r13
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+16] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r13, [reg_p2] 
+  mov    rax, [reg_p1+16] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+8] 
+  mul    r12
+  add    r9, rax
+  mov    [rcx+16], r9      // c2 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+24] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p1+24] 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r14, [reg_p1+16] 
+  mov    rax, [reg_p2+8] 
+  mul    r14
+  add    r10, rax
+  mov    [rcx+24], r10     // c3 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+32] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p1+32] 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r13, [reg_p1+24] 
+  mov    rax, [reg_p2+8] 
+  mul    r13
+  add    r8, rax
+  mov    [rcx+32], r8      // c4 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+40] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r11, [reg_p1+40] 
+  mov    rax, [reg_p2] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+32] 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r15, [reg_p1+32] 
+  mov    rax, [reg_p2+8] 
+  mul    r15
+  add    r9, rax
+  mov    [rcx+40], r9      // c5 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+16] 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+40] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+32] 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+8] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r13
+  add    r10, rax
+  mov    [rcx+48], r10     // c6 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+40] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+16] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+32]
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+24] 
+  mul    r15
+  add    r8, rax
+  mov    [rcx+56], r8      // c7 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+24] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+32] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+40] 
+  mul    r13
+  add    r9, rax
+  mov    [rcx+64], r9     // c8 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+40]
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [reg_p2+32] 
+  mul    r11
+  add    r10, rax
+  mov    [rcx+72], r10     // c9 
+  adc    r8, rdx
+  adc    r9, 0
+
+  mov    rax, [reg_p2+40] 
+  mul    r11
+  add    r8, rax
+  mov    [rcx+80], r8      // c10 
+  adc    r9, rdx   
+  mov    [rcx+88], r9      // c11 
+
+  // rcx[12-23] <- AH*BH
+  mov    r11, [reg_p1+48]
+  mov    rax, [reg_p2+48] 
+  mul    r11
+  xor    r9, r9
+  mov    [rcx+96], rax       // c0
+  mov    r8, rdx
+
+  mov    rax, [reg_p2+56]
+  mul    r11
+  xor    r10, r10
+  add    r8, rax
+  adc    r9, rdx
+
+  mov    r12, [reg_p1+56] 
+  mov    rax, [reg_p2+48] 
+  mul    r12
+  add    r8, rax
+  mov    [rcx+104], r8      // c1 
+  adc    r9, rdx
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+64] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r13, [reg_p2+48] 
+  mov    rax, [reg_p1+64] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+56] 
+  mul    r12
+  add    r9, rax
+  mov    [rcx+112], r9     // c2 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+72] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p1+72] 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    r14, [reg_p1+64] 
+  mov    rax, [reg_p2+56] 
+  mul    r14
+  add    r10, rax
+  mov    [rcx+120], r10    // c3 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+80] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r15, [reg_p1+80] 
+  mov    rax, r13 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    r13, [reg_p1+72] 
+  mov    rax, [reg_p2+56] 
+  mul    r13
+  add    r8, rax
+  mov    [rcx+128], r8     // c4 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+88] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    r11, [reg_p1+88] 
+  mov    rax, [reg_p2+48] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+80] 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+56] 
+  mul    r15
+  add    r9, rax
+  mov    [rcx+136], r9     // c5 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  xor    r9, r9
+  mov    rax, [reg_p2+64] 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+88] 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+80] 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+56] 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r13
+  add    r10, rax
+  mov    [rcx+144], r10    // c6 
+  adc    r8, rdx 
+  adc    r9, 0
+  
+  xor    r10, r10
+  mov    rax, [reg_p2+88] 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+64] 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+80]
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  mov    rax, [reg_p2+72] 
+  mul    r15
+  add    r8, rax
+  mov    [rcx+152], r8     // c7 
+  adc    r9, rdx 
+  adc    r10, 0
+  
+  xor    r8, r8
+  mov    rax, [reg_p2+72] 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+80] 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+88] 
+  mul    r13
+  add    r9, rax
+  mov    [rcx+160], r9     // c8 
+  adc    r10, rdx 
+  adc    r8, 0
+  
+  mov    rax, [reg_p2+88]
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+
+  mov    rax, [reg_p2+80] 
+  mul    r11
+  add    r10, rax
+  mov    [rcx+168], r10     // c9 
+  adc    r8, rdx
+
+  mov    rax, [reg_p2+88] 
+  mul    r11
+  add    r8, rax
+  mov    [rcx+176], r8      // c10 
+  adc    rdx, 0   
+  mov    [rcx+184], rdx     // c11  
+      
+  // [r8-r15,rax,rdx,rdi,[rsp]] <- (AH+AL)*(BH+BL) - AL*BL 
+  mov    r8,  [rsp]
+  sub    r8,  [rcx] 
+  mov    r9,  [rsp+8]
+  sbb    r9,  [rcx+8]
+  mov    r10, [rsp+16]
+  sbb    r10, [rcx+16]
+  mov    r11, [rsp+24]
+  sbb    r11, [rcx+24] 
+  mov    r12, [rsp+32]
+  sbb    r12, [rcx+32]
+  mov    r13, [rsp+40]
+  sbb    r13, [rcx+40] 
+  mov    r14, [rsp+48]
+  sbb    r14, [rcx+48] 
+  mov    r15, [rsp+56]
+  sbb    r15, [rcx+56] 
+  mov    rax, [rsp+64]
+  sbb    rax, [rcx+64]
+  mov    rdx, [rsp+72]
+  sbb    rdx, [rcx+72] 
+  mov    rdi, [rsp+80]
+  sbb    rdi, [rcx+80] 
+  mov    rsi, [rsp+88]
+  sbb    rsi, [rcx+88] 
+  mov    [rsp], rsi
+      
+  // [r8-r15,rax,rdx,rdi,[rsp]] <- (AH+AL)*(BH+BL) - AL*BL - AH*BH
+  mov    rsi, [rcx+96]
+  sub    r8,  rsi 
+  mov    rsi, [rcx+104]
+  sbb    r9,  rsi
+  mov    rsi, [rcx+112]
+  sbb    r10, rsi
+  mov    rsi, [rcx+120]
+  sbb    r11, rsi 
+  mov    rsi, [rcx+128]
+  sbb    r12, rsi
+  mov    rsi, [rcx+136]
+  sbb    r13, rsi
+  mov    rsi, [rcx+144]
+  sbb    r14, rsi 
+  mov    rsi, [rcx+152]
+  sbb    r15, rsi 
+  mov    rsi, [rcx+160]
+  sbb    rax, rsi
+  mov    rsi, [rcx+168]
+  sbb    rdx, rsi
+  mov    rsi, [rcx+176] 
+  sbb    rdi, rsi
+  mov    rsi, [rsp] 
+  sbb    rsi, [rcx+184]
+      
+  // Final result
+  add    r8,  [rcx+48] 
+  mov    [rcx+48], r8
+  adc    r9,  [rcx+56]
+  mov    [rcx+56], r9
+  adc    r10, [rcx+64]
+  mov    [rcx+64], r10
+  adc    r11, [rcx+72]
+  mov    [rcx+72], r11
+  adc    r12, [rcx+80]
+  mov    [rcx+80], r12
+  adc    r13, [rcx+88]
+  mov    [rcx+88], r13
+  adc    r14, [rcx+96] 
+  mov    [rcx+96], r14
+  adc    r15, [rcx+104] 
+  mov    [rcx+104], r15
+  adc    rax, [rcx+112]
+  mov    [rcx+112], rax
+  adc    rdx, [rcx+120]
+  mov    [rcx+120], rdx
+  adc    rdi, [rcx+128]
+  mov    [rcx+128], rdi
+  adc    rsi, [rcx+136]
+  mov    [rcx+136], rsi  
+  mov    rax, [rcx+144]
+  adc    rax, 0
+  mov    [rcx+144], rax
+  mov    rax, [rcx+152]
+  adc    rax, 0
+  mov    [rcx+152], rax
+  mov    rax, [rcx+160]
+  adc    rax, 0
+  mov    [rcx+160], rax
+  mov    rax, [rcx+168]
+  adc    rax, 0
+  mov    [rcx+168], rax
+  mov    rax, [rcx+176]
+  adc    rax, 0
+  mov    [rcx+176], rax
+  mov    rax, [rcx+184]
+  adc    rax, 0
+  mov    [rcx+184], rax
+    
+  add    rsp, 96           // Restoring space in stack
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
+
+  
+//***********************************************************************
+//  Montgomery reduction
+//  Based on comba method
+//  Operation: c [reg_p2] = a [reg_p1]
+//  NOTE: a=c is not allowed
+//*********************************************************************** 
+.global rdc751_asm
+rdc751_asm:
+  push   r12
+  push   r13 
+  push   r14 
+  push   r15 
+
+  mov    r11, [reg_p1]
+  movq   rax, p751p1_5 
+  mul    r11
+  xor    r8, r8
+  add    rax, [reg_p1+40]
+  mov    [reg_p2+40], rax    // z5
+  adc    r8, rdx
+  
+  xor    r9, r9
+  movq   rax, p751p1_6 
+  mul    r11
+  xor    r10, r10
+  add    r8, rax
+  adc    r9, rdx
+
+  mov    r12, [reg_p1+8]
+  movq   rax, p751p1_5 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+48]
+  mov    [reg_p2+48], r8    // z6
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_7 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_6 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    r13, [reg_p1+16]
+  movq   rax, p751p1_5 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+56]
+  mov    [reg_p2+56], r9    // z7
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_8 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  mov    r14, [reg_p1+24]
+  movq   rax, p751p1_5 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+64]
+  mov    [reg_p2+64], r10   // z8
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_9 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_6 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  mov    r15, [reg_p1+32]
+  movq   rax, p751p1_5 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+72]
+  mov    [reg_p2+72], r8    // z9
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_10 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_9 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_8 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_7 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_6 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    rcx, [reg_p2+40]
+  movq   rax, p751p1_5 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+80]
+  mov    [reg_p2+80], r9    // z10
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_8 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  mov    r11, [reg_p2+48]
+  movq   rax, p751p1_5 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+88]
+  mov    [reg_p2+88], r10    // z11
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_10 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_9 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_6 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  mov    r12, [reg_p2+56]
+  movq   rax, p751p1_5 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+96]
+  mov    [reg_p2], r8        // z0
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_11 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_10 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_9
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_8
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_7
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+
+  movq   rax, p751p1_6
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    r13, [reg_p2+64]
+  movq   rax, p751p1_5
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+104]
+  mov    [reg_p2+8], r9      // z1
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_8 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  mov    r14, [reg_p2+72]
+  movq   rax, p751p1_5 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+112]
+  mov    [reg_p2+16], r10    // z2
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_10 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_9 
+  mul    r11
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_6 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  mov    r15, [reg_p2+80]
+  movq   rax, p751p1_5 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+120]
+  mov    [reg_p2+24], r8     // z3
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_11 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_10 
+  mul    r11
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_9 
+  mul    r12
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_8 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_7 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_6 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  mov    rcx, [reg_p2+88]
+  movq   rax, p751p1_5 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+128]
+  mov    [reg_p2+32], r9     // z4
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r11
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r12
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    r13
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_8 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_7 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_6 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+136]
+  mov    [reg_p2+40], r10    // z5
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r12
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_10 
+  mul    r13
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_9 
+  mul    r14
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_8 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  
+  movq   rax, p751p1_7 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+144]
+  mov    [reg_p2+48], r8     // z6
+  adc    r9, 0
+  adc    r10, 0
+  
+  xor    r8, r8
+  movq   rax, p751p1_11 
+  mul    r13
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_10 
+  mul    r14
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_9 
+  mul    r15
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  
+  movq   rax, p751p1_8 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  adc    r8, 0
+  add    r9, [reg_p1+152]
+  mov    [reg_p2+56], r9     // z7
+  adc    r10, 0
+  adc    r8, 0
+  
+  xor    r9, r9
+  movq   rax, p751p1_11 
+  mul    r14
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_10 
+  mul    r15
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  
+  movq   rax, p751p1_9 
+  mul    rcx
+  add    r10, rax
+  adc    r8, rdx
+  adc    r9, 0
+  add    r10, [reg_p1+160]
+  mov    [reg_p2+64], r10    // z8
+  adc    r8, 0
+  adc    r9, 0
+  
+  xor    r10, r10
+  movq   rax, p751p1_11 
+  mul    r15
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+
+  movq   rax, p751p1_10 
+  mul    rcx
+  add    r8, rax
+  adc    r9, rdx
+  adc    r10, 0
+  add    r8, [reg_p1+168]    // z9
+  mov    [reg_p2+72], r8     // z9
+  adc    r9, 0
+  adc    r10, 0
+  
+  movq   rax, p751p1_11 
+  mul    rcx
+  add    r9, rax
+  adc    r10, rdx
+  add    r9, [reg_p1+176]    // z10
+  mov    [reg_p2+80], r9     // z10
+  adc    r10, 0  
+  add    r10, [reg_p1+184]   // z11
+  mov    [reg_p2+88], r10    // z11
+
+  pop    r15
+  pop    r14
+  pop    r13
+  pop    r12
+  ret
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/AMD64/fp_x64.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,865 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: modular arithmetic optimized for x64 platforms
+*
+*********************************************************************************************/
+
+#include "../SIDH_internal.h"
+
+
+// Global constants
+extern const uint64_t p751[NWORDS_FIELD];
+extern const uint64_t p751p1[NWORDS_FIELD]; 
+extern const uint64_t p751x2[NWORDS_FIELD]; 
+
+
+__inline void fpadd751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular addition, c = a+b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    
+#if (OS_TARGET == OS_WIN)
+    unsigned int i, carry = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], b[i], carry, c[i]); 
+    }
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(carry, c[i], ((digit_t*)p751x2)[i], carry, c[i]); 
+    }
+    mask = 0 - (digit_t)carry;
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, c[i], ((digit_t*)p751x2)[i] & mask, carry, c[i]); 
+    } 
+    
+#elif (OS_TARGET == OS_LINUX)                 
+    
+    fpadd751_asm(a, b, c);    
+
+#endif
+} 
+
+
+__inline void fpsub751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular subtraction, c = a-b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    
+#if (OS_TARGET == OS_WIN)
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], b[i], borrow, c[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, c[i], ((digit_t*)p751x2)[i] & mask, borrow, c[i]); 
+    }
+    
+#elif (OS_TARGET == OS_LINUX)                 
+    
+    fpsub751_asm(a, b, c);    
+
+#endif
+}
+
+
+__inline void fpneg751(digit_t* a)
+{ // Modular negation, a = -a mod p751.
+  // Input/output: a in [0, 2*p751-1] 
+    unsigned int i, borrow = 0;
+    
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, ((digit_t*)p751x2)[i], a[i], borrow, a[i]); 
+    }
+}
+
+
+void fpdiv2_751(digit_t* a, digit_t* c)
+{ // Modular division by two, c = a/2 mod p751.
+  // Input : a in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, carry = 0;
+    digit_t mask;
+        
+    mask = 0 - (digit_t)(a[0] & 1);    // If a is odd compute a+p521
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], ((digit_t*)p751)[i] & mask, carry, c[i]); 
+    }
+
+    mp_shiftr1(c, NWORDS_FIELD);
+}  
+
+
+void fpcorrection751(digit_t* a)
+{ // Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], ((digit_t*)p751)[i], borrow, a[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, a[i], ((digit_t*)p751)[i] & mask, borrow, a[i]); 
+    }
+}
+
+
+void mp_mul(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision multiply, c = a*b, where lng(a) = lng(b) = nwords.
+        
+    UNREFERENCED_PARAMETER(nwords);
+
+#if (OS_TARGET == OS_WIN)
+    digit_t t = 0;
+    uint128_t uv = {0};
+    unsigned int carry = 0;
+        
+    MULADD128(a[0], b[0], uv, carry, uv);
+    t += carry;
+    c[0] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[0], uv, carry, uv);
+    t += carry;
+    c[1] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[0], uv, carry, uv);
+    t += carry;
+    c[2] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[0], uv, carry, uv);
+    t += carry;
+    c[3] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[0], uv, carry, uv);
+    t += carry;
+    c[4] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[0], uv, carry, uv);
+    t += carry;
+    c[5] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[0], uv, carry, uv);
+    t += carry;
+    c[6] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[0], uv, carry, uv);
+    t += carry;
+    c[7] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[0], uv, carry, uv);
+    t += carry;
+    c[8] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[0], uv, carry, uv);
+    t += carry;
+    c[9] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[0], uv, carry, uv);
+    t += carry;
+    c[10] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[0], b[11], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[1], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[1], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[11], b[0], uv, carry, uv);
+    t += carry;
+    c[11] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;    
+    
+    MULADD128(a[1], b[11], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[11], b[1], uv, carry, uv);
+    t += carry;
+    c[12] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[2], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[2], b[11], uv, carry, uv);
+    t += carry;
+    c[13] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[3], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[3], b[11], uv, carry, uv);
+    t += carry;
+    c[14] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[4], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[4], b[11], uv, carry, uv);
+    t += carry;
+    c[15] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[5], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[5], b[11], uv, carry, uv);
+    t += carry;
+    c[16] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[6], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[6], b[11], uv, carry, uv);
+    t += carry;
+    c[17] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[7], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[7], b[11], uv, carry, uv);
+    t += carry;
+    c[18] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[8], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[8], b[11], uv, carry, uv);
+    t += carry;
+    c[19] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[9], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[9], b[11], uv, carry, uv);
+    t += carry;
+    c[20] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+    
+    MULADD128(a[11], b[10], uv, carry, uv);
+    t += carry;
+    MULADD128(a[10], b[11], uv, carry, uv);
+    t += carry;
+    c[21] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    
+    MULADD128(a[11], b[11], uv, carry, uv);
+    c[22] = uv[0];
+    c[23] = uv[1];
+
+#elif (OS_TARGET == OS_LINUX)
+    
+    mul751_asm(a, b, c);
+
+#endif
+}
+
+
+void rdc_mont(dfelm_t ma, felm_t mc)
+{ // Optimized Montgomery reduction using comba and exploiting the special form of the prime p751.
+  // mc = ma*mb*R^-1 mod p751, where ma,mb,mc in [0, 2*p751-1] and R = 2^768.
+  // ma and mb are assumed to be in Montgomery representation.
+        
+#if (OS_TARGET == OS_WIN)
+    unsigned int carry;
+    digit_t t = 0;
+    uint128_t uv = {0};
+    
+    mc[0] = ma[0];
+    mc[1] = ma[1];
+    mc[2] = ma[2];
+    mc[3] = ma[3];
+    mc[4] = ma[4];
+    MUL128(mc[0], ((digit_t*)p751p1)[5], uv);
+    ADDC(0, uv[0], ma[5], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    mc[5] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[6], uv, carry, uv);
+    MULADD128(mc[1], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[6], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[6] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[7], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[7] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[8], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[8] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[9], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[9] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[10], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[10] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[0], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[1], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[11], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[11] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[1], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[2], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[12], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[0] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[2], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[3], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[13], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[1] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[3], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[4], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[14], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[2] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[4], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[5], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[15], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[3] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[5], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[6], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[5], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[16], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[4] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[6], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[7], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[6], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[17], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[5] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[7], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[8], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[7], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[18], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[6] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[8], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[9], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[8], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[19], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[7] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[9], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[10], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[9], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[20], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[8] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[10], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    MULADD128(mc[11], ((digit_t*)p751p1)[10], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[21], carry, uv[0]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    t += carry; 
+    mc[9] = uv[0];
+    uv[0] = uv[1];
+    uv[1] = t;
+    t = 0;
+
+    MULADD128(mc[11], ((digit_t*)p751p1)[11], uv, carry, uv);
+    t += carry;
+    ADDC(0, uv[0], ma[22], carry, mc[10]); 
+    ADDC(carry, uv[1], 0, carry, uv[1]); 
+    ADDC(0, uv[1], ma[23], carry, mc[11]); 
+    
+#elif (OS_TARGET == OS_LINUX)                 
+    
+    rdc751_asm(ma, mc);    
+
+#endif
+}
\ No newline at end of file
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/ec_isogeny.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/ec_isogeny.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/ec_isogeny.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/ec_isogeny.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,586 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: elliptic curve and isogeny functions
+*
+*********************************************************************************************/ 
+
+#include "SIDH_internal.h"
+
+
+void j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv)
+{ // Computes the j-invariant of a Montgomery curve with projective constant.
+  // Input: A,C in GF(p^2).
+  // Output: j=256*(A^2-3*C^2)^3/(C^4*(A^2-4*C^2)), which is j-invariant of Montgomery curve B*y^2=x^3+(A/C)*x^2+x or (equivalently) j-invariant of B'*y^2=C*x^3+A*x^2+C*x.
+    f2elm_t t0, t1;
+    
+    fp2sqr751_mont(A, jinv);                           // jinv = A^2        
+    fp2sqr751_mont(C, t1);                             // t1 = C^2
+    fp2add751(t1, t1, t0);                             // t0 = t1+t1
+    fp2sub751(jinv, t0, t0);                           // t0 = jinv-t0
+    fp2sub751(t0, t1, t0);                             // t0 = t0-t1
+    fp2sub751(t0, t1, jinv);                           // jinv = t0-t1
+    fp2sqr751_mont(t1, t1);                            // t1 = t1^2
+    fp2mul751_mont(jinv, t1, jinv);                    // jinv = jinv*t1
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2sqr751_mont(t0, t1);                            // t1 = t0^2
+    fp2mul751_mont(t0, t1, t0);                        // t0 = t0*t1
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2add751(t0, t0, t0);                             // t0 = t0+t0
+    fp2inv751_mont(jinv);                              // jinv = 1/jinv 
+    fp2mul751_mont(jinv, t0, jinv);                    // jinv = t0*jinv
+}
+
+
+void xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24)
+{ // Simultaneous doubling and differential addition.
+  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.
+  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. 
+    f2elm_t t0, t1, t2;
+
+    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP
+    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP
+    fp2sqr751_mont(t0, P->X);                          // XP = (XP+ZP)^2
+    fp2sub751(Q->X, Q->Z, t2);                         // t2 = XQ-ZQ
+    fp2add751(Q->X, Q->Z, Q->X);                       // XQ = XQ+ZQ
+    fp2mul751_mont(t0, t2, t0);                        // t0 = (XP+ZP)*(XQ-ZQ)
+    fp2sqr751_mont(t1, P->Z);                          // ZP = (XP-ZP)^2
+    fp2mul751_mont(t1, Q->X, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)
+    fp2sub751(P->X, P->Z, t2);                         // t2 = (XP+ZP)^2-(XP-ZP)^2
+    fp2mul751_mont(P->X, P->Z, P->X);                  // XP = (XP+ZP)^2*(XP-ZP)^2
+    fp2mul751_mont(t2, A24, Q->X);                     // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]
+    fp2sub751(t0, t1, Q->Z);                           // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)
+    fp2add751(Q->X, P->Z, P->Z);                       // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2
+    fp2add751(t0, t1, Q->X);                           // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)
+    fp2mul751_mont(P->Z, t2, P->Z);                    // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]
+    fp2sqr751_mont(Q->Z, Q->Z);                        // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+    fp2sqr751_mont(Q->X, Q->X);                        // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2
+    fp2mul751_mont(Q->Z, xPQ, Q->Z);                   // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+}
+
+
+void xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24)
+{ // Doubling of a Montgomery point in projective coordinates (X:Z).
+  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.
+  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).
+    f2elm_t t0, t1;
+    
+    fp2sub751(P->X, P->Z, t0);                         // t0 = X1-Z1
+    fp2add751(P->X, P->Z, t1);                         // t1 = X1+Z1
+    fp2sqr751_mont(t0, t0);                            // t0 = (X1-Z1)^2 
+    fp2sqr751_mont(t1, t1);                            // t1 = (X1+Z1)^2 
+    fp2mul751_mont(C24, t0, Q->Z);                     // Z2 = C24*(X1-Z1)^2   
+    fp2mul751_mont(t1, Q->Z, Q->X);                    // X2 = C24*(X1-Z1)^2*(X1+Z1)^2
+    fp2sub751(t1, t0, t1);                             // t1 = (X1+Z1)^2-(X1-Z1)^2 
+    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*[(X1+Z1)^2-(X1-Z1)^2]
+    fp2add751(Q->Z, t0, Q->Z);                         // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2
+    fp2mul751_mont(Q->Z, t1, Q->Z);                    // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]
+}
+
+
+void xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e)
+{ // Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.
+  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.
+  // Output: projective Montgomery x-coordinates P <- (2^e)*P.
+    f2elm_t A24num, A24den;
+    int i;
+    
+    fp2add751(C, C, A24num);                           
+    fp2add751(A24num, A24num, A24den);                    
+    fp2add751(A24num, A, A24num); 
+    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);
+
+    for (i = 0; i < e; i++) {
+        xDBL(Q, Q, A24num, A24den);
+    }
+}
+
+
+void xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ)
+{ // Differential addition.
+  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, and affine difference xPQ=x(P-Q).
+  // Output: projective Montgomery point P <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. 
+    f2elm_t t0, t1;
+    
+    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP
+    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP
+    fp2sub751(Q->X, Q->Z, P->X);                       // XP = XQ-ZQ
+    fp2add751(Q->X, Q->Z, P->Z);                       // ZP = XQ+ZQ
+    fp2mul751_mont(t0, P->X, t0);                      // t0 = (XP+ZP)*(XQ-ZQ)                           
+    fp2mul751_mont(t1, P->Z, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)
+    fp2sub751(t0, t1, P->Z);                           // ZP = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)
+    fp2add751(t0, t1, P->X);                           // XP = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)
+    fp2sqr751_mont(P->Z, P->Z);                        // ZP = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+    fp2sqr751_mont(P->X, P->X);                        // XP = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2
+    fp2mul751_mont(P->Z, xPQ, P->Z);                   // ZP = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+}
+
+
+void xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q)
+{ // Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.
+  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.
+  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).
+    felm_t t0, t1;
+
+    // NOTE: this function is fixed for A24=1, C24=2
+    
+    fpsub751(P->X, P->Z, t0);                          // t0 = X1-Z1
+    fpadd751(P->X, P->Z, t1);                          // t1 = X1+Z1
+    fpsqr751_mont(t0, t0);                             // t0 = (X1-Z1)^2 
+    fpsqr751_mont(t1, t1);                             // t1 = (X1+Z1)^2   
+    fpadd751(t0, t0, Q->Z);                            // Z2 = C24*(X1-Z1)^2 
+    fpmul751_mont(t1, Q->Z, Q->X);                     // X2 = C24*(X1-Z1)^2*(X1+Z1)^2
+    fpsub751(t1, t0, t1);                              // t1 = (X1+Z1)^2-(X1-Z1)^2 
+    fpadd751(Q->Z, t1, Q->Z);                          // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2
+    fpmul751_mont(Q->Z, t1, Q->Z);                     // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]
+}
+
+
+void xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24)
+{ // Simultaneous doubling and differential addition over the base field.
+  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.
+  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. 
+    felm_t t0, t1, t2;
+
+    // NOTE: this function is fixed for C24=2
+
+    fpadd751(P->X, P->Z, t0);                          // t0 = XP+ZP
+    fpsub751(P->X, P->Z, t1);                          // t1 = XP-ZP
+    fpsqr751_mont(t0, P->X);                           // XP = (XP+ZP)^2
+    fpsub751(Q->X, Q->Z, t2);                          // t2 = XQ-ZQ
+    fpadd751(Q->X, Q->Z, Q->X);                        // XQ = XQ+ZQ
+    fpmul751_mont(t0, t2, t0);                         // t0 = (XP+ZP)*(XQ-ZQ)
+    fpsqr751_mont(t1, P->Z);                           // ZP = (XP-ZP)^2
+    fpmul751_mont(t1, Q->X, t1);                       // t1 = (XP-ZP)*(XQ+ZQ)
+    fpsub751(P->X, P->Z, t2);                          // t2 = (XP+ZP)^2-(XP-ZP)^2
+
+    if (A24[0] == 1) {
+        fpadd751(P->Z, P->Z, P->Z);                    // ZP = C24*(XP-ZP)^2
+        fpmul751_mont(P->X, P->Z, P->X);               // XP = C24*(XP+ZP)^2*(XP-ZP)^2
+        fpadd751(t2, P->Z, P->Z);                      // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2
+    } else {
+        fpmul751_mont(P->X, P->Z, P->X);               // XP = (XP+ZP)^2*(XP-ZP)^2
+        fpmul751_mont(A24, t2, Q->X);                  // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]
+        fpadd751(P->Z, Q->X, P->Z);                    // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2
+    }
+    
+    fpsub751(t0, t1, Q->Z);                            // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)
+    fpadd751(t0, t1, Q->X);                            // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)
+    fpmul751_mont(P->Z, t2, P->Z);                     // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]
+    fpsqr751_mont(Q->Z, Q->Z);                         // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+    fpsqr751_mont(Q->X, Q->X);                         // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2
+    fpmul751_mont(Q->Z, xPQ, Q->Z);                    // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2
+}
+
+
+void ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny)
+{ // The Montgomery ladder
+  // Inputs: the affine x-coordinate of a point P on E: B*y^2=x^3+A*x^2+x, 
+  //         scalar m
+  //         curve constant A24 = (A+2)/4
+  //         order_bits = subgroup order bitlength
+  //         order_fullbits = smallest multiple of 32 larger than the order bitlength
+  // Output: Q = m*(x:1)
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int bit = 0, owords = NBITS_TO_NWORDS(order_fullbits);
+    digit_t mask;
+    int i;
+
+    // Initializing with the points (1:0) and (x:1)
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)P->X);
+    fpzero751(P->Z);
+    fpcopy751(x, Q->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)Q->Z);
+
+    for (i = order_fullbits-order_bits; i > 0; i--) {
+        mp_shiftl1(m, owords);
+    }
+    
+    for (i = order_bits; i > 0; i--) {
+        bit = (unsigned int)(m[owords-1] >> (RADIX-1));
+        mp_shiftl1(m, owords);
+        mask = 0-(digit_t)bit;
+
+        swap_points_basefield(P, Q, mask);
+        xDBLADD_basefield(P, Q, x, A24);           // If bit=0 then P <- 2*P and Q <- P+Q, 
+        swap_points_basefield(P, Q, mask);         // else if bit=1 then Q <- 2*Q and P <- P+Q
+    }
+}
+
+
+CRYPTO_STATUS BigMont_ladder(unsigned char* x, digit_t* m, unsigned char* xout, PCurveIsogenyStruct CurveIsogeny)
+{ // BigMont's scalar multiplication using the Montgomery ladder
+  // Inputs: x, the affine x-coordinate of a point P on BigMont: y^2=x^3+A*x^2+x, 
+  //         scalar m.
+  // Output: xout, the affine x-coordinate of m*(x:1)
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    point_basefield_proj_t P1, P2;
+    digit_t scalar[BIGMONT_NWORDS_ORDER];
+    felm_t X, A24 = {0};
+
+    A24[0] = (digit_t)CurveIsogeny->BigMont_A24; 
+    to_mont(A24, A24);                               // Conversion to Montgomery representation
+    to_mont((digit_t*)x, X);
+    
+    copy_words(m, scalar, BIGMONT_NWORDS_ORDER);
+    ladder(X, scalar, P1, P2, A24, BIGMONT_NBITS_ORDER, BIGMONT_MAXBITS_ORDER, CurveIsogeny);
+
+    fpinv751_mont(P1->Z);
+    fpmul751_mont(P1->X, P1->Z, (digit_t*)xout);
+    from_mont((digit_t*)xout, (digit_t*)xout);       // Conversion to standard representation
+
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny)
+{ // Computes key generation entirely in the base field by exploiting a 1-dimensional Montgomery ladder in the trace zero subgroup and 
+  // recovering the y-coordinate for the addition. All operations in the base field GF(p).
+  // Input:  The scalar m, point P = (x,y) on E in the base field subgroup and Q = (x1,y1*i) on E in the trace-zero subgroup. 
+  //         x,y,x1,y1 are all in the base field.          
+  // Output: R = (RX0+RX1*i)/RZ0 (the x-coordinate of P+[m]Q).
+    unsigned int nbits;
+    point_basefield_t Q;
+    point_basefield_proj_t S, T;
+    digit_t *X0 = (digit_t*)S->X, *Z0 = (digit_t*)S->Z, *X1 = (digit_t*)T->X, *Z1 = (digit_t*)T->Z;
+    digit_t *x  = (digit_t*)P->x, *y  = (digit_t*)P->y, *x1 = (digit_t*)Q->x, *y1 = (digit_t*)Q->y;
+    digit_t scalar[NWORDS_ORDER];
+    felm_t t0, t1, t2, A24 = {0};
+    digit_t *RX0 = (digit_t*)R->X[0], *RX1 = (digit_t*)R->X[1], *RZ0 = (digit_t*)R->Z[0], *RZ1 = (digit_t*)R->Z[1];
+
+    fpcopy751(P->x, Q->x);                         // Q = (-XP,YP)
+    fpcopy751(P->y, Q->y);
+    fpneg751(Q->x);
+
+    if (AliceOrBob == ALICE) {
+        nbits = CurveIsogeny->oAbits;
+    } else if (AliceOrBob == BOB) {
+        nbits = CurveIsogeny->oBbits;
+    } else {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+        
+    // Setting curve constant to one (in standard representation), used in xDBLADD_basefield() in the ladder computation
+    A24[0] = 1;
+    copy_words(m, scalar, NWORDS_ORDER);
+    ladder(Q->x, scalar, S, T, A24, nbits, CurveIsogeny->owordbits, CurveIsogeny);
+    
+    //RX0 := (2*y*y1*Z0^2*Z1 + Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2)*(2*y*y1*Z0^2*Z1 - Z1*(X0*x1+Z0)*(X0+x1*Z0) + X1*(X0-x1*Z0)^2) - 4*y1^2*Z0*Z1^2*(X0+x*Z0)*(X0-x*Z0)^2;
+    //RX1 := 4*y*y1*Z0^2*Z1*(Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2);
+    //RZ0 := 4*y1^2*Z0^2*Z1^2*(X0-x*Z0)^2;
+
+    fpmul751_mont(x1, Z0, RX1);
+    fpmul751_mont(X0, x1, RX0);
+    fpsub751(X0, RX1, t0);
+    fpadd751(X0, RX1, RX1);
+    fpsqr751_mont(t0, t0);
+    fpadd751(RX0, Z0, RX0);
+    fpmul751_mont(t0, X1, t0);
+    fpmul751_mont(RX0, RX1, RX0);
+    fpmul751_mont(y1, Z1, t2);
+    fpmul751_mont(y, Z0, t1);
+    fpadd751(t2, t2, t2);
+    fpmul751_mont(t2, Z0, RX1);
+    fpmul751_mont(RX0, Z1, RX0);
+    fpsub751(RX0, t0, RX0);
+    fpmul751_mont(t1, RX1, t1);
+    fpsqr751_mont(RX1, t0);
+    fpmul751_mont(t2, RX1, t2);
+    fpmul751_mont(t1, RX0, RX1);
+    fpadd751(t1, RX0, RZ0);
+    fpadd751(RX1, RX1, RX1);
+    fpsub751(t1, RX0, t1);
+    fpmul751_mont(x, Z0, RX0);
+    fpmul751_mont(t1, RZ0, t1);
+    fpsub751(X0, RX0, RZ0);
+    fpadd751(X0, RX0, RX0);
+    fpsqr751_mont(RZ0, RZ0);
+    fpmul751_mont(t2, RX0, t2);
+    fpmul751_mont(t2, RZ0, t2);
+    fpmul751_mont(RZ0, t0, RZ0);
+    fpsub751(t1, t2, RX0);
+    fpzero751(RZ1);
+
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)
+{ // Computes P+[m]Q via x-only arithmetic. Algorithm by De Feo, Jao and Plut.
+  // Input:  three affine points xP,xQ,xPQ and Montgomery constant A.
+  // Output: projective Montgomery x-coordinates of x(P+[m]Q)=WX/WZ
+    point_proj_t U = {0}, V = {0};
+    f2elm_t A24, A24num, constant1 = {0}, constant2;
+    felm_t temp_scalar;
+    unsigned int bit = 0, nbits, fullbits = CurveIsogeny->owordbits;
+    digit_t mask;
+    int i;
+
+    if (AliceOrBob == ALICE) {
+        nbits = CurveIsogeny->oAbits;
+    } else if (AliceOrBob == BOB) {
+        nbits = CurveIsogeny->oBbits;
+    } else {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+   
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, constant1[0]);
+    fp2add751(constant1, constant1, constant1);                  // constant = 2
+    fp2add751(A, constant1, A24num);
+    fp2div2_751(A24num, A24);  
+    fp2div2_751(A24, A24);
+    
+    // Initializing with the points (1:0), (xQ:1) and (xP:1)
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)U->X);
+    fp2copy751(xQ, V->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)V->Z);
+    fp2copy751(xP, W->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)W->Z);
+    fpzero751(W->Z[1]);
+    fpcopy751(m, temp_scalar);
+    
+    for (i = fullbits-nbits; i > 0; i--) {
+        mp_shiftl1(temp_scalar, NWORDS_ORDER);
+    }
+    
+    for (i = nbits; i > 0; i--) {
+        bit = (unsigned int)(temp_scalar[NWORDS_ORDER-1] >> (RADIX-1));
+        mp_shiftl1(temp_scalar, NWORDS_ORDER);
+        mask = 0 - (digit_t)bit;
+
+        swap_points(W, U, mask);
+        swap_points(U, V, mask);
+        select_f2elm(xP, xQ, constant1, mask);
+        select_f2elm(xQ, xPQ, constant2, mask);
+        xADD(W, U, constant1);                     // If bit=0 then W <- W+U, U <- 2*U and V <- U+V, 
+        xDBLADD(U, V, constant2, A24);             // else if bit=1 then U <- U+V, V <- 2*V and W <- V+W
+        swap_points(U, V, mask);
+        swap_points(W, U, mask);
+    }
+
+    return CRYPTO_SUCCESS;
+}
+
+
+void get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff)
+{ // Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.
+  // Input:  projective point of order four P = (X4:Z4).
+  // Output: the 4-isogenous Montgomery curve with projective coefficient A/C and the 5 coefficients 
+  //         that are used to evaluate the isogeny at a point in eval_4_isog().
+    
+    fp2add751(P->X, P->Z, coeff[0]);                   // coeff[0] = X4+Z4
+    fp2sqr751_mont(P->X, coeff[3]);                    // coeff[3] = X4^2
+    fp2sqr751_mont(P->Z, coeff[4]);                    // coeff[4] = Z4^2
+    fp2sqr751_mont(coeff[0], coeff[0]);                // coeff[0] = (X4+Z4)^2
+    fp2add751(coeff[3], coeff[4], coeff[1]);           // coeff[1] = X4^2+Z4^2
+    fp2sub751(coeff[3], coeff[4], coeff[2]);           // coeff[2] = X4^2-Z4^2
+    fp2sqr751_mont(coeff[3], coeff[3]);                // coeff[3] = X4^4
+    fp2sqr751_mont(coeff[4], coeff[4]);                // coeff[4] = Z4^4
+    fp2add751(coeff[3], coeff[3], A);                  // A = 2*X4^4
+    fp2sub751(coeff[0], coeff[1], coeff[0]);           // coeff[0] = 2*X4*Z4 = (X4+Z4)^2 - (X4^2+Z4^2)
+    fp2sub751(A, coeff[4], A);                         // A = 2*X4^4-Z4^4
+    fp2copy751(coeff[4], C);                           // C = Z4^4
+    fp2add751(A, A, A);                                // A = 2(2*X4^4-Z4^4)
+}
+
+
+void eval_4_isog(point_proj_t P, f2elm_t* coeff)
+{ // Evaluates the isogeny at the point (X:Z) in the domain of the isogeny, given a 4-isogeny phi defined 
+  // by the 5 coefficients in coeff (computed in the function four_isogeny_from_projective_kernel()).
+  // Inputs: the coefficients defining the isogeny, and the projective point P = (X:Z).
+  // Output: the projective point P = phi(P) = (X:Z) in the codomain. 
+    f2elm_t t0, t1;
+
+    fp2mul751_mont(P->X, coeff[0], P->X);              // X = coeff[0]*X
+    fp2mul751_mont(P->Z, coeff[1], t0);                // t0 = coeff[1]*Z
+    fp2sub751(P->X, t0, P->X);                         // X = X-t0
+    fp2mul751_mont(P->Z, coeff[2], P->Z);              // Z = coeff[2]*Z
+    fp2sub751(P->X, P->Z, t0);                         // t0 = X-Z
+    fp2mul751_mont(P->Z, P->X, P->Z);                  // Z = X*Z
+    fp2sqr751_mont(t0, t0);                            // t0 = t0^2
+    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z
+    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z
+    fp2add751(P->Z, t0, P->X);                         // X = t0+Z
+    fp2mul751_mont(P->Z, t0, P->Z);                    // Z = t0*Z
+    fp2mul751_mont(P->Z, coeff[4], P->Z);              // Z = coeff[4]*Z
+    fp2mul751_mont(t0, coeff[4], t0);                  // t0 = t0*coeff[4]
+    fp2mul751_mont(P->X, coeff[3], t1);                // t1 = X*coeff[3]
+    fp2sub751(t0, t1, t0);                             // t0 = t0-t1
+    fp2mul751_mont(P->X, t0, P->X);                    // X = X*t0
+}
+
+
+void first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny)
+{ // Computes first 4-isogeny computed by Alice.
+  // Inputs: projective point P = (X4:Z4) and curve constant A.
+  // Output: the projective point P = (X4:Z4) in the codomain and isogenous curve constant Aout/Cout.  
+    f2elm_t t0 = {0}, t1, t2;
+    
+    fpcopy751(CurveIsogeny->Montgomery_one, t0[0]); 
+    fpadd751(t0[0], t0[0], t0[0]);                     // t0 = 2 (in Montgomery domain)
+    fp2sub751(A, t0, Cout);                            // Cout = A-2
+    fpadd751(t0[0], t0[0], t1[0]);                     
+    fpadd751(t0[0], t1[0], t0[0]);                     // t0 = 6 (in Montgomery domain)
+    fp2add751(P->X, P->Z, t1);                         // t1 = X+Z
+    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z
+    fp2sqr751_mont(t1, t1);                            // t1 = (X+Z)^2
+    fp2add751(A, t0, Aout);                            // A = A+6
+    fp2mul751_mont(P->X, P->Z, P->Z);                  // Z = X*Z
+    fp2neg751(P->Z);                                   // Z = -X*Z
+    fp2sqr751_mont(t2, t2);                            // t2 = (X-Z)^2
+    fp2mul751_mont(P->Z, Cout, P->Z);                  // Z = -C*X*Z
+    fp2add751(Aout, Aout, Aout);                       // Aout = 2*A+12
+    fp2sub751(t1, P->Z, P->X);                         // X = (X+Z)^2+C*X*Z
+    fp2mul751_mont(P->Z, t2, P->Z);                    // Z = -C*X*Z*(X-Z)^2
+    fp2mul751_mont(P->X, t1, P->X);                    // X = (X+Z)^2*[(X+Z)^2+C*X*Z]
+}
+
+
+void xTPL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24)
+{ // Tripling of a Montgomery point in projective coordinates (X:Z).
+  // Input: projective Montgomery x-coordinates P = (X:Z), where x=X/Z and Montgomery curve constant A/C.
+  // Output: projective Montgomery x-coordinates Q = 3*P = (X3:Z3).
+    f2elm_t t0, t1, t2, t3, t4, t5;
+
+    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z           
+    fp2add751(P->X, P->Z, t3);                         // t3 = X+Z 
+    fp2sqr751_mont(t2, t0);                            // t0 = t2^2 
+    fp2sqr751_mont(t3, t1);                            // t1 = t3^2 
+    fp2mul751_mont(t0, C24, t4);                       // t4 = C24*t0 
+    fp2mul751_mont(t1, t4, t5);                        // t5 = t4*t1
+    fp2sub751(t1, t0, t1);                             // t1 = t1-t0 
+    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*t1
+    fp2add751(t4, t0, t4);                             // t4 = t4+t0
+    fp2mul751_mont(t1, t4, t4);                        // t4 = t4*t1
+    fp2add751(t5, t4, t0);                             // t0 = t5+t4
+    fp2sub751(t5, t4, t1);                             // t1 = t5-t4
+    fp2mul751_mont(t0, t2, t0);                        // t0 = t2*t0
+    fp2mul751_mont(t1, t3, t1);                        // t1 = t3*t1
+    fp2sub751(t0, t1, t4);                             // t4 = t0-t1
+    fp2add751(t0, t1, t5);                             // t5 = t0+t1
+    fp2sqr751_mont(t4, t4);                            // t4 = t4^2
+    fp2sqr751_mont(t5, t5);                            // t5 = t5^2
+    fp2mul751_mont(P->X, t4, t4);                      // t4 = X*t4
+    fp2mul751_mont(P->Z, t5, Q->X);                    // X3 = Z*t5
+    fp2copy751(t4, Q->Z);                              // Z3 = t4
+}
+
+
+void xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e)
+{ // Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.
+  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.
+  // Output: projective Montgomery x-coordinates P <- (3^e)*P.
+    f2elm_t A24, C24;
+    int i;
+    
+    fp2add751(C, C, A24);                           
+    fp2add751(A24, A24, C24);                    
+    fp2add751(A24, A, A24);       
+    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);
+
+    for (i = 0; i < e; i++) {
+        xTPL(Q, Q, A24, C24);
+    }
+}
+
+
+void get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C)
+{ // Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.
+  // Input:  projective point of order three P = (X3:Z3).
+  // Output: the 3-isogenous Montgomery curve with projective coefficient A/C. 
+    f2elm_t t0, t1;
+
+    fp2sqr751_mont(P->X, t0);                          // t0 = X^2
+    fp2add751(t0, t0, t1);                             // t1 = 2*t0
+    fp2add751(t0, t1, t0);                             // t0 = t0+t1
+    fp2sqr751_mont(P->Z, t1);                          // t1 = Z^2
+    fp2sqr751_mont(t1, A);                             // A = t1^2
+    fp2add751(t1, t1, t1);                             // t1 = 2*t1
+    fp2add751(t1, t1, C);                              // C = 2*t1
+    fp2sub751(t0, t1, t1);                             // t1 = t0-t1
+    fp2mul751_mont(t0, t1, t1);                        // t1 = t0*t1
+    fp2sub751(A, t1, A);                               // A = A-t1 
+    fp2sub751(A, t1, A);                               // A = A-t1 
+    fp2sub751(A, t1, A);                               // A = A-t1     
+    fp2mul751_mont(P->X, P->Z, t1);                    // t1 = X*Z    // ms trade-off possible (1 mul for 1sqr + 1add + 2sub)
+    fp2mul751_mont(C, t1, C);                          // C = C*t1
+}
+
+
+void eval_3_isog(point_proj_t P, point_proj_t Q)
+{ // Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).
+  // Inputs: projective points P = (X3:Z3) and Q = (X:Z).
+  // Output: the projective point R = phi(Q) = (XX:ZZ). 
+    f2elm_t t0, t1, t2;
+
+    fp2mul751_mont(P->X, Q->X, t0);                  // t0 = X3*X
+    fp2mul751_mont(P->Z, Q->X, t1);                  // t1 = Z3*X
+    fp2mul751_mont(P->Z, Q->Z, t2);                  // t2 = Z3*Z
+    fp2sub751(t0, t2, t0);                           // t0 = X3*X-Z3*Z          
+    fp2mul751_mont(P->X, Q->Z, t2);                  // t2 = X3*Z
+    fp2sub751(t1, t2, t1);                           // t1 = Z3*X-X3*Z
+    fp2sqr751_mont(t0, t0);                          // t0 = (X3*X-Z3*Z)^2
+    fp2sqr751_mont(t1, t1);                          // t1 = (Z3*X-X3*Z)^2
+    fp2mul751_mont(Q->X, t0, Q->X);                  // X = X*(X3*X-Z3*Z)^2        
+    fp2mul751_mont(Q->Z, t1, Q->Z);                  // Z = Z*(Z3*X-X3*Z)^2
+}
+
+
+void inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3)
+{ // 3-way simultaneous inversion
+  // Input:  z1,z2,z3
+  // Output: 1/z1,1/z2,1/z3 (override inputs).
+    f2elm_t t0, t1, t2, t3;
+
+    fp2mul751_mont(z1, z2, t0);                      // t0 = z1*z2
+    fp2mul751_mont(z3, t0, t1);                      // t1 = z1*z2*z3
+    fp2inv751_mont(t1);                              // t1 = 1/(z1*z2*z3)
+    fp2mul751_mont(z3, t1, t2);                      // t2 = 1/(z1*z2) 
+    fp2mul751_mont(t2, z2, t3);                      // t3 = 1/z1
+    fp2mul751_mont(t2, z1, z2);                      // z2 = 1/z2
+    fp2mul751_mont(t0, t1, z3);                      // z3 = 1/z3
+    fp2copy751(t3, z1);                              // z1 = 1/z1
+}
+
+
+void distort_and_diff(felm_t xP, point_proj_t D, PCurveIsogenyStruct CurveIsogeny)
+{ // Computing the point (x(Q-P),z(Q-P))
+  // Input:  coordinate xP of point P=(xP,yP)
+  // Output: the point D = (x(Q-P),z(Q-P)), where Q=tau(P).
+    felm_t one;
+
+    fpcopy751(CurveIsogeny->Montgomery_one, one);
+    fpsqr751_mont(xP, D->X[0]);	                     // XD = xP^2
+    fpadd751(D->X[0], one, D->X[0]);                 // XD = XD+1
+    fpcopy751(D->X[0], D->X[1]);                     // XD = XD*i
+    fpzero751(D->X[0]);          
+    fpadd751(xP, xP, D->Z[0]);                       // ZD = xP+xP
+}
+
+
+void get_A(f2elm_t xP, f2elm_t xQ, f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)
+{ // Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.
+  // Input:  the x-coordinates xP, xQ, and xR of the points P, Q and R.
+  // Output: the coefficient A corresponding to the curve E_A: y^2=x^3+A*x^2+x.
+    f2elm_t t0, t1, one = {0};
+    
+    fpcopy751(CurveIsogeny->Montgomery_one, one[0]);
+    fp2add751(xP, xQ, t1);                           // t1 = xP+xQ
+    fp2mul751_mont(xP, xQ, t0);                      // t0 = xP*xQ
+    fp2mul751_mont(xR, t1, A);                       // A = xR*t1
+    fp2add751(t0, A, A);                             // A = A+t0
+    fp2mul751_mont(t0, xR, t0);                      // t0 = t0*xR
+    fp2sub751(A, one, A);                            // A = A-1
+    fp2add751(t0, t0, t0);                           // t0 = t0+t0
+    fp2add751(t1, xR, t1);                           // t1 = t1+xR
+    fp2add751(t0, t0, t0);                           // t0 = t0+t0
+    fp2sqr751_mont(A, A);                            // A = A^2
+    fp2inv751_mont(t0);                              // t0 = 1/t0
+    fp2mul751_mont(A, t0, A);                        // A = A*t0
+    fp2sub751(A, t1, A);                             // Afinal = A-t1
+}
\ No newline at end of file
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/fpx.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/fpx.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/fpx.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/fpx.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,485 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: core functions over GF(p751^2) and field operations over the prime p751
+*
+*********************************************************************************************/ 
+
+#include "SIDH_internal.h"
+    
+
+// Global constants          
+const uint64_t p751[NWORDS_FIELD]          = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xEEAFFFFFFFFFFFFF,
+                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };
+const uint64_t p751p1[NWORDS_FIELD]        = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xEEB0000000000000,
+                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };
+const uint64_t p751x2[NWORDS_FIELD]        = { 0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xDD5FFFFFFFFFFFFF, 
+                                               0xC7D92D0A93F0F151, 0xB52B363427EF98ED, 0x109D30CFADD7D0ED, 0x0AC56A08B964AE90, 0x1C25213F2F75B8CD, 0x0000DFCBAA83EE38 };
+const uint64_t Montgomery_R2[NWORDS_FIELD] = { 0x233046449DAD4058, 0xDB010161A696452A, 0x5E36941472E3FD8E, 0xF40BFE2082A2E706, 0x4932CCA8904F8751 ,0x1F735F1F1EE7FC81, 
+                                               0xA24F4D80C1048E18, 0xB56C383CCDB607C5, 0x441DD47B735F9C90, 0x5673ED2C6A6AC82A, 0x06C905261132294B, 0x000041AD830F1F35 }; 
+
+
+/*******************************************************/
+/************* Field arithmetic functions **************/
+
+__inline void fpcopy751(felm_t a, felm_t c)
+{ // Copy of a field element, c = a
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++)
+        c[i] = a[i];
+}
+
+
+__inline void fpzero751(felm_t a)
+{ // Zeroing a field element, a = 0
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++)
+        a[i] = 0;
+}
+
+
+void to_mont(felm_t a, felm_t mc)
+{ // Conversion to Montgomery representation
+  // mc = a*R^2*R^-1 mod p751 = a*R mod p751, where a in [0, p751-1]
+  // The Montgomery constant R^2 mod p751 is the global value "Montgomery_R2". 
+
+    fpmul751_mont(a, (digit_t*)&Montgomery_R2, mc);
+}
+
+
+void from_mont(felm_t ma, felm_t c)
+{ // Conversion from Montgomery representation to standard representation
+  // c = ma*R^-1 mod p751 = a mod p751, where ma in [0, p751-1].
+    digit_t one[NWORDS_FIELD] = {0};
+    
+    one[0] = 1;
+    fpmul751_mont(ma, one, c);
+    fpcorrection751(c);
+}
+
+
+static __inline unsigned int is_felm_zero(felm_t x)
+{ // Is x = 0? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+  // NOTE: this function does not run in constant-time so it can only be used in functions
+  //       incorporating countermeasures such as projective randomization.
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        if (x[i] != 0) return false;
+    }
+    return true;
+}
+
+
+static __inline unsigned int is_felm_even(felm_t x)
+{ // Is x even? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+    return (unsigned int)((x[0] & 1) ^ 1);
+}
+
+
+static __inline unsigned int is_felm_lt(felm_t x, felm_t y)
+{ // Is x < y? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+  // NOTE: this function does not run in constant-time so it can only be used in functions
+  //       incorporating countermeasures such as projective randomization.
+    int i;
+
+    for (i = NWORDS_FIELD-1; i >= 0; i--) {
+        if (x[i] < y[i]) { 
+            return true;
+        } else if (x[i] > y[i]) {
+            return false;
+        }
+    }
+    return false;
+}
+
+
+void copy_words(digit_t* a, digit_t* c, unsigned int nwords)
+{ // Copy wordsize digits, c = a, where lng(a) = nwords
+    unsigned int i;
+        
+    for (i = 0; i < nwords; i++) {                      
+        c[i] = a[i];
+    }
+}
+
+
+__inline unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit 
+    unsigned int i, borrow = 0;
+
+    for (i = 0; i < nwords; i++) {
+        SUBC(borrow, a[i], b[i], borrow, c[i]);
+    }
+
+    return borrow;
+}
+
+
+__inline unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit 
+    unsigned int i, carry = 0;
+        
+    for (i = 0; i < nwords; i++) {                      
+        ADDC(carry, a[i], b[i], carry, c[i]);
+    }
+
+    return carry;
+}
+
+
+void mp_shiftr1(digit_t* x, unsigned int nwords)
+{ // Multiprecision right shift by one
+    unsigned int i;
+
+    for (i = 0; i < nwords-1; i++) {
+        SHIFTR(x[i+1], x[i], 1, x[i], RADIX);
+    }
+    x[nwords-1] >>= 1;
+}
+
+
+void mp_shiftl1(digit_t* x, unsigned int nwords)
+{ // Multiprecision left right shift by one
+    int i;
+
+    for (i = nwords-1; i > 0; i--) {
+        SHIFTL(x[i], x[i-1], 1, x[i], RADIX);
+    }
+    x[0] <<= 1;
+}
+
+
+void fpmul751_mont(felm_t ma, felm_t mb, felm_t mc)
+{ // 751-bit Comba multi-precision multiplication, c = a*b mod p751
+    dfelm_t temp = {0};
+
+    mp_mul(ma, mb, temp, NWORDS_FIELD);
+    rdc_mont(temp, mc);
+}
+
+
+void fpsqr751_mont(felm_t ma, felm_t mc)
+{ // 751-bit Comba multi-precision squaring, c = a^2 mod p751
+    dfelm_t temp = {0};
+
+    mp_mul(ma, ma, temp, NWORDS_FIELD);
+    rdc_mont(temp, mc);
+}
+
+
+void fpinv751_mont(felm_t a)
+{ // Field inversion using Montgomery arithmetic, a = a^-1*R mod p751
+    felm_t t[27], tt;
+    unsigned int i, j;
+    
+    // Precomputed table
+    fpsqr751_mont(a, tt);
+    fpmul751_mont(a, tt, t[0]);
+    fpmul751_mont(t[0], tt, t[1]);
+    fpmul751_mont(t[1], tt, t[2]);
+    fpmul751_mont(t[2], tt, t[3]); 
+    fpmul751_mont(t[3], tt, t[3]);
+    for (i = 3; i <= 8; i++) fpmul751_mont(t[i], tt, t[i+1]);
+    fpmul751_mont(t[9], tt, t[9]);
+    for (i = 9; i <= 20; i++) fpmul751_mont(t[i], tt, t[i+1]);
+    fpmul751_mont(t[21], tt, t[21]); 
+    for (i = 21; i <= 24; i++) fpmul751_mont(t[i], tt, t[i+1]); 
+    fpmul751_mont(t[25], tt, t[25]);
+    fpmul751_mont(t[25], tt, t[26]);
+
+    fpcopy751(a, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[20], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[24], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[11], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[8], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[23], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 9; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[15], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[13], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[26], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[20], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[11], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[10], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[14], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[4], tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[18], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[1], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[6], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[24], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[9], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[18], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[17], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(a, tt, tt);
+    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[16], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[7], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[0], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[12], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[19], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[25], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[10], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[18], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[4], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[14], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[13], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[5], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[23], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[21], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[2], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[23], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[12], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[9], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[3], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[13], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[17], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[26], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[5], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[8], tt, tt);
+    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[11], tt, tt);
+    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    fpmul751_mont(t[22], tt, tt);
+    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);
+    for (j = 0; j < 61; j++) {
+        fpmul751_mont(t[26], tt, tt);
+        for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);
+    }
+    fpmul751_mont(t[25], tt, a);  
+}
+
+
+/***********************************************/
+/************* GF(p^2) FUNCTIONS ***************/
+
+void fp2copy751(f2elm_t a, f2elm_t c)
+{ // Copy of a GF(p751^2) element, c = a
+    fpcopy751(a[0], c[0]);
+    fpcopy751(a[1], c[1]);
+}
+
+
+void fp2zero751(f2elm_t a)
+{ // Zeroing a GF(p751^2) element, a = 0
+    fpzero751(a[0]);
+    fpzero751(a[1]);
+}
+
+
+void fp2neg751(f2elm_t a)
+{ // GF(p751^2) negation, a = -a in GF(p751^2)
+    fpneg751(a[0]);
+    fpneg751(a[1]);
+}
+
+
+__inline void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c)           
+{ // GF(p751^2) addition, c = a+b in GF(p751^2)
+    fpadd751(a[0], b[0], c[0]);
+    fpadd751(a[1], b[1], c[1]);
+}
+
+
+__inline void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c)          
+{ // GF(p751^2) subtraction, c = a-b in GF(p751^2) 
+    fpsub751(a[0], b[0], c[0]);
+    fpsub751(a[1], b[1], c[1]);
+}
+
+
+void fp2div2_751(f2elm_t a, f2elm_t c)          
+{ // GF(p751^2) division by two, c = a/2  in GF(p751^2) 
+    fpdiv2_751(a[0], c[0]);
+    fpdiv2_751(a[1], c[1]);
+}
+
+
+void fp2correction751(f2elm_t a)
+{ // Modular correction, a = a in GF(p751^2)
+    fpcorrection751(a[0]);
+    fpcorrection751(a[1]);
+}
+
+
+void fp2sqr751_mont(f2elm_t a, f2elm_t c)
+{ // GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)
+    felm_t t1, t2, t3;
+    
+    mp_add(a[0], a[1], t1, NWORDS_FIELD);    // t1 = a0+a1 
+    fpsub751(a[0], a[1], t2);                // t2 = a0-a1
+    mp_add(a[0], a[0], t3, NWORDS_FIELD);    // t3 = 2a0
+    fpmul751_mont(t1, t2, c[0]);             // c0 = (a0+a1)(a0-a1)
+    fpmul751_mont(t3, a[1], c[1]);           // c1 = 2a0*a1
+}
+
+
+void fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c)
+{ // GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)
+    felm_t t1, t2;
+    dfelm_t tt1, tt2, tt3; 
+    digit_t mask;
+    unsigned int i, borrow;
+    
+    mp_mul(a[0], b[0], tt1, NWORDS_FIELD);           // tt1 = a0*b0
+    mp_mul(a[1], b[1], tt2, NWORDS_FIELD);           // tt2 = a1*b1
+    mp_add(a[0], a[1], t1, NWORDS_FIELD);            // t1 = a0+a1
+    mp_add(b[0], b[1], t2, NWORDS_FIELD);            // t2 = b0+b1
+    borrow = mp_sub(tt1, tt2, tt3, 2*NWORDS_FIELD);  // tt3 = a0*b0 - a1*b1
+    mask = 0 - (digit_t)borrow;                      // if tt3 < 0 then mask = 0xFF..F, else if tt3 >= 0 then mask = 0x00..0
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, tt3[NWORDS_FIELD+i],  ((digit_t*)p751)[i]  & mask, borrow, tt3[NWORDS_FIELD+i]);
+    }
+    rdc_mont(tt3, c[0]);                             // c[0] = a0*b0 - a1*b1
+    mp_add(tt1, tt2, tt1, 2*NWORDS_FIELD);           // tt1 = a0*b0 + a1*b1
+    mp_mul(t1, t2, tt2, NWORDS_FIELD);               // tt2 = (a0+a1)*(b0+b1)
+    mp_sub(tt2, tt1, tt2, 2*NWORDS_FIELD);           // tt2 = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 
+    rdc_mont(tt2, c[1]);                             // c[1] = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 
+}
+
+
+void to_fp2mont(f2elm_t a, f2elm_t mc)
+{ // Conversion of a GF(p751^2) element to Montgomery representation
+  // mc_i = a_i*R^2*R^-1 = a_i*R in GF(p751^2). 
+
+    to_mont(a[0], mc[0]);
+    to_mont(a[1], mc[1]);
+}
+
+
+void from_fp2mont(f2elm_t ma, f2elm_t c)
+{ // Conversion of a GF(p751^2) element from Montgomery representation to standard representation
+  // c_i = ma_i*R^-1 = a_i in GF(p751^2).
+
+    from_mont(ma[0], c[0]);
+    from_mont(ma[1], c[1]);
+}
+
+
+void fp2inv751_mont(f2elm_t a)
+{// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)
+    f2elm_t t1;
+
+    fpsqr751_mont(a[0], t1[0]);             // t10 = a0^2
+    fpsqr751_mont(a[1], t1[1]);             // t11 = a1^2
+    fpadd751(t1[0], t1[1], t1[0]);          // t10 = a0^2+a1^2
+    fpinv751_mont(t1[0]);                   // t10 = (a0^2+a1^2)^-1
+    fpneg751(a[1]);                         // a = a0-i*a1
+    fpmul751_mont(a[0], t1[0], a[0]);
+    fpmul751_mont(a[1], t1[0], a[1]);       // a = (a0-i*a1)*(a0^2+a1^2)^-1
+}
+
+
+void swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option)
+{ // Swap points over the base field 
+  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P
+    digit_t temp;
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        temp = option & (P->X[i] ^ Q->X[i]);
+        P->X[i] = temp ^ P->X[i]; 
+        Q->X[i] = temp ^ Q->X[i]; 
+        temp = option & (P->Z[i] ^ Q->Z[i]);
+        P->Z[i] = temp ^ P->Z[i]; 
+        Q->Z[i] = temp ^ Q->Z[i]; 
+    }
+}
+
+
+void swap_points(point_proj_t P, point_proj_t Q, digit_t option)
+{ // Swap points
+  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P
+    digit_t temp;
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        temp = option & (P->X[0][i] ^ Q->X[0][i]);
+        P->X[0][i] = temp ^ P->X[0][i]; 
+        Q->X[0][i] = temp ^ Q->X[0][i]; 
+        temp = option & (P->Z[0][i] ^ Q->Z[0][i]);
+        P->Z[0][i] = temp ^ P->Z[0][i]; 
+        Q->Z[0][i] = temp ^ Q->Z[0][i]; 
+        temp = option & (P->X[1][i] ^ Q->X[1][i]);
+        P->X[1][i] = temp ^ P->X[1][i]; 
+        Q->X[1][i] = temp ^ Q->X[1][i]; 
+        temp = option & (P->Z[1][i] ^ Q->Z[1][i]);
+        P->Z[1][i] = temp ^ P->Z[1][i]; 
+        Q->Z[1][i] = temp ^ Q->Z[1][i]; 
+    }
+}
+
+
+void select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option)
+{ // Select either x or y depending on value of option 
+  // If option = 0 then z <- x, else if option = 0xFF...FF then z <- y
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        z[0][i] = (option & (x[0][i] ^ y[0][i])) ^ x[0][i]; 
+        z[1][i] = (option & (x[1][i] ^ y[1][i])) ^ x[1][i]; 
+    }
+}
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/generic/fp_generic.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/generic/fp_generic.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/generic/fp_generic.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/generic/fp_generic.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,251 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: portable modular arithmetic
+*
+*********************************************************************************************/
+
+#include "../SIDH_internal.h"
+
+
+// Global constants
+extern const uint64_t p751[NWORDS_FIELD];
+extern const uint64_t p751p1[NWORDS_FIELD]; 
+extern const uint64_t p751x2[NWORDS_FIELD]; 
+
+
+__inline void fpadd751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular addition, c = a+b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, carry = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], b[i], carry, c[i]); 
+    }
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(carry, c[i], ((digit_t*)p751x2)[i], carry, c[i]); 
+    }
+    mask = 0 - (digit_t)carry;
+
+    carry = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, c[i], ((digit_t*)p751x2)[i] & mask, carry, c[i]); 
+    }
+} 
+
+
+__inline void fpsub751(digit_t* a, digit_t* b, digit_t* c)
+{ // Modular subtraction, c = a-b mod p751.
+  // Inputs: a, b in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], b[i], borrow, c[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, c[i], ((digit_t*)p751x2)[i] & mask, borrow, c[i]); 
+    }
+}
+
+
+__inline void fpneg751(digit_t* a)
+{ // Modular negation, a = -a mod p751.
+  // Input/output: a in [0, 2*p751-1] 
+    unsigned int i, borrow = 0;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, ((digit_t*)p751x2)[i], a[i], borrow, a[i]); 
+    }
+}
+
+
+void fpdiv2_751(digit_t* a, digit_t* c)
+{ // Modular division by two, c = a/2 mod p751.
+  // Input : a in [0, 2*p751-1] 
+  // Output: c in [0, 2*p751-1] 
+    unsigned int i, carry = 0;
+    digit_t mask;
+        
+    mask = 0 - (digit_t)(a[0] & 1);    // If a is odd compute a+p521
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(carry, a[i], ((digit_t*)p751)[i] & mask, carry, c[i]); 
+    }
+
+    mp_shiftr1(c, NWORDS_FIELD);
+} 
+
+
+void fpcorrection751(digit_t* a)
+{ // Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].
+    unsigned int i, borrow = 0;
+    digit_t mask;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        SUBC(borrow, a[i], ((digit_t*)p751)[i], borrow, a[i]); 
+    }
+    mask = 0 - (digit_t)borrow;
+
+    borrow = 0;
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        ADDC(borrow, a[i], ((digit_t*)p751)[i] & mask, borrow, a[i]); 
+    }
+}
+
+
+void digit_x_digit(digit_t a, digit_t b, digit_t* c)
+{ // Digit multiplication, digit * digit -> 2-digit result    
+    register digit_t al, ah, bl, bh, temp;
+    digit_t albl, albh, ahbl, ahbh, res1, res2, res3, carry;
+    digit_t mask_low = (digit_t)(-1) >> (sizeof(digit_t)*4), mask_high = (digit_t)(-1) << (sizeof(digit_t)*4);
+
+    al = a & mask_low;                        // Low part
+    ah = a >> (sizeof(digit_t) * 4);          // High part
+    bl = b & mask_low;
+    bh = b >> (sizeof(digit_t) * 4);
+
+    albl = al*bl;
+    albh = al*bh;
+    ahbl = ah*bl;
+    ahbh = ah*bh;
+    c[0] = albl & mask_low;                   // C00
+
+    res1 = albl >> (sizeof(digit_t) * 4);
+    res2 = ahbl & mask_low;
+    res3 = albh & mask_low;  
+    temp = res1 + res2 + res3;
+    carry = temp >> (sizeof(digit_t) * 4);
+    c[0] ^= temp << (sizeof(digit_t) * 4);    // C01   
+
+    res1 = ahbl >> (sizeof(digit_t) * 4);
+    res2 = albh >> (sizeof(digit_t) * 4);
+    res3 = ahbh & mask_low;
+    temp = res1 + res2 + res3 + carry;
+    c[1] = temp & mask_low;                   // C10 
+    carry = temp & mask_high; 
+    c[1] ^= (ahbh & mask_high) + carry;       // C11
+}
+
+ 
+void mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.   
+    unsigned int i, j;
+    digit_t u, v, UV[2];
+    unsigned int carry = 0;
+
+     for (i = 0; i < (2*nwords); i++) c[i] = 0;
+
+     for (i = 0; i < nwords; i++) {
+          u = 0;
+          for (j = 0; j < nwords; j++) {
+               MUL(a[i], b[j], UV+1, UV[0]); 
+               ADDC(0, UV[0], u, carry, v); 
+               u = UV[1] + carry;
+               ADDC(0, c[i+j], v, carry, v); 
+               u = u + carry;
+               c[i+j] = v;
+          }
+          c[nwords+i] = u;
+     }
+}
+
+
+void mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)
+{ // Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.   
+    unsigned int i, j;
+    digit_t t = 0, u = 0, v = 0, UV[2];
+    unsigned int carry = 0;
+    
+    for (i = 0; i < nwords; i++) {
+        for (j = 0; j <= i; j++) {
+            MUL(a[j], b[i-j], UV+1, UV[0]); 
+            ADDC(0, UV[0], v, carry, v); 
+            ADDC(carry, UV[1], u, carry, u); 
+            t += carry;
+        }
+        c[i] = v;
+        v = u; 
+        u = t;
+        t = 0;
+    }
+
+    for (i = nwords; i < 2*nwords-1; i++) {
+        for (j = i-nwords+1; j < nwords; j++) {
+            MUL(a[j], b[i-j], UV+1, UV[0]); 
+            ADDC(0, UV[0], v, carry, v); 
+            ADDC(carry, UV[1], u, carry, u); 
+            t += carry;
+        }
+        c[i] = v;
+        v = u; 
+        u = t;
+        t = 0;
+    }
+    c[2*nwords-1] = v; 
+}
+
+
+void rdc_mont(dfelm_t ma, felm_t mc)
+{ // Optimized Montgomery reduction using comba and exploiting the special form of the prime p751.
+  // mc = ma*mb*R^-1 mod p751, where ma,mb,mc in [0, p751-1] and R = 2^768.
+  // ma and mb are assumed to be in Montgomery representation.
+    unsigned int i, j, carry, count = p751_ZERO_WORDS;
+    digit_t UV[2], t = 0, u = 0, v = 0;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        mc[i] = 0;
+    }
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        for (j = 0; j < i; j++) {
+            if (j < (i-p751_ZERO_WORDS+1)) { 
+                MUL(mc[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);
+                ADDC(0, UV[0], v, carry, v); 
+                ADDC(carry, UV[1], u, carry, u); 
+                t += carry; 
+            }
+        }
+        ADDC(0, v, ma[i], carry, v); 
+        ADDC(carry, u, 0, carry, u); 
+        t += carry; 
+        mc[i] = v;
+        v = u;
+        u = t;
+        t = 0;
+    }    
+
+    for (i = NWORDS_FIELD; i < 2*NWORDS_FIELD-1; i++) {
+        if (count > 0) {
+            count -= 1;
+        }
+        for (j = i-NWORDS_FIELD+1; j < NWORDS_FIELD; j++) {
+            if (j < (NWORDS_FIELD-count)) { 
+                MUL(mc[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);
+                ADDC(0, UV[0], v, carry, v); 
+                ADDC(carry, UV[1], u, carry, u); 
+                t += carry;
+            }
+        }
+        ADDC(0, v, ma[i], carry, v); 
+        ADDC(carry, u, 0, carry, u); 
+        t += carry; 
+        mc[i-NWORDS_FIELD] = v;
+        v = u;
+        u = t;
+        t = 0;
+    }
+    ADDC(0, v, ma[2*NWORDS_FIELD-1], carry, v); 
+    mc[NWORDS_FIELD-1] = v;
+}
\ No newline at end of file
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/kex.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/kex.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/kex.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/kex.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,387 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: isogeny-based key exchange
+*
+*********************************************************************************************/ 
+
+#include "SIDH_internal.h"
+
+extern const unsigned int splits_Alice[MAX_Alice];
+extern const unsigned int splits_Bob[MAX_Bob];
+
+
+CRYPTO_STATUS KeyGeneration_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyA, PCurveIsogenyStruct CurveIsogeny)
+{ // Alice's key-pair generation
+  // It produces a private key pPrivateKeyA and computes the public key pPublicKeyA.
+  // The private key is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). 
+  // The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    point_basefield_t P;
+    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_ALICE];
+    publickey_t* PublicKeyA = (publickey_t*)pPublicKeyA;
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; 
+    f2elm_t coeff[5], A = {0}, C = {0}, Aout, Cout;
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; 
+
+    if (pPrivateKeyA == NULL || pPublicKeyA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }  
+
+    // Choose a random even number in the range [2, oA-2] as secret key for Alice
+    Status = random_mod_order((digit_t*)pPrivateKeyA, ALICE, CurveIsogeny);    
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyA, owords);
+        return Status;
+    }
+
+    to_mont((digit_t*)CurveIsogeny->PA, (digit_t*)P);                               // Conversion of Alice's generators to Montgomery representation
+    to_mont(((digit_t*)CurveIsogeny->PA)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); 
+
+    Status = secret_pt(P, (digit_t*)pPrivateKeyA, ALICE, R, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyA, owords);
+        return Status;
+    }
+
+    copy_words((digit_t*)CurveIsogeny->PB, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Bob's public parameters, set Z <- 1
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);  
+    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        
+    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QB = (-XPB:1)
+    fpneg751(phiQ->X[0]);   
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z); 
+    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DB = (x(QB-PB),z(QB-PB))
+
+    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(A[0], A[0]);
+    to_mont(C[0], C[0]);
+
+    first_4_isog(phiP, A, Aout, Cout, CurveIsogeny);     
+    first_4_isog(phiQ, A, Aout, Cout, CurveIsogeny);
+    first_4_isog(phiD, A, Aout, Cout, CurveIsogeny);
+    first_4_isog(R, A, A, C, CurveIsogeny);
+    
+    index = 0;        
+    for (row = 1; row < MAX_Alice; row++) {
+        while (index < MAX_Alice-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Alice[MAX_Alice-index-row];
+            xDBLe(R, R, A, C, (int)(2*m));
+            index += m;
+        }
+        get_4_isog(R, A, C, coeff);        
+
+        for (i = 0; i < npts; i++) {
+            eval_4_isog(pts[i], coeff);
+        }
+        eval_4_isog(phiP, coeff);
+        eval_4_isog(phiQ, coeff);
+        eval_4_isog(phiD, coeff);
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+
+    get_4_isog(R, A, C, coeff); 
+    eval_4_isog(phiP, coeff);
+    eval_4_isog(phiQ, coeff);
+    eval_4_isog(phiD, coeff);
+
+    inv_3_way(phiP->Z, phiQ->Z, phiD->Z);
+    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);
+    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);
+    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);
+                                   
+    from_fp2mont(phiP->X, ((f2elm_t*)PublicKeyA)[0]);                               // Converting back to standard representation
+    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKeyA)[1]);
+    from_fp2mont(phiD->X, ((f2elm_t*)PublicKeyA)[2]);
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)phiP, 2*2*pwords);
+    clear_words((void*)phiQ, 2*2*pwords);
+    clear_words((void*)phiD, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+    clear_words((void*)coeff, 5*2*pwords);
+      
+    return Status;
+}
+
+
+CRYPTO_STATUS KeyGeneration_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyB, PCurveIsogenyStruct CurveIsogeny)
+{ // Bob's key-pair generation
+  // It produces a private key pPrivateKeyB and computes the public key pPublicKeyB.
+  // The private key is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). 
+  // The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    point_basefield_t P;
+    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_BOB];
+    publickey_t* PublicKeyB = (publickey_t*)pPublicKeyB;
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; 
+    f2elm_t A = {0}, C = {0};
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  
+
+    if (pPrivateKeyB == NULL || pPublicKeyB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }  
+
+    // Choose a random number equivalent to 0 (mod 3) in the range [3, oB-3] as secret key for Bob
+    Status = random_mod_order((digit_t*)pPrivateKeyB, BOB, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyB, owords);
+        return Status;
+    }
+
+    to_mont((digit_t*)CurveIsogeny->PB, (digit_t*)P);                               // Conversion of Bob's generators to Montgomery representation
+    to_mont(((digit_t*)CurveIsogeny->PB)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); 
+
+    Status = secret_pt(P, (digit_t*)pPrivateKeyB, BOB, R, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)pPrivateKeyB, owords);
+        return Status;
+    }
+
+    copy_words((digit_t*)CurveIsogeny->PA, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Alice's public parameters, set Z <- 1
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);   
+    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        // Conversion to Montgomery representation
+    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QA = (-XPA:1)
+    fpneg751(phiQ->X[0]); 
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z);  
+    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DA = (x(QA-PA),z(QA-PA))
+
+    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(A[0], A[0]);
+    to_mont(C[0], C[0]);
+    
+    index = 0;  
+    for (row = 1; row < MAX_Bob; row++) {
+        while (index < MAX_Bob-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Bob[MAX_Bob-index-row];
+            xTPLe(R, R, A, C, (int)m);
+            index += m;
+        }
+        get_3_isog(R, A, C);        
+
+        for (i = 0; i < npts; i++) {
+            eval_3_isog(R, pts[i]);
+        }     
+        eval_3_isog(R, phiP);
+        eval_3_isog(R, phiQ);
+        eval_3_isog(R, phiD);
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+    
+    get_3_isog(R, A, C);    
+    eval_3_isog(R, phiP);
+    eval_3_isog(R, phiQ);
+    eval_3_isog(R, phiD);
+
+    inv_3_way(phiP->Z, phiQ->Z, phiD->Z);
+    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);
+    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);
+    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);
+                                   
+    from_fp2mont(phiP->X, ((f2elm_t*)PublicKeyB)[0]);                               // Converting back to standard representation
+    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKeyB)[1]);
+    from_fp2mont(phiD->X, ((f2elm_t*)PublicKeyB)[2]);
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)phiP, 2*2*pwords);
+    clear_words((void*)phiQ, 2*2*pwords);
+    clear_words((void*)phiD, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+      
+    return Status;
+}
+
+
+CRYPTO_STATUS SecretAgreement_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyB, unsigned char* pSharedSecretA, bool validate, PCurveIsogenyStruct CurveIsogeny)
+{ // Alice's shared secret generation
+  // It produces a shared secret key pSharedSecretA using her secret key pPrivateKeyA and Bob's public key pPublicKeyB
+  // Inputs: Alice's pPrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). 
+  //         Bob's pPublicKeyB consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  //         "validate" flag that indicates if Alice must validate Bob's public key. 
+  // Output: a shared secret pSharedSecretA that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; 
+    point_proj_t R, pts[MAX_INT_POINTS_ALICE];
+    publickey_t* PublicKeyB = (publickey_t*)pPublicKeyB;
+    f2elm_t jinv, coeff[5], PKB[3], A, C = {0};
+    bool valid_PublicKey = false; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; 
+
+    if (pPrivateKeyA == NULL || pPublicKeyB == NULL || pSharedSecretA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+      
+    to_fp2mont(((f2elm_t*)PublicKeyB)[0], PKB[0]);    // Extracting and converting Bob's public curve parameters to Montgomery representation
+    to_fp2mont(((f2elm_t*)PublicKeyB)[1], PKB[1]);        
+    to_fp2mont(((f2elm_t*)PublicKeyB)[2], PKB[2]);
+
+    get_A(PKB[0], PKB[1], PKB[2], A, CurveIsogeny);
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(C[0], C[0]);
+
+    if (validate == true) {                           // Alice validating Bob's public key
+        Status = Validate_PKB(A, &PKB[0], &valid_PublicKey, CurveIsogeny);                   
+        if (Status != CRYPTO_SUCCESS) {  
+            return Status;
+        }  
+        if (valid_PublicKey != true) {
+            Status = CRYPTO_ERROR_PUBLIC_KEY_VALIDATION; 
+            return Status;
+        }
+    }
+
+    Status = ladder_3_pt(PKB[0], PKB[1], PKB[2], (digit_t*)pPrivateKeyA, ALICE, R, A, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        return Status;
+    }
+    first_4_isog(R, A, A, C, CurveIsogeny); 
+        
+    index = 0;  
+    for (row = 1; row < MAX_Alice; row++) {
+        while (index < MAX_Alice-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Alice[MAX_Alice-index-row];
+            xDBLe(R, R, A, C, (int)(2*m));
+            index += m;
+        }
+        get_4_isog(R, A, C, coeff);        
+
+        for (i = 0; i < npts; i++) {
+            eval_4_isog(pts[i], coeff);
+        }
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+    
+    get_4_isog(R, A, C, coeff); 
+    j_inv(A, C, jinv);
+    from_fp2mont(jinv, (felm_t*)pSharedSecretA);      // Converting back to standard representation
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+    clear_words((void*)jinv, 2*pwords);
+    clear_words((void*)coeff, 5*2*pwords);
+      
+    return Status;
+}
+
+
+CRYPTO_STATUS SecretAgreement_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyA, unsigned char* pSharedSecretB, bool validate, PCurveIsogenyStruct CurveIsogeny)
+{ // Bob's shared secret generation
+  // It produces a shared secret key pSharedSecretB using his secret key pPrivateKeyB and Alice's public key pPublicKeyA
+  // Inputs: Bob's pPrivateKeyB is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). 
+  //         Alice's pPublicKeyA consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+  //         "validate" flag that indicates if Bob must validate Alice's public key. 
+  // Output: a shared secret pSharedSecretB that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);
+    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; 
+    point_proj_t R, pts[MAX_INT_POINTS_BOB];
+    publickey_t* PublicKeyA = (publickey_t*)pPublicKeyA;
+    f2elm_t jinv, A, PKA[3], C = {0};
+    bool valid_PublicKey = false; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  
+
+    if (pPrivateKeyB == NULL || pPublicKeyA == NULL || pSharedSecretB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+       
+    to_fp2mont(((f2elm_t*)PublicKeyA)[0], PKA[0]);    // Extracting and converting Alice's public curve parameters to Montgomery representation
+    to_fp2mont(((f2elm_t*)PublicKeyA)[1], PKA[1]);       
+    to_fp2mont(((f2elm_t*)PublicKeyA)[2], PKA[2]);
+    
+    get_A(PKA[0], PKA[1], PKA[2], A, CurveIsogeny);
+    fpcopy751(CurveIsogeny->C, C[0]);
+    to_mont(C[0], C[0]);
+
+    if (validate == true) {                           // Bob validating Alice's public key
+        Status = Validate_PKA(A, &PKA[0], &valid_PublicKey, CurveIsogeny);                   
+        if (Status != CRYPTO_SUCCESS) {  
+            return Status;
+        }  
+        if (valid_PublicKey != true) {
+            Status = CRYPTO_ERROR_PUBLIC_KEY_VALIDATION; 
+            return Status;
+        }
+    }
+
+    Status = ladder_3_pt(PKA[0], PKA[1], PKA[2], (digit_t*)pPrivateKeyB, BOB, R, A, CurveIsogeny);
+    if (Status != CRYPTO_SUCCESS) {
+        return Status;
+    }
+    
+    index = 0;  
+    for (row = 1; row < MAX_Bob; row++) {
+        while (index < MAX_Bob-row) {
+            fp2copy751(R->X, pts[npts]->X);
+            fp2copy751(R->Z, pts[npts]->Z);
+            pts_index[npts] = index;
+            npts += 1;
+            m = splits_Bob[MAX_Bob-index-row];
+            xTPLe(R, R, A, C, (int)m);
+            index += m;
+        }
+        get_3_isog(R, A, C);        
+
+        for (i = 0; i < npts; i++) {
+            eval_3_isog(R, pts[i]);
+        } 
+
+        fp2copy751(pts[npts-1]->X, R->X); 
+        fp2copy751(pts[npts-1]->Z, R->Z);
+        index = pts_index[npts-1];
+        npts -= 1;
+    }
+    
+    get_3_isog(R, A, C);    
+    j_inv(A, C, jinv);
+    from_fp2mont(jinv, (felm_t*)pSharedSecretB);      // Converting back to standard representation
+
+// Cleanup:
+    clear_words((void*)R, 2*2*pwords);
+    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);
+    clear_words((void*)A, 2*pwords);
+    clear_words((void*)C, 2*pwords);
+    clear_words((void*)jinv, 2*pwords);
+      
+    return Status;
+}
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/License.txt sidh/openssl-1.0.2g/crypto/sidh/sidhlib/License.txt
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/License.txt	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/License.txt	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,21 @@
+SIDH Library
+
+Copyright (c) Microsoft Corporation
+All rights reserved. 
+
+MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
+associated documentation files (the ""Software""), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, 
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial 
+portions of the Software.
+
+THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
+LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/makefile_kat_tests sidh/openssl-1.0.2g/crypto/sidh/sidhlib/makefile_kat_tests
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/makefile_kat_tests	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/makefile_kat_tests	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,109 @@
+####  Makefile for compilation on Linux  ####
+
+OPT=-O3     # Optimization option by default
+
+ifeq "$(CC)" "gcc"
+    COMPILER=gcc
+else ifeq "$(CC)" "clang"
+    COMPILER=clang
+endif
+
+ifeq "$(ARCH)" "x64"
+    ARCHITECTURE=_AMD64_
+else ifeq "$(ARCH)" "x86"
+    ARCHITECTURE=_X86_
+else ifeq "$(ARCH)" "ARM"
+    ARCHITECTURE=_ARM_
+endif
+
+ADDITIONAL_SETTINGS=
+ifeq "$(SET)" "EXTENDED"
+    ADDITIONAL_SETTINGS=-fwrapv -fomit-frame-pointer -march=native
+endif
+
+ifeq "$(ASM)" "TRUE"
+    USE_ASM=-D _ASM_
+endif
+
+ifeq "$(GENERIC)" "TRUE"
+    USE_GENERIC=-D _GENERIC_
+endif
+
+ifeq "$(ARCH)" "ARM"
+    ARM_SETTING=-lrt
+endif
+
+cc=$(COMPILER)
+CFLAGS=-c $(OPT) $(ADDITIONAL_SETTINGS) -D $(ARCHITECTURE) -D __LINUX__ $(USE_ASM) $(USE_GENERIC)
+LDFLAGS=
+ifeq "$(GENERIC)" "TRUE"
+    EXTRA_OBJECTS=fp_generic.o
+else
+ifeq "$(ARCH)" "x64"
+    EXTRA_OBJECTS=fp_x64.o fp_x64_asm.o
+endif
+endif
+OBJECTS=kex.o ec_isogeny.o validate.o SIDH.o SIDH_setup.o fpx.o $(EXTRA_OBJECTS)
+OBJECTS_TEST=test_extras.o
+OBJECTS_ARITH_TEST=arith_tests.o $(OBJECTS_TEST) $(OBJECTS)
+OBJECTS_KEX_TEST=kex_tests.o $(OBJECTS_TEST) $(OBJECTS)
+OBJECTS_KAT_TEST=kat_tests.o $(OBJECTS_TEST) $(OBJECTS)
+OBJECTS_ALL=$(OBJECTS) $(OBJECTS_ARITH_TEST) $(OBJECTS_KEX_TEST)
+
+kat_test: $(OBJECTS_KAT_TEST)
+	$(CC) -o kat_test $(OBJECTS_KAT_TEST) $(ARM_SETTING)
+
+arith_test: $(OBJECTS_ARITH_TEST)
+	$(CC) -o arith_test $(OBJECTS_ARITH_TEST) $(ARM_SETTING)
+
+kex_test: $(OBJECTS_KEX_TEST)
+	$(CC) -o kex_test $(OBJECTS_KEX_TEST) $(ARM_SETTING)
+
+kex.o: kex.c SIDH_internal.h
+	$(CC) $(CFLAGS) kex.c
+
+ec_isogeny.o: ec_isogeny.c SIDH_internal.h
+	$(CC) $(CFLAGS) ec_isogeny.c
+
+validate.o: validate.c SIDH_internal.h
+	$(CC) $(CFLAGS) validate.c
+
+SIDH.o: SIDH.c SIDH_internal.h
+	$(CC) $(CFLAGS) SIDH.c
+
+SIDH_setup.o: SIDH_setup.c SIDH_internal.h
+	$(CC) $(CFLAGS) SIDH_setup.c
+
+fpx.o: fpx.c SIDH_internal.h
+	$(CC) $(CFLAGS) fpx.c
+
+ifeq "$(GENERIC)" "TRUE"
+    fp_generic.o: generic/fp_generic.c
+	    $(CC) $(CFLAGS) generic/fp_generic.c
+else
+ifeq "$(ARCH)" "x64"
+    fp_x64.o: AMD64/fp_x64.c
+	    $(CC) $(CFLAGS) AMD64/fp_x64.c
+
+    fp_x64_asm.o: AMD64/fp_x64_asm.S
+	    $(CC) $(CFLAGS) AMD64/fp_x64_asm.S
+endif
+endif
+
+test_extras.o: tests/test_extras.c tests/test_extras.h
+	$(CC) $(CFLAGS) tests/test_extras.c
+
+arith_tests.o: tests/arith_tests.c SIDH_internal.h
+	$(CC) $(CFLAGS) tests/arith_tests.c
+
+kex_tests.o: tests/kex_tests.c SIDH.h
+	$(CC) $(CFLAGS) tests/kex_tests.c
+
+kat_tests.o: tests/kat_tests.c SIDH_internal.h
+	$(CC) $(CFLAGS) tests/kat_tests.c
+
+.PHONY: clean
+
+clean:
+	rm arith_test kex_test kat_test fp_generic.o fp_x64.o fp_x64_asm.o $(OBJECTS_ALL)
+
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/README.txt sidh/openssl-1.0.2g/crypto/sidh/sidhlib/README.txt
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/README.txt	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/README.txt	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,46 @@
+                                        SIDH v1.1 (C Edition)
+                                       =======================
+
+The SIDH v1.1 library (C Edition) is a supersingular isogeny-based cryptography library that implements a
+new suite of algorithms for a post-quantum resistant Diffie-Hellman key exchange scheme [2]. This scheme 
+provides approximately 128 bits of quantum security and 192 bits of classical security. 
+
+The library was developed by Microsoft Research for experimentation purposes. 
+
+*** THE ORIGINAL README HAS BEEN TRIMMED LEAVING ONLY THE INFO RELEVANT FOR THE OPENSSL INTEGRATION ***
+
+1. CONTENTS:
+   --------
+
+/                              - Library C and header files                                     
+AMD64/                         - Optimized implementation of the field arithmetic for x64 platforms
+generic/                       - Implementation of the field arithmetic in portable C
+README.txt                     - This readme file
+
+
+2. MAIN FEATURES:
+   -------------
+   
+- Support key exchange providing 128 bits of quantum security and 192 bits of classical security.
+- Support a peace-of-mind hybrid key exchange mode that adds a classical elliptic curve Diffie-Hellman 
+  key exchange on a high-security Montgomery curve providing 384 bits of classical ECDH security.
+- Protected against timing and cache-timing attacks through regular, constant-time implementation of 
+  all operations on secret key material.
+- Support for public key validation in static key exchange when private keys are used more than once.
+- Basic implementation of the underlying arithmetic functions using portable C to enable support on
+  a wide range of platforms including x64, x86 and ARM. 
+- Optimized implementation of the underlying arithmetic functions for x64 platforms with optional, 
+  high-performance x64 assembly for Linux.
+
+
+REFERENCES:
+----------
+
+[1]   Craig Costello, Patrick Longa, and Michael Naehrig.
+      Efficient algorithms for supersingular isogeny Diffie-Hellman.      
+      Advances in Cryptology - CRYPTO 2016 (to appear), 2016. 
+      Extended version available at: http://eprint.iacr.org/2016/413. 
+
+[2]   David Jao and Luca DeFeo. 
+      Towards quantum-resistant cryptosystems from supersingular elliptic curve isogenies.
+      PQCrypto 2011, LNCS 7071, pp. 19-34, 2011. 
\ No newline at end of file
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,102 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: supersingular elliptic curve isogeny parameters
+*
+*********************************************************************************************/  
+
+#include "SIDH_internal.h"
+
+
+// Encoding of field elements, elements over Z_order, elements over GF(p^2) and elliptic curve points:
+// --------------------------------------------------------------------------------------------------
+// Elements over GF(p) and Z_order are encoded with the least significant octet (and digit) located
+// at the leftmost position (i.e., little endian format). 
+// Elements (a+b*i) over GF(p^2), where a and b are defined over GF(p), are encoded as {b, a}, with b 
+// in the least significant position.
+// Elliptic curve points P = (x,y) are encoded as {x, y}, with x in the least significant position. 
+
+//
+// Curve isogeny system "SIDHp751". Base curve: Montgomery curve By^2 = Cx^3 + Ax^2 + Cx defined over GF(p751^2), where A=0, B=1 and C=1
+//
+
+CurveIsogenyStaticData CurveIsogeny_SIDHp751 = {
+    "SIDHp751", 768, 384,         // Curve isogeny system ID, smallest multiple of 32 larger than the prime bitlength and smallest multiple of 32 larger than the order bitlength
+    751,                          // Bitlength of the prime 
+    // Prime p751 = 2^372*3^239-1
+    { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xEEAFFFFFFFFFFFFF, 
+      0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C },                                                
+    // Base curve parameter "A"
+    { 0 },
+    // Base curve parameter "C"
+    { 1 },
+    // Order bitlength for Alice
+    372,
+    // Order of Alice's subgroup
+    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0010000000000000 }, 
+    // Order bitlength for Bob
+    379,
+    // Power of Bob's subgroup order
+    239,
+    // Order of Bob's subgroup
+    { 0xC968549F878A8EEB, 0x59B1A13F7CC76E3E, 0xE9867D6EBE876DA9, 0x2B5045CB25748084, 0x2909F97BADC66856, 0x06FE5D541F71C0E1 },    
+    // Alice's generator PA = (XPA,YPA), where XPA and YPA are defined over GF(p751)
+    { 0x4B0346F5CCE233E9, 0x632646086CE3ACD5, 0x5661D14AB7347693, 0xA58A20449AF1F133, 0xB9AC2F40C56D6FA4, 0x8E561E008FA0E3F3, 
+      0x6CAE096D5DB822C9, 0x83FDB7A4AD3E83E8, 0xB1317AD904386217, 0x3FA23F89F6BE06D2, 0x429C8D36FF46BCC9, 0x00003E82027A38E9,
+      0x12E0D620BFB341D5, 0x0F8EEA7370893430, 0x5A99EBEC3B5B8B00, 0x236C7FAC9E69F7FD, 0x0F147EF3BD0CFEC5, 0x8ED5950D80325A8D, 
+      0x1E911F50BF3F721A, 0x163A7421DFA8378D, 0xC331B043DA010E6A, 0x5E15915A755883B7, 0xB6236F5F598D56EB, 0x00003BBF8DCD4E7E },
+    // Bob's generator PB = (XPB,YPB), where XPB and YPB are defined over GF(p751)
+    { 0x76ED2325DCC93103, 0xD9E1DF566C1D26D3, 0x76AECB94B919AEED, 0xD3785AAAA4D646C5, 0xCB610E30288A7770, 0x9BD3778659023B9E, 
+      0xD5E69CF26DF23742, 0xA3AD8E17B9F9238C, 0xE145FE2D525160E0, 0xF8D5BCE859ED725D, 0x960A01AB8FF409A2, 0x00002F1D80EF06EF,
+      0x91479226A0687894, 0xBBC6BAF5F6BA40BB, 0x15B529122CFE3CA6, 0x7D12754F00E898A3, 0x76EBA0C8419745E9, 0x0A94F06CDFB3EADE,
+      0x399A6EDB2EEB2F9B, 0xE302C5129C049EEB, 0xC35892123951D4B6, 0x15445287ED1CC55D, 0x1ACAF351F09AB55A, 0x00000127A46D082A },
+    // BigMont's curve parameter A24 = (A+2)/4
+    156113,
+    // BigMont's order, where BigMont is defined by y^2=x^3+A*x^2+x
+    { 0xA59B73D250E58055, 0xCB063593D0BE10E1, 0xF6515CCB5D076CBB, 0x66880747EDDF5E20, 0xBA515248A6BFD4AB, 0x3B8EF00DDDDC789D,
+      0xB8FB25A1527E1E2A, 0xB6A566C684FDF31D, 0x0213A619F5BAFA1D, 0xA158AD41172C95D2, 0x0384A427E5EEB719, 0x00001BF975507DC7 },
+    // Montgomery constant Montgomery_R2 = (2^768)^2 mod p751
+    { 0x233046449DAD4058, 0xDB010161A696452A, 0x5E36941472E3FD8E, 0xF40BFE2082A2E706, 0x4932CCA8904F8751 ,0x1F735F1F1EE7FC81, 
+      0xA24F4D80C1048E18, 0xB56C383CCDB607C5, 0x441DD47B735F9C90, 0x5673ED2C6A6AC82A, 0x06C905261132294B, 0x000041AD830F1F35 },
+    // Montgomery constant -p751^-1 mod 2^768
+    { 0x0000000000000001, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xEEB0000000000000, 
+      0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x258C28E5D541F71C },
+    // Value one in Montgomery representation
+    { 0x00000000000249ad, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x8310000000000000,
+      0x5527b1e4375c6c66, 0x697797bf3f4f24d0, 0xc89db7b2ac5c4e2e, 0x4ca4b439d2076956, 0x10f7926c7512c7e9, 0x00002d5b24bce5e2 }
+};
+
+
+// Fixed parameters for isogeny tree computation
+
+const unsigned int splits_Alice[MAX_Alice] = {
+ 0, 1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 5, 6, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 12, 
+ 11, 12, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 17, 17, 18, 18, 17, 21, 17, 
+ 18, 21, 20, 21, 21, 21, 21, 21, 22, 25, 25, 25, 26, 27, 28, 28, 29, 30, 31, 
+ 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 35, 36, 36, 33, 36, 35, 36, 36, 35, 
+ 36, 36, 37, 38, 38, 39, 40, 41, 42, 38, 39, 40, 41, 42, 40, 46, 42, 43, 46, 
+ 46, 46, 46, 48, 48, 48, 48, 49, 49, 48, 53, 54, 51, 52, 53, 54, 55, 56, 57, 
+ 58, 59, 59, 60, 62, 62, 63, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 
+ 65, 66, 67, 65, 66, 67, 66, 69, 70, 66, 67, 66, 69, 70, 69, 70, 70, 71, 72, 
+ 71, 72, 72, 74, 74, 75, 72, 72, 74, 74, 75, 72, 72, 74, 75, 75, 72, 72, 74, 
+ 75, 75, 77, 77, 79, 80, 80, 82 };
+
+const unsigned int splits_Bob[MAX_Bob] = {
+  0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 
+ 10, 12, 12, 12, 12, 12, 12, 13, 14, 14, 15, 16, 16, 16, 16, 16, 17, 16, 16, 
+ 17, 19, 19, 20, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 24, 24, 25, 27, 
+ 27, 28, 28, 29, 28, 29, 28, 28, 28, 30, 28, 28, 28, 29, 30, 33, 33, 33, 33, 
+ 34, 35, 37, 37, 37, 37, 38, 38, 37, 38, 38, 38, 38, 38, 39, 43, 38, 38, 38, 
+ 38, 43, 40, 41, 42, 43, 48, 45, 46, 47, 47, 48, 49, 49, 49, 50, 51, 50, 49, 
+ 49, 49, 49, 51, 49, 53, 50, 51, 50, 51, 51, 51, 52, 55, 55, 55, 56, 56, 56, 
+ 56, 56, 58, 58, 61, 61, 61, 63, 63, 63, 64, 65, 65, 65, 65, 66, 66, 65, 65, 
+ 66, 66, 66, 66, 66, 66, 66, 71, 66, 73, 66, 66, 71, 66, 73, 66, 66, 71, 66, 
+ 73, 68, 68, 71, 71, 73, 73, 73, 75, 75, 78, 78, 78, 80, 80, 80, 81, 81, 82, 
+ 83, 84, 85, 86, 86, 86, 86, 86, 87, 86, 88, 86, 86, 86, 86, 88, 86, 88, 86, 
+ 86, 86, 88, 88, 86, 86, 86, 93, 90, 90, 92, 92, 92, 93, 93, 93, 93, 93, 97, 
+ 97, 97, 97, 97, 97 };
+                                         
\ No newline at end of file
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.h sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.h
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.h	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH.h	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,274 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: main header file
+*
+*********************************************************************************************/  
+
+#ifndef __SIDH_H__
+#define __SIDH_H__
+
+
+// For C++
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+
+// Definition of operating system
+
+#define OS_WIN       1
+#define OS_LINUX     2
+
+#if (defined(OPENSSL_SYS_WINDOWS) || defined(WINDOWS) || defined(OPENSSL_SYS_WIN64) || defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN32_UWIN) || defined(OPENSSL_SYS_WIN32_CYGWIN))
+    #define OS_TARGET OS_WIN
+#else
+    #define OS_TARGET OS_LINUX 
+#endif
+
+#if (defined(__x86_64__) || defined(__x86_64) || defined(__arch64__) || defined(_M_AMD64) || defined(_M_X64) || defined(_WIN64) || !defined(__LP64__))
+    #define TARGET TARGET_AMD64
+    #define RADIX           64
+    typedef uint64_t        digit_t;        // Unsigned 64-bit digit
+    typedef int64_t         sdigit_t;       // Signed 64-bit digit
+    #define NWORDS_FIELD    12              // Number of words of a 751-bit field element
+    #define p751_ZERO_WORDS 5               // Number of "0" digits in the least significant part of p751 - 1     
+#else
+    #define TARGET TARGET_x86
+    #define TARGET TARGET_ARM
+    #define RADIX           32
+    typedef uint32_t        digit_t;        // Unsigned 32-bit digit
+    typedef int32_t         sdigit_t;       // Signed 32-bit digit
+    #define NWORDS_FIELD    24 
+    #define p751_ZERO_WORDS 11
+#endif
+
+#define RADIX64         64
+
+// Extended datatype support
+#if defined(SIDH_ASM)
+#if (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)
+    #define SCALAR_INTRIN_SUPPORT   
+    typedef uint64_t uint128_t[2];
+#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_LINUX)
+    #define UINT128_SUPPORT
+    typedef unsigned uint128_t __attribute__((mode(TI))); 
+#endif
+#else   /* generic implementation */
+  typedef uint64_t uint128_t[2];
+#endif
+
+// Basic constants
+
+#define NBITS_FIELD     751  
+#define MAXBITS_FIELD   768                
+#define MAXWORDS_FIELD  ((MAXBITS_FIELD+RADIX-1)/RADIX)     // Max. number of words to represent field elements
+#define NWORDS64_FIELD  ((NBITS_FIELD+63)/64)               // Number of 64-bit words of a 751-bit field element 
+#define NBITS_ORDER     384
+#define NWORDS_ORDER    ((NBITS_ORDER+RADIX-1)/RADIX)       // Number of words of oA and oB, where oA and oB are the subgroup orders of Alice and Bob, resp.
+#define MAXBITS_ORDER   NBITS_ORDER                         
+#define MAXWORDS_ORDER  ((MAXBITS_ORDER+RADIX-1)/RADIX)     // Max. number of words to represent elements in [1, oA-1] or [1, oB].
+  
+// Basic constants for elliptic curve BigMont
+
+#define BIGMONT_NBITS_ORDER     749 
+#define BIGMONT_MAXBITS_ORDER   768  
+#define BIGMONT_NWORDS_ORDER    ((BIGMONT_NBITS_ORDER+RADIX-1)/RADIX)       // Number of words of BigMont's subgroup order.
+#define BIGMONT_MAXWORDS_ORDER  ((BIGMONT_MAXBITS_ORDER+RADIX-1)/RADIX)     // Max. number of words to represent elements in [1, BigMont_order].
+   
+
+// Definitions of the error-handling type and error codes
+
+typedef enum {
+    CRYPTO_SUCCESS,                          // 0x00
+    CRYPTO_ERROR,                            // 0x01
+    CRYPTO_ERROR_DURING_TEST,                // 0x02
+    CRYPTO_ERROR_UNKNOWN,                    // 0x03
+    CRYPTO_ERROR_NOT_IMPLEMENTED,            // 0x04
+    CRYPTO_ERROR_NO_MEMORY,                  // 0x05
+    CRYPTO_ERROR_INVALID_PARAMETER,          // 0x06
+    CRYPTO_ERROR_SHARED_KEY,                 // 0x07
+    CRYPTO_ERROR_PUBLIC_KEY_VALIDATION,      // 0x08
+    CRYPTO_ERROR_TOO_MANY_ITERATIONS,        // 0x09
+    CRYPTO_ERROR_END_OF_LIST
+} CRYPTO_STATUS;
+
+#define CRYPTO_STATUS_TYPE_SIZE (CRYPTO_ERROR_END_OF_LIST)
+
+
+// Definitions of the error messages
+// NOTE: they must match the error codes above
+
+#define CRYPTO_MSG_SUCCESS                                "CRYPTO_SUCCESS"
+#define CRYPTO_MSG_ERROR                                  "CRYPTO_ERROR"
+#define CRYPTO_MSG_ERROR_DURING_TEST                      "CRYPTO_ERROR_DURING_TEST"
+#define CRYPTO_MSG_ERROR_UNKNOWN                          "CRYPTO_ERROR_UNKNOWN"
+#define CRYPTO_MSG_ERROR_NOT_IMPLEMENTED                  "CRYPTO_ERROR_NOT_IMPLEMENTED"
+#define CRYPTO_MSG_ERROR_NO_MEMORY                        "CRYPTO_ERROR_NO_MEMORY"
+#define CRYPTO_MSG_ERROR_INVALID_PARAMETER                "CRYPTO_ERROR_INVALID_PARAMETER"
+#define CRYPTO_MSG_ERROR_SHARED_KEY                       "CRYPTO_ERROR_SHARED_KEY"
+#define CRYPTO_MSG_ERROR_PUBLIC_KEY_VALIDATION            "CRYPTO_ERROR_PUBLIC_KEY_VALIDATION"
+#define CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS              "CRYPTO_ERROR_TOO_MANY_ITERATIONS"                                                    
+
+
+// Definition of type for curve isogeny system identifiers. Currently valid value is "SIDHp751" (see SIDH.h)
+typedef char CurveIsogeny_ID[10];
+
+
+// Supersingular elliptic curve isogeny structures:
+
+// This data struct contains the static curve isogeny data
+typedef struct
+{    
+    CurveIsogeny_ID  CurveIsogeny;                           // Curve isogeny system identifier, base curve defined over GF(p^2) 
+    unsigned int     pwordbits;                              // Smallest multiple of 32 larger than the prime bitlength
+    unsigned int     owordbits;                              // Smallest multiple of 32 larger than the order bitlength
+    unsigned int     pbits;                                  // Bitlength of the prime p
+    uint64_t         prime[MAXWORDS_FIELD];                  // Prime p
+    uint64_t         A[MAXWORDS_FIELD];                      // Base curve parameter "A"
+    uint64_t         C[MAXWORDS_FIELD];                      // Base curve parameter "C"
+    unsigned int     oAbits;                                 // Order bitlength for Alice 
+    uint64_t         Aorder[MAXWORDS_ORDER];                 // Order of Alice's (sub)group 
+    unsigned int     oBbits;                                 // Order bitlength for Bob 
+    unsigned int     eB;                                     // Power of Bob's subgroup order (i.e., oB = 3^eB) 
+    uint64_t         Border[MAXWORDS_ORDER];                 // Order of Bob's (sub)group 
+    uint64_t         PA[2*MAXWORDS_FIELD];                   // Alice's generator PA = (XPA,YPA), where XPA and YPA are defined over GF(p)
+    uint64_t         PB[2*MAXWORDS_FIELD];                   // Bob's generator PB = (XPB,YPB), where XPB and YPB are defined over GF(p)
+    unsigned int     BigMont_A24;                            // BigMont's curve parameter A24 = (A+2)/4
+    uint64_t         BigMont_order[BIGMONT_MAXWORDS_ORDER];  // BigMont's subgroup order 
+    uint64_t         Montgomery_R2[MAXWORDS_FIELD];          // Montgomery constant (2^W)^2 mod p, using a suitable value W
+    uint64_t         Montgomery_pp[MAXWORDS_FIELD];          // Montgomery constant -p^-1 mod 2^W, using a suitable value W
+    uint64_t         Montgomery_one[MAXWORDS_FIELD];         // Value one in Montgomery representation
+} CurveIsogenyStaticData, *PCurveIsogenyStaticData;
+
+
+// This data struct is initialized with the targeted curve isogeny system during setup
+typedef struct
+{
+    CurveIsogeny_ID  CurveIsogeny;                           // Curve isogeny system identifier, base curve defined over GF(p^2) 
+    unsigned int     pwordbits;                              // Closest multiple of 32 to prime bitlength
+    unsigned int     owordbits;                              // Closest multiple of 32 to order bitlength
+    unsigned int     pbits;                                  // Bitlength of the prime p
+    digit_t*         prime;                                  // Prime p
+    digit_t*         A;                                      // Base curve parameter "A"
+    digit_t*         C;                                      // Base curve parameter "C"
+    unsigned int     oAbits;                                 // Order bitlength for Alice 
+    digit_t*         Aorder;                                 // Order of Alice's (sub)group 
+    unsigned int     oBbits;                                 // Order bitlength for Bob 
+    unsigned int     eB;                                     // Power of Bob's subgroup order (i.e., oB = 3^eB) 
+    digit_t*         Border;                                 // Order of Bob's (sub)group 
+    digit_t*         PA;                                     // Alice's generator PA = (XPA,YPA), where XPA and YPA are defined over GF(p)
+    digit_t*         PB;                                     // Bob's generator PB = (XPB,YPB), where XPB and YPB are defined over GF(p)
+    unsigned int     BigMont_A24;                            // BigMont's curve parameter A24 = (A+2)/4
+    digit_t*         BigMont_order;                          // BigMont's subgroup order
+    digit_t*         Montgomery_R2;                          // Montgomery constant (2^W)^2 mod p, using a suitable value W
+    digit_t*         Montgomery_pp;                          // Montgomery constant -p^-1 mod 2^W, using a suitable value W
+    digit_t*         Montgomery_one;                         // Value one in Montgomery representation
+} CurveIsogenyStruct, *PCurveIsogenyStruct;
+
+
+// Supported curve isogeny systems:
+
+// "SIDHp751", base curve: supersingular elliptic curve E: y^2 = x^3 + x
+extern CurveIsogenyStaticData CurveIsogeny_SIDHp751;
+
+
+/******************** Function prototypes ***********************/
+/*************** Setup/initialization functions *****************/ 
+
+// Dynamic allocation of memory for curve isogeny structure.
+// Returns NULL on error.
+PCurveIsogenyStruct SIDH_curve_allocate(PCurveIsogenyStaticData CurveData);
+
+// Initialize curve isogeny structure pCurveIsogeny with static data extracted from pCurveIsogenyData. 
+// This needs to be called after allocating memory for "pCurveIsogeny" using SIDH_curve_allocate().
+CRYPTO_STATUS SIDH_curve_initialize(PCurveIsogenyStruct pCurveIsogeny, PCurveIsogenyStaticData pCurveIsogenyData); 
+
+// Free memory for curve isogeny structure
+void SIDH_curve_free(PCurveIsogenyStruct pCurveIsogeny);
+
+// Output error/success message for a given CRYPTO_STATUS
+const char* SIDH_get_error_message(CRYPTO_STATUS Status);
+
+// Output random values in the range [1, order-1] in little endian format that can be used as private keys.
+CRYPTO_STATUS random_mod_order(digit_t* random_digits, unsigned int AliceOrBob, PCurveIsogenyStruct pCurveIsogeny);
+
+// Output random values in the range [1, BigMont_order-1] in little endian format that can be used as private keys
+// to compute scalar multiplications using the elliptic curve BigMont.
+CRYPTO_STATUS random_BigMont_mod_order(digit_t* random_digits, PCurveIsogenyStruct pCurveIsogeny);
+
+// Clear "nwords" digits from memory
+void clear_words(void* mem, digit_t nwords);
+
+/*********************** Key exchange API ***********************/ 
+
+// Alice's key-pair generation
+// It produces a private key pPrivateKeyA and computes the public key pPublicKeyA.
+// The private key is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total).  
+// The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS KeyGeneration_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyA, PCurveIsogenyStruct CurveIsogeny);
+
+// Bob's key-pair generation
+// It produces a private key pPrivateKeyB and computes the public key pPublicKeyB.
+// The private key is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total).  
+// The public key consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS KeyGeneration_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyB, PCurveIsogenyStruct CurveIsogeny);
+
+// Alice's shared secret generation
+// It produces a shared secret key pSharedSecretA using her secret key pPrivateKeyA and Bob's public key pPublicKeyB
+// Inputs: Alice's pPrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). 
+//         Bob's pPublicKeyB consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+//         "validate" flag that indicates if Alice must validate Bob's public key. 
+// Output: a shared secret pSharedSecretA that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS SecretAgreement_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyB, unsigned char* pSharedSecretA, bool validate, PCurveIsogenyStruct CurveIsogeny);
+
+// Bob's shared secret generation
+// It produces a shared secret key pSharedSecretB using his secret key pPrivateKeyB and Alice's public key pPublicKeyA
+// Inputs: Bob's pPrivateKeyB is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). 
+//         Alice's pPublicKeyA consists of 3 elements in GF(p751^2), i.e., 564 bytes.
+//         "validate" flag that indicates if Bob must validate Alice's public key. 
+// Output: a shared secret pSharedSecretB that consists of one element in GF(p751^2), i.e., 1502 bits in total. 
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS SecretAgreement_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyA, unsigned char* pSharedSecretB, bool validate, PCurveIsogenyStruct CurveIsogeny);
+
+/*********************** Scalar multiplication API using BigMont ***********************/ 
+
+// BigMont's scalar multiplication using the Montgomery ladder
+// Inputs: x, the affine x-coordinate of a point P on BigMont: y^2=x^3+A*x^2+x, 
+//         scalar m.
+// Output: xout, the affine x-coordinate of m*(x:1)
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS BigMont_ladder(unsigned char* x, digit_t* m, unsigned char* xout, PCurveIsogenyStruct CurveIsogeny);
+
+
+// Encoding of keys for isogeny system "SIDHp751" (wire format):
+// ------------------------------------------------------------
+// Elements over GF(p751) are encoded in 96 octets in little endian format (i.e., the least significant octet located at the leftmost position). 
+// Elements (a+b*i) over GF(p751^2), where a and b are defined over GF(p751), are encoded as {b, a}, with b in the least significant position.
+// Elements over Z_oA and Z_oB are encoded in 48 octets in little endian format. 
+//
+// Private keys pPrivateKeyA and pPrivateKeyB are defined in Z_oA and Z_oB (resp.) and can have values in the range [2, 2^372-2] and [1, 3^239-1], resp.
+// In the key exchange API, they are encoded in 48 octets in little endian format. 
+// Public keys pPublicKeyA and pPublicKeyB consist of four elements in GF(p751^2). In the key exchange API, they are encoded in 768 octets in little
+// endian format. 
+// Shared keys pSharedSecretA and pSharedSecretB consist of one element in GF(p751^2). In the key exchange API, they are encoded in 192 octets in little
+// endian format. 
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_internal.h sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_internal.h
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_internal.h	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_internal.h	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,429 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: internal header file
+*
+*********************************************************************************************/  
+
+#ifndef __SIDH_INTERNAL_H__
+#define __SIDH_INTERNAL_H__
+
+
+// For C++
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "SIDH.h"   
+    
+
+// Basic constants
+
+#define ALICE                 0
+#define BOB                   1 
+#define MAX_INT_POINTS_ALICE  8      
+// Fixed parameters for isogeny tree computation    
+#define MAX_INT_POINTS_BOB    10 
+#define MAX_Alice             185   
+#define MAX_Bob               239
+   
+
+// SIDH's basic element definitions and point representations
+
+typedef digit_t felm_t[NWORDS_FIELD];                             // Datatype for representing 751-bit field elements (768-bit max.)
+typedef digit_t dfelm_t[2*NWORDS_FIELD];                          // Datatype for representing double-precision 2x751-bit field elements (2x768-bit max.) 
+typedef felm_t  f2elm_t[2];                                       // Datatype for representing quadratic extension field elements GF(p751^2)
+typedef f2elm_t publickey_t[3];                                   // Datatype for representing public keys equivalent to three GF(p751^2) elements
+        
+typedef struct { f2elm_t x; f2elm_t y; } point_affine;            // Point representation in affine coordinates on Montgomery curve.
+typedef point_affine point_t[1]; 
+        
+typedef struct { f2elm_t X; f2elm_t Z; } point_proj;              // Point representation in projective XZ Montgomery coordinates.
+typedef point_proj point_proj_t[1]; 
+        
+typedef struct { felm_t x; felm_t y; } point_basefield_affine;    // Point representation in affine coordinates on Montgomery curve over the base field.
+typedef point_basefield_affine point_basefield_t[1];  
+        
+typedef struct { felm_t X; felm_t Z; } point_basefield_proj;      // Point representation in projective XZ Montgomery coordinates over the base field.
+typedef point_basefield_proj point_basefield_proj_t[1]; 
+    
+
+// Macro definitions
+
+#define NBITS_TO_NBYTES(nbits)      (((nbits)+7)/8)                                          // Conversion macro from number of bits to number of bytes
+#define NBITS_TO_NWORDS(nbits)      (((nbits)+(sizeof(digit_t)*8)-1)/(sizeof(digit_t)*8))    // Conversion macro from number of bits to number of computer words
+#define NBYTES_TO_NWORDS(nbytes)    (((nbytes)+sizeof(digit_t)-1)/sizeof(digit_t))           // Conversion macro from number of bytes to number of computer words
+
+// Macro to avoid compiler warnings when detecting unreferenced parameters
+#define UNREFERENCED_PARAMETER(PAR) (PAR)
+
+
+/********************** Constant-time unsigned comparisons ***********************/
+
+// The following functions return 1 (TRUE) if condition is true, 0 (FALSE) otherwise
+
+static __inline unsigned int is_digit_nonzero_ct(digit_t x)
+{ // Is x != 0?
+    return (unsigned int)((x | (0-x)) >> (RADIX-1));
+}
+
+static __inline unsigned int is_digit_zero_ct(digit_t x)
+{ // Is x = 0?
+    return (unsigned int)(1 ^ is_digit_nonzero_ct(x));
+}
+
+static __inline unsigned int is_digit_lessthan_ct(digit_t x, digit_t y)
+{ // Is x < y?
+    return (unsigned int)((x ^ ((x ^ y) | ((x - y) ^ y))) >> (RADIX-1)); 
+}
+
+
+/********************** Macros for platform-dependent operations **********************/
+
+#if !defined(SIDH_ASM)
+
+// Digit multiplication
+#define MUL(multiplier, multiplicand, hi, lo)                                                     \
+    digit_x_digit((multiplier), (multiplicand), &(lo));
+    
+// Digit addition with carry
+#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \
+    { digit_t tempReg = (addend1) + (digit_t)(carryIn);                                           \
+    (sumOut) = (addend2) + tempReg;                                                               \
+    (carryOut) = (is_digit_lessthan_ct(tempReg, (digit_t)(carryIn)) | is_digit_lessthan_ct((sumOut), tempReg)); }
+
+// Digit subtraction with borrow
+#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \
+    { digit_t tempReg = (minuend) - (subtrahend);                                                 \
+    unsigned int borrowReg = (is_digit_lessthan_ct((minuend), (subtrahend)) | ((borrowIn) & is_digit_zero_ct(tempReg)));  \
+    (differenceOut) = tempReg - (digit_t)(borrowIn);                                              \
+    (borrowOut) = borrowReg; }
+    
+// Shift right with flexible datatype
+#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (DigitSize - (shift)));
+    
+// Shift left with flexible datatype
+#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (DigitSize - (shift)));
+
+// 64x64-bit multiplication
+#define MUL128(multiplier, multiplicand, product)                                                 \
+    mp_mul((digit_t*)&(multiplier), (digit_t*)&(multiplicand), (digit_t*)&(product), NWORDS_FIELD/2);
+
+// 128-bit addition, inputs < 2^127
+#define ADD128(addend1, addend2, addition)                                                        \
+    mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);
+
+// 128-bit addition with output carry
+#define ADC128(addend1, addend2, carry, addition)                                                 \
+    (carry) = mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);
+
+#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)
+
+// Digit multiplication
+#define MUL(multiplier, multiplicand, hi, lo)                                                     \
+    (lo) = _umul128((multiplier), (multiplicand), (hi));                
+
+// Digit addition with carry
+#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \
+    (carryOut) = _addcarry_u64((carryIn), (addend1), (addend2), &(sumOut));
+
+// Digit subtraction with borrow
+#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \
+    (borrowOut) = _subborrow_u64((borrowIn), (minuend), (subtrahend), &(differenceOut));
+
+// Digit shift right
+#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = __shiftright128((lowIn), (highIn), (shift));
+
+// Digit shift left
+#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = __shiftleft128((lowIn), (highIn), (shift));
+
+// 64x64-bit multiplication
+#define MUL128(multiplier, multiplicand, product)                                                 \
+    (product)[0] = _umul128((multiplier), (multiplicand), &(product)[1]);
+
+// 128-bit addition, inputs < 2^127
+#define ADD128(addend1, addend2, addition)                                                        \
+    { unsigned char carry = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);         \
+    _addcarry_u64(carry, (addend1)[1], (addend2)[1], &(addition)[1]); }
+
+// 128-bit addition with output carry
+#define ADC128(addend1, addend2, carry, addition)                                                 \
+    (carry) = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);                       \
+    (carry) = _addcarry_u64((carry), (addend1)[1], (addend2)[1], &(addition)[1]); 
+
+// 128-bit subtraction, subtrahend < 2^127
+#define SUB128(minuend, subtrahend, difference)                                                   \
+    { unsigned char borrow = _subborrow_u64(0, (minuend)[0], (subtrahend)[0], &(difference)[0]);  \
+    _subborrow_u64(borrow, (minuend)[1], (subtrahend)[1], &(difference)[1]); }
+
+// 128-bit right shift, max. shift value is 64
+#define SHIFTR128(Input, shift, shiftOut)                                                         \
+    (shiftOut)[0]  = __shiftright128((Input)[0], (Input)[1], (shift));                            \
+    (shiftOut)[1] = (Input)[1] >> (shift);    
+
+// 128-bit left shift, max. shift value is 64
+#define SHIFTL128(Input, shift, shiftOut)                                                         \
+    (shiftOut)[1]  = __shiftleft128((Input)[0], (Input)[1], (shift));                             \
+    (shiftOut)[0] = (Input)[0] << (shift);  
+
+#define MULADD128(multiplier, multiplicand, addend, carry, result);    \
+    { uint128_t product;                                               \
+      MUL128(multiplier, multiplicand, product);                       \
+      ADC128(addend, product, carry, result); }   
+
+#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_LINUX)
+
+// Digit multiplication
+#define MUL(multiplier, multiplicand, hi, lo)                                                     \
+    { uint128_t tempReg = (uint128_t)(multiplier) * (uint128_t)(multiplicand);                    \
+    *(hi) = (digit_t)(tempReg >> RADIX);                                                          \
+    (lo) = (digit_t)tempReg; }
+
+// Digit addition with carry
+#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \
+    { uint128_t tempReg = (uint128_t)(addend1) + (uint128_t)(addend2) + (uint128_t)(carryIn);     \
+    (carryOut) = (digit_t)(tempReg >> RADIX);                                                     \
+    (sumOut) = (digit_t)tempReg; }  
+    
+// Digit subtraction with borrow
+#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \
+    { uint128_t tempReg = (uint128_t)(minuend) - (uint128_t)(subtrahend) - (uint128_t)(borrowIn); \
+    (borrowOut) = (digit_t)(tempReg >> (sizeof(uint128_t)*8 - 1));                                \
+    (differenceOut) = (digit_t)tempReg; }
+
+// Digit shift right
+#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (RADIX - (shift)));
+
+// Digit shift left
+#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \
+    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (RADIX - (shift)));
+
+#endif
+
+
+// Multiprecision multiplication selection
+#if !defined(SIDH_ASM) && (TARGET == TARGET_AMD64)
+    #define mp_mul_comba         mp_mul
+#else
+    #define mp_mul_schoolbook    mp_mul
+#endif
+
+
+
+/**************** Function prototypes ****************/
+/************* Multiprecision functions **************/ 
+
+// Copy wordsize digits, c = a, where lng(a) = nwords
+void copy_words(digit_t* a, digit_t* c, unsigned int nwords);
+
+// Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit 
+extern unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+// Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit 
+extern unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+// Multiprecision right shift by one
+void mp_shiftr1(digit_t* x, unsigned int nwords);
+
+// Multiprecision left right shift by one    
+void mp_shiftl1(digit_t* x, unsigned int nwords);
+
+// Digit multiplication, digit * digit -> 2-digit result
+void digit_x_digit(digit_t a, digit_t b, digit_t* c);    
+
+// Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.
+void mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+// Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.
+void mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);
+
+/************ Field arithmetic functions *************/
+
+// Copy of a field element, c = a
+void fpcopy751(felm_t a, felm_t c);
+
+// Zeroing a field element, a = 0
+void fpzero751(felm_t a);
+
+// Modular addition, c = a+b mod p751
+extern void fpadd751(digit_t* a, digit_t* b, digit_t* c);
+extern void fpadd751_asm(digit_t* a, digit_t* b, digit_t* c);
+
+// Modular subtraction, c = a-b mod p751
+extern void fpsub751(digit_t* a, digit_t* b, digit_t* c);
+extern void fpsub751_asm(digit_t* a, digit_t* b, digit_t* c);
+
+// Modular negation, a = -a mod p751        
+extern void fpneg751(digit_t* a);  
+
+// Modular division by two, c = a/2 mod p751.
+void fpdiv2_751(digit_t* a, digit_t* c);
+
+// Modular correction to reduce field element a in [0, 2*p751-1] to [0, p751-1].
+void fpcorrection751(digit_t* a);
+
+// 751-bit Montgomery reduction, c = a mod p
+void rdc_mont(digit_t* a, digit_t* c);
+            
+// Field multiplication using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768
+void fpmul751_mont(felm_t a, felm_t b, felm_t c);
+void mul751_asm(felm_t a, felm_t b, dfelm_t c);
+void rdc751_asm(dfelm_t ma, dfelm_t mc);
+   
+// Field squaring using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768
+void fpsqr751_mont(felm_t ma, felm_t mc);
+
+// Conversion to Montgomery representation
+void to_mont(felm_t a, felm_t mc);
+    
+// Conversion from Montgomery representation to standard representation
+void from_mont(felm_t ma, felm_t c);
+
+// Field inversion, a = a^-1 in GF(p751)
+void fpinv751_mont(felm_t a);
+
+/************ GF(p^2) arithmetic functions *************/
+    
+// Copy of a GF(p751^2) element, c = a
+void fp2copy751(f2elm_t a, f2elm_t c);
+
+// Zeroing a GF(p751^2) element, a = 0
+void fp2zero751(f2elm_t a);
+
+// GF(p751^2) negation, a = -a in GF(p751^2)
+void fp2neg751(f2elm_t a);
+
+// GF(p751^2) addition, c = a+b in GF(p751^2)
+extern void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c);           
+
+// GF(p751^2) subtraction, c = a-b in GF(p751^2)
+extern void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c); 
+
+// GF(p751^2) division by two, c = a/2  in GF(p751^2) 
+void fp2div2_751(f2elm_t a, f2elm_t c);
+
+// Modular correction, a = a in GF(p751^2)
+void fp2correction751(f2elm_t a);
+            
+// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)
+void fp2sqr751_mont(f2elm_t a, f2elm_t c);
+ 
+// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)
+void fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c);
+    
+// Conversion of a GF(p751^2) element to Montgomery representation
+void to_fp2mont(f2elm_t a, f2elm_t mc);
+
+// Conversion of a GF(p751^2) element from Montgomery representation to standard representation
+void from_fp2mont(f2elm_t ma, f2elm_t c);
+
+// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)
+void fp2inv751_mont(f2elm_t a);
+
+// Select either x or y depending on value of option 
+void select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option);
+
+/************ Elliptic curve and isogeny functions *************/
+
+// Check if curve isogeny structure is NULL
+bool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny);
+
+// Swap points over the base field 
+void swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option);
+
+// Swap points
+void swap_points(point_proj_t P, point_proj_t Q, digit_t option);
+
+// Computes the j-invariant of a Montgomery curve with projective constant.
+void j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv);
+
+// Simultaneous doubling and differential addition.
+void xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24);
+
+// Doubling of a Montgomery point in projective coordinates (X:Z).
+void xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24);
+
+// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.
+void xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);
+
+// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings and collects a few intermediate multiples.
+void xDBLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);
+
+// Differential addition.
+void xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ);
+
+// Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.
+void xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q);
+
+// Simultaneous doubling and differential addition over the base field.
+void xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24);
+
+// The Montgomery ladder
+void ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);
+
+// Computes key generation entirely in the base field
+CRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny);
+
+// Computes P+[m]Q via x-only arithmetic.
+CRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);
+
+// Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.
+void get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff);
+
+// Evaluates the isogeny at the point (X:Z) in the domain of the isogeny
+void eval_4_isog(point_proj_t P, f2elm_t* coeff);
+
+// Computes first 4-isogeny computed by Alice.
+void first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny);
+
+// Tripling of a Montgomery point in projective coordinates (X:Z).
+void xTPL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24);
+
+// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.
+void xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);
+
+// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings and collects a few intermediate multiples.    
+void xTPLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);
+
+// Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.
+void get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C);
+
+// Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).
+void eval_3_isog(point_proj_t P, point_proj_t Q);
+
+// 3-way simultaneous inversion
+void inv_3_way(f2elm_t z1, f2elm_t z2, f2elm_t z3);
+
+// Computing the point D = (x(Q-P),z(Q-P))
+void distort_and_diff(felm_t xP, point_proj_t d, PCurveIsogenyStruct CurveIsogeny);
+
+// Given the x-coordinates of P, Q, and R, returns the value A corresponding to the Montgomery curve E_A: y^2=x^3+A*x^2+x such that R=Q-P on E_A.
+void get_A(f2elm_t xP, f2elm_t xQ, f2elm_t xR, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);
+
+/************ Public key validation functions *************/
+
+// Validation of Alice's public key (ran by Bob)
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS Validate_PKA(f2elm_t A, publickey_t PKA, bool* valid, PCurveIsogenyStruct CurveIsogeny);
+
+// Validation of Bob's public key (ran by Alice)
+// CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+CRYPTO_STATUS Validate_PKB(f2elm_t A, publickey_t PKB, bool* valid, PCurveIsogenyStruct CurveIsogeny);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_setup.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_setup.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_setup.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/SIDH_setup.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,265 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: functions for initialization and getting randomness
+*
+*********************************************************************************************/ 
+
+#include <openssl/rand.h>
+#include "SIDH_internal.h"
+
+
+CRYPTO_STATUS SIDH_curve_initialize(PCurveIsogenyStruct pCurveIsogeny, PCurveIsogenyStaticData pCurveIsogenyData)
+{ // Initialize curve isogeny structure pCurveIsogeny with static data extracted from pCurveIsogenyData.
+  // This needs to be called after allocating memory for "pCurveIsogeny" using SIDH_curve_allocate().
+    unsigned int i, pwords, owords;
+
+    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+
+    for (i = 0; i < 8; i++) {    // Copy 8-character identifier
+        pCurveIsogeny->CurveIsogeny[i] = pCurveIsogenyData->CurveIsogeny[i];
+    }
+    pCurveIsogeny->pwordbits = pCurveIsogenyData->pwordbits;
+    pCurveIsogeny->owordbits = pCurveIsogenyData->owordbits;
+    pCurveIsogeny->pbits = pCurveIsogenyData->pbits;
+    pCurveIsogeny->oAbits = pCurveIsogenyData->oAbits;
+    pCurveIsogeny->oBbits = pCurveIsogenyData->oBbits;
+    pCurveIsogeny->eB = pCurveIsogenyData->eB;
+    pCurveIsogeny->BigMont_A24 = pCurveIsogenyData->BigMont_A24;
+
+    pwords = (pCurveIsogeny->pwordbits + RADIX - 1)/RADIX;
+    owords = (pCurveIsogeny->owordbits + RADIX - 1)/RADIX;
+    copy_words((digit_t*)pCurveIsogenyData->prime, pCurveIsogeny->prime, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->A, pCurveIsogeny->A, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->C, pCurveIsogeny->C, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Aorder, pCurveIsogeny->Aorder, owords);
+    copy_words((digit_t*)pCurveIsogenyData->Border, pCurveIsogeny->Border, owords);
+    copy_words((digit_t*)pCurveIsogenyData->PA, pCurveIsogeny->PA, 2*pwords);
+    copy_words((digit_t*)pCurveIsogenyData->PB, pCurveIsogeny->PB, 2*pwords);
+    copy_words((digit_t*)pCurveIsogenyData->BigMont_order, pCurveIsogeny->BigMont_order, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Montgomery_R2, pCurveIsogeny->Montgomery_R2, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Montgomery_pp, pCurveIsogeny->Montgomery_pp, pwords);
+    copy_words((digit_t*)pCurveIsogenyData->Montgomery_one, pCurveIsogeny->Montgomery_one, pwords);
+    
+    return CRYPTO_SUCCESS;
+}
+
+
+PCurveIsogenyStruct SIDH_curve_allocate(PCurveIsogenyStaticData CurveData)
+{ // Dynamic allocation of memory for curve isogeny structure.
+  // Returns NULL on error.
+    digit_t pbytes = (CurveData->pwordbits + 7)/8;
+    digit_t obytes = (CurveData->owordbits + 7)/8;
+    PCurveIsogenyStruct pCurveIsogeny = NULL;
+
+    pCurveIsogeny = (PCurveIsogenyStruct)OPENSSL_malloc(sizeof(CurveIsogenyStruct));
+    pCurveIsogeny->prime = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->A = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->C = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Aorder = (digit_t*)OPENSSL_malloc(obytes);
+    pCurveIsogeny->Border = (digit_t*)OPENSSL_malloc(obytes);
+    pCurveIsogeny->PA = (digit_t*)OPENSSL_malloc(2*pbytes);
+    pCurveIsogeny->PB = (digit_t*)OPENSSL_malloc(2*pbytes);
+    pCurveIsogeny->BigMont_order = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Montgomery_R2 = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Montgomery_pp = (digit_t*)OPENSSL_malloc(pbytes);
+    pCurveIsogeny->Montgomery_one = (digit_t*)OPENSSL_malloc(pbytes);
+
+    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {
+        return NULL;
+    }
+    return pCurveIsogeny;
+}
+
+
+void SIDH_curve_free(PCurveIsogenyStruct pCurveIsogeny)
+{ // Free memory for curve isogeny structure
+
+    if (pCurveIsogeny != NULL)
+    {
+        if (pCurveIsogeny->prime != NULL) 
+	  OPENSSL_free(pCurveIsogeny->prime);
+        if (pCurveIsogeny->A != NULL) 
+	  OPENSSL_free(pCurveIsogeny->A);
+        if (pCurveIsogeny->C != NULL) 
+	  OPENSSL_free(pCurveIsogeny->C);
+        if (pCurveIsogeny->Aorder != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Aorder);
+        if (pCurveIsogeny->Border != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Border);
+        if (pCurveIsogeny->PA != NULL) 
+	  OPENSSL_free(pCurveIsogeny->PA);
+        if (pCurveIsogeny->PB != NULL) 
+	  OPENSSL_free(pCurveIsogeny->PB);
+        if (pCurveIsogeny->BigMont_order != NULL) 
+	  OPENSSL_free(pCurveIsogeny->BigMont_order);
+        if (pCurveIsogeny->Montgomery_R2 != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Montgomery_R2);
+        if (pCurveIsogeny->Montgomery_pp != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Montgomery_pp);
+        if (pCurveIsogeny->Montgomery_one != NULL) 
+	  OPENSSL_free(pCurveIsogeny->Montgomery_one);
+
+        OPENSSL_free(pCurveIsogeny);
+    }
+}
+
+
+bool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny)
+{ // Check if curve isogeny structure is NULL
+
+    if (pCurveIsogeny == NULL || pCurveIsogeny->prime == NULL || pCurveIsogeny->A == NULL || pCurveIsogeny->C == NULL || pCurveIsogeny->Aorder == NULL || pCurveIsogeny->Border == NULL || 
+        pCurveIsogeny->PA == NULL || pCurveIsogeny->PB == NULL || pCurveIsogeny->BigMont_order == NULL || pCurveIsogeny->Montgomery_R2 == NULL || pCurveIsogeny->Montgomery_pp == NULL || 
+        pCurveIsogeny->Montgomery_one == NULL)
+    {
+        return true;
+    }
+    return false;
+}
+
+
+const char* SIDH_get_error_message(CRYPTO_STATUS Status)
+{ // Output error/success message for a given CRYPTO_STATUS
+    struct error_mapping {
+        unsigned int index;
+        char*        string;
+    } mapping[CRYPTO_STATUS_TYPE_SIZE] = {
+        {CRYPTO_SUCCESS, CRYPTO_MSG_SUCCESS},
+        {CRYPTO_ERROR, CRYPTO_MSG_ERROR},
+        {CRYPTO_ERROR_DURING_TEST, CRYPTO_MSG_ERROR_DURING_TEST},
+        {CRYPTO_ERROR_UNKNOWN, CRYPTO_MSG_ERROR_UNKNOWN},
+        {CRYPTO_ERROR_NOT_IMPLEMENTED, CRYPTO_MSG_ERROR_NOT_IMPLEMENTED},
+        {CRYPTO_ERROR_NO_MEMORY, CRYPTO_MSG_ERROR_NO_MEMORY},
+        {CRYPTO_ERROR_INVALID_PARAMETER, CRYPTO_MSG_ERROR_INVALID_PARAMETER},
+        {CRYPTO_ERROR_SHARED_KEY, CRYPTO_MSG_ERROR_SHARED_KEY},
+        {CRYPTO_ERROR_PUBLIC_KEY_VALIDATION, CRYPTO_MSG_ERROR_PUBLIC_KEY_VALIDATION},
+        {CRYPTO_ERROR_TOO_MANY_ITERATIONS, CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS}
+    };
+
+    if (Status >= CRYPTO_STATUS_TYPE_SIZE || mapping[Status].string == NULL) {
+        return "Unrecognized CRYPTO_STATUS";
+    } else {
+        return mapping[Status].string;
+    }
+};
+
+
+const uint64_t Border_div3[NWORDS_ORDER] = { 0xEDCD718A828384F9, 0x733B35BFD4427A14, 0xF88229CF94D7CF38, 0x63C56C990C7C2AD6, 0xB858A87E8F4222C7, 0x254C9C6B525EAF5 }; 
+
+
+CRYPTO_STATUS random_mod_order(digit_t* random_digits, unsigned int AliceOrBob, PCurveIsogenyStruct pCurveIsogeny)
+{ // Output random values in the range [1, order-1] in little endian format that can be used as private keys.
+  // It makes requests of random values with length "oAbits" (when AliceOrBob = 0) or "oBbits" (when AliceOrBob = 1). 
+  // The process repeats until random value is in [0, Aorder-2]  ([0, Border-2], resp.). 
+  // If successful, the output is given in "random_digits" in the range [1, Aorder-1] ([1, Border-1], resp.).
+    unsigned int ntry = 0, nbytes, nwords;    
+    digit_t t1[MAXWORDS_ORDER] = {0}, order2[MAXWORDS_ORDER] = {0};
+    unsigned char mask;
+    CRYPTO_STATUS Status = CRYPTO_SUCCESS;
+
+    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny) || AliceOrBob > 1) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+
+    clear_words((void*)random_digits, MAXWORDS_ORDER);     
+    t1[0] = 2;
+    if (AliceOrBob == ALICE) {
+        nbytes = (pCurveIsogeny->oAbits+7)/8;                  // Number of random bytes to be requested 
+        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oAbits);
+        mask = 0x07;                                           // Value for masking last random byte
+        copy_words(pCurveIsogeny->Aorder, order2, nwords);
+        mp_shiftr1(order2, nwords);                            // order/2
+        mp_sub(order2, t1, order2, nwords);                    // order2 = order/2-2
+    } else {
+        nbytes = (pCurveIsogeny->oBbits+7)/8;                    
+        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oBbits);
+        mask = 0x03;                                           // Value for masking last random byte
+        mp_sub((digit_t*)Border_div3, t1, order2, nwords);     // order2 = order/3-2
+    }
+
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)random_digits, nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte 
+    } while (mp_sub(order2, random_digits, t1, nwords) == 1);
+    
+    clear_words((void*)t1, MAXWORDS_ORDER);  
+    t1[0] = 1;
+    mp_add(random_digits, t1, random_digits, nwords);          
+    copy_words(random_digits, t1, nwords);
+    mp_shiftl1(random_digits, nwords);                         // Alice's output in the range [2, order-2]
+    if (AliceOrBob == BOB) {
+        mp_add(random_digits, t1, random_digits, nwords);      // Bob's output in the range [3, order-3]
+    }
+
+    return Status;
+}
+
+
+CRYPTO_STATUS random_BigMont_mod_order(digit_t* random_digits, PCurveIsogenyStruct pCurveIsogeny)
+{ // Output random values in the range [1, BigMont_order-1] in little endian format that can be used as private keys to compute scalar multiplications 
+  // using the elliptic curve BigMont.
+  // It makes requests of random values with length "BIGMONT_NBITS_ORDER". 
+  // The process repeats until random value is in [0, BigMont_order-2] 
+  // If successful, the output is given in "random_digits" in the range [1, BigMont_order-1].
+    unsigned int ntry = 0, nbytes = (BIGMONT_NBITS_ORDER+7)/8, nwords = NBITS_TO_NWORDS(BIGMONT_NBITS_ORDER);    
+    digit_t t1[BIGMONT_MAXWORDS_ORDER] = {0}, order2[BIGMONT_MAXWORDS_ORDER] = {0};
+    unsigned char mask;
+    CRYPTO_STATUS Status = CRYPTO_SUCCESS;
+
+    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny)) {
+        return CRYPTO_ERROR_INVALID_PARAMETER;
+    }
+
+    clear_words((void*)random_digits, BIGMONT_MAXWORDS_ORDER);     
+    t1[0] = 2;
+    mask = (unsigned char)(8*nbytes - BIGMONT_NBITS_ORDER);
+    mp_sub(pCurveIsogeny->BigMont_order, t1, order2, nwords);  // order2 = order-2
+    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte
+
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)random_digits, nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte 
+    } while (mp_sub(order2, random_digits, t1, nwords) == 1);
+    
+    clear_words((void*)t1, BIGMONT_MAXWORDS_ORDER);  
+    t1[0] = 1;
+    mp_add(random_digits, t1, random_digits, nwords);          // Output in the range [1, order-1]
+
+    return Status;
+}
+
+
+void clear_words(void* mem, digit_t nwords)
+{ // Clear digits from memory. "nwords" indicates the number of digits to be zeroed.
+  // This function uses the volatile type qualifier to inform the compiler not to optimize out the memory clearing.
+    unsigned int i;
+    volatile digit_t *v = mem; 
+
+    for (i = 0; i < nwords; i++) {
+        v[i] = 0;
+    }
+}
+
+
+
+
+
+
diff -Naur original/openssl-1.0.2g/crypto/sidh/sidhlib/validate.c sidh/openssl-1.0.2g/crypto/sidh/sidhlib/validate.c
--- original/openssl-1.0.2g/crypto/sidh/sidhlib/validate.c	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/crypto/sidh/sidhlib/validate.c	2016-07-20 08:28:03.331200610 -0700
@@ -0,0 +1,223 @@
+/********************************************************************************************
+* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key 
+*       exchange providing 128 bits of quantum security and 192 bits of classical security.
+*
+*    Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*
+* Abstract: functions for validation of public keys
+*           
+* SECURITY NOTE: these functions run in variable time because it is assumed that they are
+*                used over public data.
+*
+*********************************************************************************************/ 
+
+#include <openssl/rand.h>
+#include "SIDH_internal.h"
+
+
+static bool is_equal_fp(felm_t a, felm_t b)
+{ // Return true if a = b in GF(p751). Otherwise, return false
+    unsigned int i;
+
+    for (i = 0; i < NWORDS_FIELD; i++) {
+        if (a[i] != b[i]) {
+            return false; 
+        }
+    }
+
+    return true;
+}
+
+
+static bool is_equal_fp2(f2elm_t a, f2elm_t b)
+{ // Return true if a = b in GF(p751^2). Otherwise, return false
+
+    return (is_equal_fp(a[0], b[0]) && is_equal_fp(a[1], b[1]));
+}
+
+
+CRYPTO_STATUS random_fp2(f2elm_t f2value, PCurveIsogenyStruct pCurveIsogeny)
+{ // Output random value in GF(p751). It makes requests of random values to the "random_bytes" function. 
+  // If successful, the output is given in "f2value".
+    unsigned int ntry = 0, nbytes;    
+    felm_t t1, p751;
+    unsigned char mask;
+    clear_words((void*)f2value, 2*NWORDS_FIELD);    
+    fpcopy751(pCurveIsogeny->prime, p751);
+    nbytes = (pCurveIsogeny->pbits+7)/8;                       // Number of random bytes to be requested 
+    mask = (unsigned char)(8*nbytes - pCurveIsogeny->pbits);
+    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte
+
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, p751-1] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)&f2value[0], nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)&f2value[0])[nbytes-1] &= mask;       // Masking last byte 
+    } while (mp_sub(p751, f2value[0], t1, NWORDS_FIELD) == 1);
+
+    ntry = 0;
+    do {
+        ntry++;
+        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, p751-1] 
+            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;
+        }
+	if (!RAND_bytes((unsigned char*)&f2value[1], nbytes)) {
+            return CRYPTO_ERROR;
+        }
+        ((unsigned char*)&f2value[1])[nbytes-1] &= mask;       // Masking last byte 
+    } while (mp_sub(p751, f2value[1], t1, NWORDS_FIELD) == 1);
+
+// Cleanup
+    clear_words((void*)t1, NWORDS_FIELD);
+
+    return CRYPTO_SUCCESS;
+}
+
+
+static bool test_curve(f2elm_t A, f2elm_t rvalue, PCurveIsogenyStruct CurveIsogeny) 
+{ // This function checks that the curve is in the correct supersingular isogeny class via Sutherland's Monte Carlo algorithm. 
+  // It also checks that the curve is not a subfield curve. Both Alice and Bob call this same function in their respective validation procedures below. 
+  // Inputs: the curve constant A, corresponding to E_A: y^2=x^3+A*x^2+x,
+  //         a random value "rvalue" in Fp2.
+  // Output: returns "true" if curve is valid, "false" otherwise.
+    f2elm_t t0, t1, one = {0}, zero = {0};
+    point_proj_t rP, P1;
+    bool valid_curve;
+    
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);
+
+    // Test j invariant in Fp2\Fp
+    fp2sqr751_mont(A, t0);                             // t0 = a^2
+    fp2sub751(t0, one, t0);             
+    fp2sub751(t0, one, t0);             
+    fp2sub751(t0, one, t0);                            // t0 = t0-3
+    fp2sqr751_mont(t0, t1);                            // t1 = t0^2
+    fp2mul751_mont(t0, t1, t1);                        // t1 = t1*t0
+    fp2sub751(t0, one, t0);                            // t0 = t0-1
+    fpmul751_mont(t1[0], t0[1], t1[0]);
+    fpmul751_mont(t1[1], t0[0], t1[1]);  
+    fp2correction751(t1);  
+
+    valid_curve = !is_equal_fp(t1[0], t1[1]);
+        
+    // Test supersingular
+    fp2copy751(rvalue, rP->X);
+    fp2copy751(one, rP->Z);
+
+    xDBLe(rP, rP, A, one, 1);
+    xDBLe(rP, P1, A, one, 371);    
+    xTPLe(P1, P1, A, one, 239);    
+    fp2mul751_mont(rP->X, P1->Z, rP->X);               // X = X*Z1
+    fp2mul751_mont(rP->Z, P1->X, rP->Z);               // Z = Z*X1
+    fp2sub751(rP->X, rP->Z, rP->X);                    // X = X-Z
+    fp2mul751_mont(rP->X, P1->Z, rP->X);               // X = X*Z1 
+    fp2correction751(rP->X);  
+
+    return (valid_curve && is_equal_fp2(rP->X, zero));
+}
+
+
+CRYPTO_STATUS Validate_PKA(f2elm_t A, publickey_t PKA, bool* valid, PCurveIsogenyStruct CurveIsogeny)
+{ // Bob validating Alice's public key
+  // Inputs: Alice's public key [A,xP,xQ,xQP], where xP,xQ and xQP are contained in PKA,
+  //         the exponent eB (=239 for our curve) for Miller's algorithm.
+  // Output: valid = "true" if key is valid, "false" otherwise.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int eB1 = CurveIsogeny->eB - 1;    // eB1 = eB-1
+    f2elm_t t0, t1, rvalue, one = {0}, zero = {0};
+    point_proj_t P = {0}, Q = {0}; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;
+    
+    // Choose a random element in GF(p751^2) for Sutherland's algorithm. Assume that it is in Montgomery representation 
+    Status = random_fp2(rvalue, CurveIsogeny);    
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)rvalue, 2*NWORDS_FIELD);
+        return Status;
+    }
+    
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);
+    fp2copy751(PKA[0], P->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, P->Z[0]);
+    fp2copy751(PKA[1], Q->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, Q->Z[0]); 
+    
+    xTPLe(P, P, A, one, eB1);                      
+    xTPLe(Q, Q, A, one, eB1);    
+    fp2mul751_mont(P->X, Q->Z, t0);                         // t0 = XP*ZQ  
+    fp2mul751_mont(Q->X, P->Z, t1);                         // t1 = XQ*ZP   
+    fp2sub751(t0, t1, t0);                                  // t0 = t0-t1  
+    fp2mul751_mont(P->Z, t0, t0);                           // t0 = ZP*t0   
+    fp2mul751_mont(Q->Z, t0, t0);                           // t0 = ZQ*t0   
+    fp2correction751(t0);    
+    *valid = !is_equal_fp2(t0, zero);                       // Checks that ZP*ZQ*(XQ*ZP-XP*ZQ) != 0, i.e., that 3^(e-1)*P != 3^(e-1)*Q and neither P nor Q has order 3^(e-1)
+            
+    xTPLe(P, P, A, one, 1);                      
+    xTPLe(Q, Q, A, one, 1);   
+    fp2correction751(P->Z);   
+    fp2correction751(Q->Z);          
+    *valid = *valid & is_equal_fp2(P->Z, zero);             // Checks that 3^e*P = 0
+    *valid = *valid & is_equal_fp2(Q->Z, zero);             // Checks that 3^e*Q = 0
+    *valid = *valid & test_curve(A, rvalue, CurveIsogeny);  // Tests curve via Sutherland's algorithm
+
+    return CRYPTO_SUCCESS;
+}
+
+
+CRYPTO_STATUS Validate_PKB(f2elm_t A, publickey_t PKB, bool* valid, PCurveIsogenyStruct CurveIsogeny)
+{ // Alice validating Bob's public key
+  // Inputs: Bob's public key [A,xP,xQ,xQP], where xP,xQ and xQP are contained in PKB,
+  //         the exponent eA (=372 for our curve) for Miller's algorithm.
+  // Output: valid = "true" if key is valid, "false" otherwise.
+  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().
+    unsigned int oAbits2 = CurveIsogeny->oAbits - 2;    // oAbits2 = oAbits-2   
+    f2elm_t t0, t1, two, four, rvalue, one = {0}, zero = {0};
+    point_proj_t P = {0}, Q = {0}; 
+    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; 
+
+    // Choose a random element in GF(p751^2) for Sutherland's algorithm. Assume that it is in Montgomery representation 
+    Status = random_fp2(rvalue, CurveIsogeny);    
+    if (Status != CRYPTO_SUCCESS) {
+        clear_words((void*)rvalue, 2*NWORDS_FIELD);
+        return Status;
+    }
+    
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);
+    fp2copy751(PKB[0], P->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, P->Z[0]);
+    fp2copy751(PKB[1], Q->X);
+    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, Q->Z[0]);    
+
+    fp2add751(one, one, two); 
+    fp2add751(two, two, four);                              // four = 4    
+    xDBLe(P, P, A, one, oAbits2);                      
+    xDBLe(Q, Q, A, one, oAbits2);    
+    fp2mul751_mont(P->X, Q->Z, t0);                         // t0 = XP*ZQ  
+    fp2mul751_mont(Q->X, P->Z, t1);                         // t1 = XQ*ZP   
+    fp2sub751(t0, t1, t0);                                  // t0 = t0-t1  
+    fp2mul751_mont(P->Z, t0, t0);                           // t0 = ZP*t0   
+    fp2mul751_mont(Q->Z, t0, t0);                           // t0 = ZQ*t0  
+    fp2correction751(t0);  
+    *valid = !is_equal_fp2(t0, zero);                       // Checks that ZP*ZQ*(XQ*ZP-XP*ZQ) != 0, i.e., that 2^(e-2)*P != 2^(e-2)*Q and neither P nor Q has order 2^(e-2)
+    
+    fp2add751(A, two, t0);                                  // t0 = A+2
+    xDBL(P, P, t0, four);                      
+    xDBL(Q, Q, t0, four);   
+    fp2mul751_mont(P->Z, Q->Z, t0);                         // t0 = ZP*ZQ    
+    fp2correction751(t0);  
+    *valid = *valid & !is_equal_fp2(t0, zero);              // Checks that 2^(e-1)*P != 0 and 2^(e-1)*Q != 0
+        
+    xDBL(P, P, t0, four);                      
+    xDBL(Q, Q, t0, four);   
+    fp2correction751(P->Z);   
+    fp2correction751(Q->Z);      
+    *valid = *valid & is_equal_fp2(P->Z, zero);             // Checks that 2^e*P = 0
+    *valid = *valid & is_equal_fp2(Q->Z, zero);             // Checks that 2^e*Q = 0
+    *valid = *valid & test_curve(A, rvalue, CurveIsogeny);  // Tests curve via Sutherland's algorithm
+
+    return CRYPTO_SUCCESS;
+}
diff -Naur original/openssl-1.0.2g/.gitignore sidh/openssl-1.0.2g/.gitignore
--- original/openssl-1.0.2g/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/.gitignore	2016-07-20 08:28:03.299200611 -0700
@@ -0,0 +1,121 @@
+# Object files
+*.o
+*.obj
+
+# editor artefacts
+*.swp
+.#*
+#*#
+*~
+/.dir-locals.el
+
+# Top level excludes
+/Makefile.bak
+/Makefile
+/MINFO
+/*.a
+/include
+/*.pc
+/rehash.time
+/inc.*
+/makefile.*
+/out.*
+/tmp.*
+
+# Most *.c files under test/ are symlinks
+/test/*.c
+# Apart from these
+!/test/asn1test.c
+!/test/methtest.c
+!/test/dummytest.c
+!/test/igetest.c
+!/test/r160test.c
+!/test/fips_algvs.c
+
+/test/*.ss
+/test/*.srl
+/test/.rnd
+/test/test*.pem
+/test/newkey.pem
+
+# Certificate symbolic links
+*.0
+
+# Links under apps
+/apps/CA.pl
+/apps/md4.c
+
+
+# Auto generated headers
+/crypto/buildinf.h
+/crypto/opensslconf.h
+
+# Auto generated assembly language source files
+*.s
+!/crypto/bn/asm/pa-risc2.s
+!/crypto/bn/asm/pa-risc2W.s
+crypto/aes/asm/a_win32.asm
+crypto/bf/asm/b_win32.asm
+crypto/bn/asm/bn_win32.asm
+crypto/bn/asm/co_win32.asm
+crypto/bn/asm/mt_win32.asm
+crypto/cast/asm/c_win32.asm
+crypto/cpu_win32.asm
+crypto/des/asm/d_win32.asm
+crypto/des/asm/y_win32.asm
+crypto/md5/asm/m5_win32.asm
+crypto/rc4/asm/r4_win32.asm
+crypto/rc5/asm/r5_win32.asm
+crypto/ripemd/asm/rm_win32.asm
+crypto/sha/asm/s1_win32.asm
+crypto/sha/asm/sha512-sse2.asm
+ms/uptable.asm
+
+# Executables
+/apps/openssl
+/test/sha256t
+/test/sha512t
+/test/*test
+/test/fips_aesavs
+/test/fips_desmovs
+/test/fips_dhvs
+/test/fips_drbgvs
+/test/fips_dssvs
+/test/fips_ecdhvs
+/test/fips_ecdsavs
+/test/fips_rngvs
+/test/fips_test_suite
+*.so*
+*.dylib*
+*.dll*
+*.exe
+# Exceptions
+!/test/bctest
+!/crypto/des/times/486-50.sol
+
+# Misc auto generated files
+/tools/c_rehash
+/test/evptests.txt
+lib
+Makefile.save
+*.bak
+tags
+TAGS
+
+# Windows
+/tmp32
+/tmp32.dbg
+/tmp32dll
+/tmp32dll.dbg
+/out32
+/out32.dbg
+/out32dll
+/out32dll.dbg
+/inc32
+/MINFO
+ms/bcb.mak
+ms/libeay32.def
+ms/nt.mak
+ms/ntdll.mak
+ms/ssleay32.def
+ms/version32.rc
diff -Naur original/openssl-1.0.2g/Makefile sidh/openssl-1.0.2g/Makefile
--- original/openssl-1.0.2g/Makefile	2016-03-01 05:36:55.000000000 -0800
+++ sidh/openssl-1.0.2g/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,680 +0,0 @@
-### Generated automatically from Makefile.org by Configure.
-
-##
-## Makefile for OpenSSL
-##
-
-VERSION=1.0.2g
-MAJOR=1
-MINOR=0.2
-SHLIB_VERSION_NUMBER=1.0.0
-SHLIB_VERSION_HISTORY=
-SHLIB_MAJOR=1
-SHLIB_MINOR=0.0
-SHLIB_EXT=
-PLATFORM=dist
-OPTIONS= no-ec_nistp_64_gcc_128 no-gmp no-jpake no-krb5 no-libunbound no-md2 no-rc5 no-rfc3779 no-sctp no-shared no-ssl-trace no-ssl2 no-store no-unit-test no-weak-ssl-ciphers no-zlib no-zlib-dynamic static-engine
-CONFIGURE_ARGS=dist
-SHLIB_TARGET=
-
-# HERE indicates where this Makefile lives.  This can be used to indicate
-# where sub-Makefiles are expected to be.  Currently has very limited usage,
-# and should probably not be bothered with at all.
-HERE=.
-
-# INSTALL_PREFIX is for package builders so that they can configure
-# for, say, /usr/ and yet have everything installed to /tmp/somedir/usr/.
-# Normally it is left empty.
-INSTALL_PREFIX=
-INSTALLTOP=/usr/local/ssl
-
-# Do not edit this manually. Use Configure --openssldir=DIR do change this!
-OPENSSLDIR=/usr/local/ssl
-
-# NO_IDEA - Define to build without the IDEA algorithm
-# NO_RC4  - Define to build without the RC4 algorithm
-# NO_RC2  - Define to build without the RC2 algorithm
-# THREADS - Define when building with threads, you will probably also need any
-#           system defines as well, i.e. _REENTERANT for Solaris 2.[34]
-# TERMIO  - Define the termio terminal subsystem, needed if sgtty is missing.
-# TERMIOS - Define the termios terminal subsystem, Silicon Graphics.
-# LONGCRYPT - Define to use HPUX 10.x's long password modification to crypt(3).
-# DEVRANDOM - Give this the value of the 'random device' if your OS supports
-#           one.  32 bytes will be read from this when the random
-#           number generator is initalised.
-# SSL_FORBID_ENULL - define if you want the server to be not able to use the
-#           NULL encryption ciphers.
-#
-# LOCK_DEBUG - turns on lots of lock debug output :-)
-# REF_CHECK - turn on some xyz_free() assertions.
-# REF_PRINT - prints some stuff on structure free.
-# CRYPTO_MDEBUG - turns on my 'memory leak' detecting stuff
-# MFUNC - Make all Malloc/Free/Realloc calls call
-#       CRYPTO_malloc/CRYPTO_free/CRYPTO_realloc which can be setup to
-#       call application defined callbacks via CRYPTO_set_mem_functions()
-# MD5_ASM needs to be defined to use the x86 assembler for MD5
-# SHA1_ASM needs to be defined to use the x86 assembler for SHA1
-# RMD160_ASM needs to be defined to use the x86 assembler for RIPEMD160
-# Do not define B_ENDIAN or L_ENDIAN if 'unsigned long' == 8.  It must
-# equal 4.
-# PKCS1_CHECK - pkcs1 tests.
-
-CC= cc
-CFLAG= -O
-DEPFLAG= -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_LIBUNBOUND -DOPENSSL_NO_MD2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_SSL_TRACE -DOPENSSL_NO_SSL2 -DOPENSSL_NO_STORE -DOPENSSL_NO_UNIT_TEST -DOPENSSL_NO_WEAK_SSL_CIPHERS
-PEX_LIBS= 
-EX_LIBS= 
-EXE_EXT= 
-ARFLAGS= 
-AR= ar $(ARFLAGS) r
-RANLIB= /usr/bin/ranlib
-NM= nm
-PERL= /usr/bin/perl
-TAR= tar
-TARFLAGS= --no-recursion
-MAKEDEPPROG=makedepend
-LIBDIR=lib
-
-# We let the C compiler driver to take care of .s files. This is done in
-# order to be excused from maintaining a separate set of architecture
-# dependent assembler flags. E.g. if you throw -mcpu=ultrasparc at SPARC
-# gcc, then the driver will automatically translate it to -xarch=v8plus
-# and pass it down to assembler.
-AS=$(CC) -c
-ASFLAG=$(CFLAG)
-
-# For x86 assembler: Set PROCESSOR to 386 if you want to support
-# the 80386.
-PROCESSOR= 
-
-# CPUID module collects small commonly used assembler snippets
-CPUID_OBJ= mem_clr.o
-BN_ASM= bn_asm.o
-EC_ASM= 
-DES_ENC= des_enc.o fcrypt_b.o
-AES_ENC= aes_core.o aes_cbc.o
-BF_ENC= bf_enc.o
-CAST_ENC= c_enc.o
-RC4_ENC= rc4_enc.o rc4_skey.o
-RC5_ENC= rc5_enc.o
-MD5_ASM_OBJ= 
-SHA1_ASM_OBJ= 
-RMD160_ASM_OBJ= 
-WP_ASM_OBJ= wp_block.o
-CMLL_ENC= camellia.o cmll_misc.o cmll_cbc.o
-MODES_ASM_OBJ= 
-ENGINES_ASM_OBJ= 
-PERLASM_SCHEME= 
-
-# KRB5 stuff
-KRB5_INCLUDES=
-LIBKRB5=
-
-# Zlib stuff
-ZLIB_INCLUDE=
-LIBZLIB=
-
-# TOP level FIPS install directory.
-FIPSDIR=/usr/local/ssl/fips-2.0
-
-# This is the location of fipscanister.o and friends.
-# The FIPS module build will place it $(INSTALLTOP)/lib
-# but since $(INSTALLTOP) can only take the default value
-# when the module is built it will be in /usr/local/ssl/lib
-# $(INSTALLTOP) for this build may be different so hard
-# code the path.
-
-FIPSLIBDIR=
-
-# The location of the library which contains fipscanister.o
-# normally it will be libcrypto unless fipsdso is set in which
-# case it will be libfips. If not compiling in FIPS mode at all
-# this is empty making it a useful test for a FIPS compile.
-
-FIPSCANLIB=
-
-# Shared library base address. Currently only used on Windows.
-#
-
-BASEADDR=0xFB00000
-
-DIRS=   crypto ssl engines apps test tools
-ENGDIRS= ccgost
-SHLIBDIRS= crypto ssl
-
-# dirs in crypto to build
-SDIRS=  \
-	objects \
-	md4 md5 sha mdc2 hmac ripemd whrlpool \
-	des aes rc2 rc4 idea bf cast camellia seed modes \
-	bn ec rsa dsa ecdsa dh ecdh dso engine \
-	buffer bio stack lhash rand err \
-	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts srp cmac
-# keep in mind that the above list is adjusted by ./Configure
-# according to no-xxx arguments...
-
-# tests to perform.  "alltests" is a special word indicating that all tests
-# should be performed.
-TESTS = alltests
-
-MAKEFILE= Makefile
-
-MANDIR=$(OPENSSLDIR)/man
-MAN1=1
-MAN3=3
-MANSUFFIX=
-HTMLSUFFIX=html
-HTMLDIR=$(OPENSSLDIR)/html
-SHELL=/bin/sh
-
-TOP=    .
-ONEDIRS=out tmp
-EDIRS=  times doc bugs util include certs ms shlib mt demos perl sf dep VMS
-WDIRS=  windows
-LIBS=   libcrypto.a libssl.a
-SHARED_CRYPTO=libcrypto$(SHLIB_EXT)
-SHARED_SSL=libssl$(SHLIB_EXT)
-SHARED_LIBS=
-SHARED_LIBS_LINK_EXTS=
-SHARED_LDFLAGS=
-
-GENERAL=        Makefile
-BASENAME=       openssl
-NAME=           $(BASENAME)-$(VERSION)
-TARFILE=        ../$(NAME).tar
-EXHEADER=       e_os2.h
-HEADER=         e_os.h
-
-all: Makefile build_all
-
-# as we stick to -e, CLEARENV ensures that local variables in lower
-# Makefiles remain local and variable. $${VAR+VAR} is tribute to Korn
-# shell, which [annoyingly enough] terminates unset with error if VAR
-# is not present:-( TOP= && unset TOP is tribute to HP-UX /bin/sh,
-# which terminates unset with error if no variable was present:-(
-CLEARENV=	TOP= && unset TOP $${LIB+LIB} $${LIBS+LIBS}	\
-		$${INCLUDE+INCLUDE} $${INCLUDES+INCLUDES}	\
-		$${DIR+DIR} $${DIRS+DIRS} $${SRC+SRC}		\
-		$${LIBSRC+LIBSRC} $${LIBOBJ+LIBOBJ} $${ALL+ALL}	\
-		$${EXHEADER+EXHEADER} $${HEADER+HEADER}		\
-		$${GENERAL+GENERAL} $${CFLAGS+CFLAGS}		\
-		$${ASFLAGS+ASFLAGS} $${AFLAGS+AFLAGS}		\
-		$${LDCMD+LDCMD} $${LDFLAGS+LDFLAGS} $${SCRIPTS+SCRIPTS}	\
-		$${SHAREDCMD+SHAREDCMD} $${SHAREDFLAGS+SHAREDFLAGS}	\
-		$${SHARED_LIB+SHARED_LIB} $${LIBEXTRAS+LIBEXTRAS}
-
-# LC_ALL=C ensures that error [and other] messages are delivered in
-# same language for uniform treatment.
-BUILDENV=	LC_ALL=C PLATFORM='$(PLATFORM)' PROCESSOR='$(PROCESSOR)'\
-		CC='$(CC)' CFLAG='$(CFLAG)' 			\
-		AS='$(CC)' ASFLAG='$(CFLAG) -c'			\
-		AR='$(AR)' NM='$(NM)' RANLIB='$(RANLIB)'	\
-		CROSS_COMPILE='$(CROSS_COMPILE)'	\
-		PERL='$(PERL)' ENGDIRS='$(ENGDIRS)'		\
-		SDIRS='$(SDIRS)' LIBRPATH='$(INSTALLTOP)/$(LIBDIR)'	\
-		INSTALL_PREFIX='$(INSTALL_PREFIX)'		\
-		INSTALLTOP='$(INSTALLTOP)' OPENSSLDIR='$(OPENSSLDIR)'	\
-		LIBDIR='$(LIBDIR)'				\
-		MAKEDEPEND='$$$${TOP}/util/domd $$$${TOP} -MD $(MAKEDEPPROG)' \
-		DEPFLAG='-DOPENSSL_NO_DEPRECATED $(DEPFLAG)'	\
-		MAKEDEPPROG='$(MAKEDEPPROG)'			\
-		SHARED_LDFLAGS='$(SHARED_LDFLAGS)'		\
-		KRB5_INCLUDES='$(KRB5_INCLUDES)' LIBKRB5='$(LIBKRB5)'	\
-		ZLIB_INCLUDE='$(ZLIB_INCLUDE)' LIBZLIB='$(LIBZLIB)'	\
-		EXE_EXT='$(EXE_EXT)' SHARED_LIBS='$(SHARED_LIBS)'	\
-		SHLIB_EXT='$(SHLIB_EXT)' SHLIB_TARGET='$(SHLIB_TARGET)'	\
-		PEX_LIBS='$(PEX_LIBS)' EX_LIBS='$(EX_LIBS)'	\
-		CPUID_OBJ='$(CPUID_OBJ)' BN_ASM='$(BN_ASM)'	\
-		EC_ASM='$(EC_ASM)' DES_ENC='$(DES_ENC)' 	\
-		AES_ENC='$(AES_ENC)' CMLL_ENC='$(CMLL_ENC)'	\
-		BF_ENC='$(BF_ENC)' CAST_ENC='$(CAST_ENC)'	\
-		RC4_ENC='$(RC4_ENC)' RC5_ENC='$(RC5_ENC)'	\
-		SHA1_ASM_OBJ='$(SHA1_ASM_OBJ)'			\
-		MD5_ASM_OBJ='$(MD5_ASM_OBJ)'			\
-		RMD160_ASM_OBJ='$(RMD160_ASM_OBJ)'		\
-		WP_ASM_OBJ='$(WP_ASM_OBJ)'			\
-		MODES_ASM_OBJ='$(MODES_ASM_OBJ)'		\
-		ENGINES_ASM_OBJ='$(ENGINES_ASM_OBJ)'		\
-		PERLASM_SCHEME='$(PERLASM_SCHEME)'		\
-		FIPSLIBDIR='${FIPSLIBDIR}'			\
-		FIPSDIR='${FIPSDIR}'				\
-		FIPSCANLIB="$${FIPSCANLIB:-$(FIPSCANLIB)}"	\
-		THIS=$${THIS:-$@} MAKEFILE=Makefile MAKEOVERRIDES=
-# MAKEOVERRIDES= effectively "equalizes" GNU-ish and SysV-ish make flavors,
-# which in turn eliminates ambiguities in variable treatment with -e.
-
-# BUILD_CMD is a generic macro to build a given target in a given
-# subdirectory.  The target must be given through the shell variable
-# `target' and the subdirectory to build in must be given through `dir'.
-# This macro shouldn't be used directly, use RECURSIVE_BUILD_CMD or
-# BUILD_ONE_CMD instead.
-#
-# BUILD_ONE_CMD is a macro to build a given target in a given
-# subdirectory if that subdirectory is part of $(DIRS).  It requires
-# exactly the same shell variables as BUILD_CMD.
-#
-# RECURSIVE_BUILD_CMD is a macro to build a given target in all
-# subdirectories defined in $(DIRS).  It requires that the target
-# is given through the shell variable `target'.
-BUILD_CMD=  if [ -d "$$dir" ]; then \
-	    (	cd $$dir && echo "making $$target in $$dir..." && \
-		$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. DIR=$$dir $$target \
-	    ) || exit 1; \
-	    fi
-RECURSIVE_BUILD_CMD=for dir in $(DIRS); do $(BUILD_CMD); done
-BUILD_ONE_CMD=\
-	if expr " $(DIRS) " : ".* $$dir " >/dev/null 2>&1; then \
-		$(BUILD_CMD); \
-	fi
-
-reflect:
-	@[ -n "$(THIS)" ] && $(CLEARENV) && $(MAKE) $(THIS) -e $(BUILDENV)
-
-sub_all: build_all
-
-build_all: build_libs build_apps build_tests build_tools
-
-build_libs: build_libcrypto build_libssl openssl.pc
-
-build_libcrypto: build_crypto build_engines libcrypto.pc
-build_libssl: build_ssl libssl.pc
-
-build_crypto:
-	@dir=crypto; target=all; $(BUILD_ONE_CMD)
-build_ssl: build_crypto
-	@dir=ssl; target=all; $(BUILD_ONE_CMD)
-build_engines: build_crypto
-	@dir=engines; target=all; $(BUILD_ONE_CMD)
-build_apps: build_libs
-	@dir=apps; target=all; $(BUILD_ONE_CMD)
-build_tests: build_libs
-	@dir=test; target=all; $(BUILD_ONE_CMD)
-build_tools: build_libs
-	@dir=tools; target=all; $(BUILD_ONE_CMD)
-
-all_testapps: build_libs build_testapps
-build_testapps:
-	@dir=crypto; target=testapps; $(BUILD_ONE_CMD)
-
-fips_premain_dso$(EXE_EXT): libcrypto.a
-	[ -z "$(FIPSCANLIB)" ] || $(CC) $(CFLAG) -Iinclude \
-		-DFINGERPRINT_PREMAIN_DSO_LOAD -o $@  \
-		$(FIPSLIBDIR)fips_premain.c $(FIPSLIBDIR)fipscanister.o \
-		libcrypto.a $(EX_LIBS)
-
-libcrypto$(SHLIB_EXT): libcrypto.a fips_premain_dso$(EXE_EXT)
-	@if [ "$(SHLIB_TARGET)" != "" ]; then \
-		if [ "$(FIPSCANLIB)" = "libcrypto" ]; then \
-			FIPSLD_LIBCRYPTO=libcrypto.a ; \
-			FIPSLD_CC="$(CC)"; CC=$(FIPSDIR)/bin/fipsld; \
-			export CC FIPSLD_CC FIPSLD_LIBCRYPTO; \
-		fi; \
-		$(MAKE) -e SHLIBDIRS=crypto  CC="$${CC:-$(CC)}" build-shared && \
-		(touch -c fips_premain_dso$(EXE_EXT) || :); \
-	else \
-		echo "There's no support for shared libraries on this platform" >&2; \
-		exit 1; \
-	fi
-
-libssl$(SHLIB_EXT): libcrypto$(SHLIB_EXT) libssl.a
-	@if [ "$(SHLIB_TARGET)" != "" ]; then \
-		$(MAKE) SHLIBDIRS=ssl SHLIBDEPS='-lcrypto' build-shared; \
-	else \
-		echo "There's no support for shared libraries on this platform" >&2; \
-		exit 1; \
-	fi
-
-clean-shared:
-	@set -e; for i in $(SHLIBDIRS); do \
-		if [ -n "$(SHARED_LIBS_LINK_EXTS)" ]; then \
-			tmp="$(SHARED_LIBS_LINK_EXTS)"; \
-			for j in $${tmp:-x}; do \
-				( set -x; rm -f lib$$i$$j ); \
-			done; \
-		fi; \
-		( set -x; rm -f lib$$i$(SHLIB_EXT) ); \
-		if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
-			( set -x; rm -f cyg$$i$(SHLIB_EXT) lib$$i$(SHLIB_EXT).a ); \
-		fi; \
-	done
-
-link-shared:
-	@ set -e; for i in $(SHLIBDIRS); do \
-		$(MAKE) -f $(HERE)/Makefile.shared -e $(BUILDENV) \
-			LIBNAME=$$i LIBVERSION=$(SHLIB_MAJOR).$(SHLIB_MINOR) \
-			LIBCOMPATVERSIONS=";$(SHLIB_VERSION_HISTORY)" \
-			symlink.$(SHLIB_TARGET); \
-		libs="$$libs -l$$i"; \
-	done
-
-build-shared: do_$(SHLIB_TARGET) link-shared
-
-do_$(SHLIB_TARGET):
-	@ set -e; libs='-L. $(SHLIBDEPS)'; for i in $(SHLIBDIRS); do \
-		if [ "$$i" = "ssl" -a -n "$(LIBKRB5)" ]; then \
-			libs="$(LIBKRB5) $$libs"; \
-		fi; \
-		$(CLEARENV) && $(MAKE) -f Makefile.shared -e $(BUILDENV) \
-			LIBNAME=$$i LIBVERSION=$(SHLIB_MAJOR).$(SHLIB_MINOR) \
-			LIBCOMPATVERSIONS=";$(SHLIB_VERSION_HISTORY)" \
-			LIBDEPS="$$libs $(EX_LIBS)" \
-			link_a.$(SHLIB_TARGET); \
-		libs="-l$$i $$libs"; \
-	done
-
-libcrypto.pc: Makefile
-	@ ( echo 'prefix=$(INSTALLTOP)'; \
-	    echo 'exec_prefix=$${prefix}'; \
-	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
-	    echo 'includedir=$${prefix}/include'; \
-	    echo ''; \
-	    echo 'Name: OpenSSL-libcrypto'; \
-	    echo 'Description: OpenSSL cryptography library'; \
-	    echo 'Version: '$(VERSION); \
-	    echo 'Requires: '; \
-	    echo 'Libs: -L$${libdir} -lcrypto'; \
-	    echo 'Libs.private: $(EX_LIBS)'; \
-	    echo 'Cflags: -I$${includedir} $(KRB5_INCLUDES)' ) > libcrypto.pc
-
-libssl.pc: Makefile
-	@ ( echo 'prefix=$(INSTALLTOP)'; \
-	    echo 'exec_prefix=$${prefix}'; \
-	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
-	    echo 'includedir=$${prefix}/include'; \
-	    echo ''; \
-	    echo 'Name: OpenSSL-libssl'; \
-	    echo 'Description: Secure Sockets Layer and cryptography libraries'; \
-	    echo 'Version: '$(VERSION); \
-	    echo 'Requires.private: libcrypto'; \
-	    echo 'Libs: -L$${libdir} -lssl'; \
-	    echo 'Libs.private: $(EX_LIBS)'; \
-	    echo 'Cflags: -I$${includedir} $(KRB5_INCLUDES)' ) > libssl.pc
-
-openssl.pc: Makefile
-	@ ( echo 'prefix=$(INSTALLTOP)'; \
-	    echo 'exec_prefix=$${prefix}'; \
-	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
-	    echo 'includedir=$${prefix}/include'; \
-	    echo ''; \
-	    echo 'Name: OpenSSL'; \
-	    echo 'Description: Secure Sockets Layer and cryptography libraries and tools'; \
-	    echo 'Version: '$(VERSION); \
-	    echo 'Requires: libssl libcrypto' ) > openssl.pc
-
-Makefile: Makefile.org Configure config
-	@echo "Makefile is older than Makefile.org, Configure or config."
-	@echo "Reconfigure the source tree (via './config' or 'perl Configure'), please."
-	@false
-
-libclean:
-	rm -f *.map *.so *.so.* *.dylib *.dll engines/*.so engines/*.dll engines/*.dylib *.a engines/*.a */lib */*/lib
-
-clean:	libclean
-	rm -f shlib/*.o *.o core a.out fluff rehash.time testlog make.log cctest cctest.c
-	@set -e; target=clean; $(RECURSIVE_BUILD_CMD)
-	rm -f $(LIBS)
-	rm -f openssl.pc libssl.pc libcrypto.pc
-	rm -f speed.* .pure
-	rm -f $(TARFILE)
-	@set -e; for i in $(ONEDIRS) ;\
-	do \
-	rm -fr $$i/*; \
-	done
-
-makefile.one: files
-	$(PERL) util/mk1mf.pl >makefile.one; \
-	sh util/do_ms.sh
-
-files:
-	$(PERL) $(TOP)/util/files.pl Makefile > $(TOP)/MINFO
-	@set -e; target=files; $(RECURSIVE_BUILD_CMD)
-
-links:
-	@$(PERL) $(TOP)/util/mkdir-p.pl include/openssl
-	@$(PERL) $(TOP)/util/mklink.pl include/openssl $(EXHEADER)
-	@set -e; target=links; $(RECURSIVE_BUILD_CMD)
-
-gentests:
-	@(cd test && echo "generating dummy tests (if needed)..." && \
-	$(CLEARENV) && $(MAKE) -e $(BUILDENV) TESTS='$(TESTS)' OPENSSL_DEBUG_MEMORY=on generate );
-
-dclean:
-	rm -rf *.bak include/openssl certs/.0
-	@set -e; target=dclean; $(RECURSIVE_BUILD_CMD)
-
-rehash: rehash.time
-rehash.time: certs apps
-	@if [ -z "$(CROSS_COMPILE)" ]; then \
-		(OPENSSL="`pwd`/util/opensslwrap.sh"; \
-		[ -x "apps/openssl.exe" ] && OPENSSL="apps/openssl.exe" || :; \
-		OPENSSL_DEBUG_MEMORY=on; \
-		export OPENSSL OPENSSL_DEBUG_MEMORY; \
-		$(PERL) tools/c_rehash certs/demo) && \
-		touch rehash.time; \
-	else :; fi
-
-test:   tests
-
-tests: rehash
-	@(cd test && echo "testing..." && \
-	$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. TESTS='$(TESTS)' OPENSSL_DEBUG_MEMORY=on OPENSSL_CONF=../apps/openssl.cnf tests );
-	OPENSSL_CONF=apps/openssl.cnf util/opensslwrap.sh version -a
-
-report:
-	@$(PERL) util/selftest.pl
-
-update: errors stacks util/libeay.num util/ssleay.num TABLE
-	@set -e; target=update; $(RECURSIVE_BUILD_CMD)
-
-depend:
-	@set -e; target=depend; $(RECURSIVE_BUILD_CMD)
-
-lint:
-	@set -e; target=lint; $(RECURSIVE_BUILD_CMD)
-
-tags:
-	rm -f TAGS
-	find . -name '[^.]*.[ch]' | xargs etags -a
-
-errors:
-	$(PERL) util/ck_errf.pl -strict */*.c */*/*.c
-	$(PERL) util/mkerr.pl -recurse -write
-	(cd engines; $(MAKE) PERL=$(PERL) errors)
-
-stacks:
-	$(PERL) util/mkstack.pl -write
-
-util/libeay.num::
-	$(PERL) util/mkdef.pl crypto update
-
-util/ssleay.num::
-	$(PERL) util/mkdef.pl ssl update
-
-TABLE: Configure
-	(echo 'Output of `Configure TABLE'"':"; \
-	$(PERL) Configure TABLE) > TABLE
-
-# Build distribution tar-file. As the list of files returned by "find" is
-# pretty long, on several platforms a "too many arguments" error or similar
-# would occur. Therefore the list of files is temporarily stored into a file
-# and read directly, requiring GNU-Tar. Call "make TAR=gtar dist" if the normal
-# tar does not support the --files-from option.
-TAR_COMMAND=$(TAR) $(TARFLAGS) --files-from $(TARFILE).list \
-	                       --owner 0 --group 0 \
-			       --transform 's|^|$(NAME)/|' \
-			       -cvf -
-
-$(TARFILE).list:
-	find * \! -name STATUS \! -name TABLE \! -name '*.o' \! -name '*.a' \
-	       \! -name '*.so' \! -name '*.so.*'  \! -name 'openssl' \
-	       \( \! -name '*test' -o -name bctest -o -name pod2mantest \) \
-	       \! -name '.#*' \! -name '*~' \! -type l \
-	    | sort > $(TARFILE).list
-
-tar: $(TARFILE).list
-	find . -type d -print | xargs chmod 755
-	find . -type f -print | xargs chmod a+r
-	find . -type f -perm -0100 -print | xargs chmod a+x
-	$(TAR_COMMAND) | gzip --best > $(TARFILE).gz
-	rm -f $(TARFILE).list
-	ls -l $(TARFILE).gz
-
-tar-snap: $(TARFILE).list
-	$(TAR_COMMAND) > $(TARFILE)
-	rm -f $(TARFILE).list
-	ls -l $(TARFILE)
-
-dist:   
-	$(PERL) Configure dist
-	@$(MAKE) SDIRS='$(SDIRS)' clean
-	@$(MAKE) TAR='$(TAR)' TARFLAGS='$(TARFLAGS)' $(DISTTARVARS) tar
-
-install: all install_docs install_sw
-
-install_sw:
-	@$(PERL) $(TOP)/util/mkdir-p.pl $(INSTALL_PREFIX)$(INSTALLTOP)/bin \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR) \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl \
-		$(INSTALL_PREFIX)$(OPENSSLDIR)/misc \
-		$(INSTALL_PREFIX)$(OPENSSLDIR)/certs \
-		$(INSTALL_PREFIX)$(OPENSSLDIR)/private
-	@set -e; headerlist="$(EXHEADER)"; for i in $$headerlist;\
-	do \
-	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
-	done;
-	@set -e; target=install; $(RECURSIVE_BUILD_CMD)
-	@set -e; liblist="$(LIBS)"; for i in $$liblist ;\
-	do \
-		if [ -f "$$i" ]; then \
-		(       echo installing $$i; \
-			cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-			$(RANLIB) $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-			chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-			mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i ); \
-		fi; \
-	done;
-	@set -e; if [ -n "$(SHARED_LIBS)" ]; then \
-		tmp="$(SHARED_LIBS)"; \
-		for i in $${tmp:-x}; \
-		do \
-			if [ -f "$$i" -o -f "$$i.a" ]; then \
-			(       echo installing $$i; \
-				if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
-					c=`echo $$i | sed 's/^lib\(.*\)\.dll\.a/cyg\1-$(SHLIB_VERSION_NUMBER).dll/'`; \
-					cp $$c $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new; \
-					chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new; \
-					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c; \
-					cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i; \
-				else \
-					cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i; \
-				fi ); \
-				if expr $(PLATFORM) : 'mingw' > /dev/null; then \
-				(	case $$i in \
-						*crypto*) i=libeay32.dll;; \
-						*ssl*)    i=ssleay32.dll;; \
-					esac; \
-					echo installing $$i; \
-	 				cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
-	 				chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
-	 				mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i ); \
-				fi; \
-			fi; \
-		done; \
-		(	here="`pwd`"; \
-			cd $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR); \
-			$(MAKE) -f $$here/Makefile HERE="$$here" link-shared ); \
-		if [ "$(INSTALLTOP)" != "/usr" ]; then \
-			echo 'OpenSSL shared libraries have been installed in:'; \
-			echo '  $(INSTALLTOP)'; \
-			echo ''; \
-			sed -e '1,/^$$/d' doc/openssl-shared.txt; \
-		fi; \
-	fi
-	cp libcrypto.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libcrypto.pc
-	cp libssl.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libssl.pc
-	cp openssl.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/openssl.pc
-
-install_html_docs:
-	here="`pwd`"; \
-	filecase=; \
-	case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
-		filecase=-i; \
-	esac; \
-	for subdir in apps crypto ssl; do \
-		mkdir -p $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir; \
-		for i in doc/$$subdir/*.pod; do \
-			fn=`basename $$i .pod`; \
-			echo "installing html/$$fn.$(HTMLSUFFIX)"; \
-			cat $$i \
-			| sed -r 's/L<([^)]*)(\([0-9]\))?\|([^)]*)(\([0-9]\))?>/L<\1|\3>/g' \
-			| pod2html --podroot=doc --htmlroot=.. --podpath=apps:crypto:ssl \
-			| sed -r 's/<!DOCTYPE.*//g' \
-			> $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir/$$fn.$(HTMLSUFFIX); \
-			$(PERL) util/extract-names.pl < $$i | \
-				grep -v $$filecase "^$$fn\$$" | \
-				(cd $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir; \
-				 while read n; do \
-					PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$(HTMLSUFFIX) "$$n".$(HTMLSUFFIX); \
-				 done); \
-		done; \
-	done
-
-install_docs:
-	@$(PERL) $(TOP)/util/mkdir-p.pl \
-		$(INSTALL_PREFIX)$(MANDIR)/man1 \
-		$(INSTALL_PREFIX)$(MANDIR)/man3 \
-		$(INSTALL_PREFIX)$(MANDIR)/man5 \
-		$(INSTALL_PREFIX)$(MANDIR)/man7
-	@pod2man="`cd ./util; ./pod2mantest $(PERL)`"; \
-	here="`pwd`"; \
-	filecase=; \
-	case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
-		filecase=-i; \
-	esac; \
-	set -e; for i in doc/apps/*.pod; do \
-		fn=`basename $$i .pod`; \
-		sec=`$(PERL) util/extract-section.pl 1 < $$i`; \
-		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
-		(cd `$(PERL) util/dirname.pl $$i`; \
-		sh -c "$$pod2man \
-			--section=$$sec --center=OpenSSL \
-			--release=$(VERSION) `basename $$i`") \
-			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
-		$(PERL) util/extract-names.pl < $$i | \
-			(grep -v $$filecase "^$$fn\$$"; true) | \
-			(grep -v "[	]"; true) | \
-			(cd $(INSTALL_PREFIX)$(MANDIR)/man$$sec/; \
-			 while read n; do \
-				PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$${sec}$(MANSUFFIX) "$$n".$${sec}$(MANSUFFIX); \
-			 done); \
-	done; \
-	set -e; for i in doc/crypto/*.pod doc/ssl/*.pod; do \
-		fn=`basename $$i .pod`; \
-		sec=`$(PERL) util/extract-section.pl 3 < $$i`; \
-		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
-		(cd `$(PERL) util/dirname.pl $$i`; \
-		sh -c "$$pod2man \
-			--section=$$sec --center=OpenSSL \
-			--release=$(VERSION) `basename $$i`") \
-			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
-		$(PERL) util/extract-names.pl < $$i | \
-			(grep -v $$filecase "^$$fn\$$"; true) | \
-			(grep -v "[	]"; true) | \
-			(cd $(INSTALL_PREFIX)$(MANDIR)/man$$sec/; \
-			 while read n; do \
-				PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$${sec}$(MANSUFFIX) "$$n".$${sec}$(MANSUFFIX); \
-			 done); \
-	done
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur original/openssl-1.0.2g/Makefile.bak sidh/openssl-1.0.2g/Makefile.bak
--- original/openssl-1.0.2g/Makefile.bak	2016-03-01 05:36:54.000000000 -0800
+++ sidh/openssl-1.0.2g/Makefile.bak	1969-12-31 16:00:00.000000000 -0800
@@ -1,680 +0,0 @@
-### Generated automatically from Makefile.org by Configure.
-
-##
-## Makefile for OpenSSL
-##
-
-VERSION=1.0.2g
-MAJOR=1
-MINOR=0.2
-SHLIB_VERSION_NUMBER=1.0.0
-SHLIB_VERSION_HISTORY=
-SHLIB_MAJOR=1
-SHLIB_MINOR=0.0
-SHLIB_EXT=.so.$(SHLIB_MAJOR).$(SHLIB_MINOR)
-PLATFORM=linux-x86_64
-OPTIONS=-Wa,--noexecstack no-ec_nistp_64_gcc_128 no-gmp no-jpake no-krb5 no-libunbound no-md2 no-rc5 no-rfc3779 no-sctp no-shared no-ssl-trace no-ssl2 no-store no-unit-test no-weak-ssl-ciphers no-zlib no-zlib-dynamic static-engine
-CONFIGURE_ARGS=linux-x86_64 -Wa,--noexecstack
-SHLIB_TARGET=linux-shared
-
-# HERE indicates where this Makefile lives.  This can be used to indicate
-# where sub-Makefiles are expected to be.  Currently has very limited usage,
-# and should probably not be bothered with at all.
-HERE=.
-
-# INSTALL_PREFIX is for package builders so that they can configure
-# for, say, /usr/ and yet have everything installed to /tmp/somedir/usr/.
-# Normally it is left empty.
-INSTALL_PREFIX=
-INSTALLTOP=/usr/local/ssl
-
-# Do not edit this manually. Use Configure --openssldir=DIR do change this!
-OPENSSLDIR=/usr/local/ssl
-
-# NO_IDEA - Define to build without the IDEA algorithm
-# NO_RC4  - Define to build without the RC4 algorithm
-# NO_RC2  - Define to build without the RC2 algorithm
-# THREADS - Define when building with threads, you will probably also need any
-#           system defines as well, i.e. _REENTERANT for Solaris 2.[34]
-# TERMIO  - Define the termio terminal subsystem, needed if sgtty is missing.
-# TERMIOS - Define the termios terminal subsystem, Silicon Graphics.
-# LONGCRYPT - Define to use HPUX 10.x's long password modification to crypt(3).
-# DEVRANDOM - Give this the value of the 'random device' if your OS supports
-#           one.  32 bytes will be read from this when the random
-#           number generator is initalised.
-# SSL_FORBID_ENULL - define if you want the server to be not able to use the
-#           NULL encryption ciphers.
-#
-# LOCK_DEBUG - turns on lots of lock debug output :-)
-# REF_CHECK - turn on some xyz_free() assertions.
-# REF_PRINT - prints some stuff on structure free.
-# CRYPTO_MDEBUG - turns on my 'memory leak' detecting stuff
-# MFUNC - Make all Malloc/Free/Realloc calls call
-#       CRYPTO_malloc/CRYPTO_free/CRYPTO_realloc which can be setup to
-#       call application defined callbacks via CRYPTO_set_mem_functions()
-# MD5_ASM needs to be defined to use the x86 assembler for MD5
-# SHA1_ASM needs to be defined to use the x86 assembler for SHA1
-# RMD160_ASM needs to be defined to use the x86 assembler for RIPEMD160
-# Do not define B_ENDIAN or L_ENDIAN if 'unsigned long' == 8.  It must
-# equal 4.
-# PKCS1_CHECK - pkcs1 tests.
-
-CC= gcc
-CFLAG= -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -Wa,--noexecstack -m64 -DL_ENDIAN -O3 -Wall -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASM
-DEPFLAG= -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_LIBUNBOUND -DOPENSSL_NO_MD2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_SSL_TRACE -DOPENSSL_NO_SSL2 -DOPENSSL_NO_STORE -DOPENSSL_NO_UNIT_TEST -DOPENSSL_NO_WEAK_SSL_CIPHERS
-PEX_LIBS= 
-EX_LIBS= -ldl
-EXE_EXT= 
-ARFLAGS= 
-AR= ar $(ARFLAGS) r
-RANLIB= /usr/bin/ranlib
-NM= nm
-PERL= /usr/bin/perl
-TAR= tar
-TARFLAGS= --no-recursion
-MAKEDEPPROG= gcc
-LIBDIR=lib
-
-# We let the C compiler driver to take care of .s files. This is done in
-# order to be excused from maintaining a separate set of architecture
-# dependent assembler flags. E.g. if you throw -mcpu=ultrasparc at SPARC
-# gcc, then the driver will automatically translate it to -xarch=v8plus
-# and pass it down to assembler.
-AS=$(CC) -c
-ASFLAG=$(CFLAG)
-
-# For x86 assembler: Set PROCESSOR to 386 if you want to support
-# the 80386.
-PROCESSOR= 
-
-# CPUID module collects small commonly used assembler snippets
-CPUID_OBJ= x86_64cpuid.o
-BN_ASM= x86_64-gcc.o x86_64-mont.o x86_64-mont5.o x86_64-gf2m.o rsaz_exp.o rsaz-x86_64.o rsaz-avx2.o
-EC_ASM= ecp_nistz256.o ecp_nistz256-x86_64.o
-DES_ENC= des_enc.o fcrypt_b.o
-AES_ENC= aes-x86_64.o vpaes-x86_64.o bsaes-x86_64.o aesni-x86_64.o aesni-sha1-x86_64.o aesni-sha256-x86_64.o aesni-mb-x86_64.o
-BF_ENC= bf_enc.o
-CAST_ENC= c_enc.o
-RC4_ENC= rc4-x86_64.o rc4-md5-x86_64.o
-RC5_ENC= rc5_enc.o
-MD5_ASM_OBJ= md5-x86_64.o
-SHA1_ASM_OBJ= sha1-x86_64.o sha256-x86_64.o sha512-x86_64.o sha1-mb-x86_64.o sha256-mb-x86_64.o
-RMD160_ASM_OBJ= 
-WP_ASM_OBJ= wp-x86_64.o
-CMLL_ENC= cmll-x86_64.o cmll_misc.o
-MODES_ASM_OBJ= ghash-x86_64.o aesni-gcm-x86_64.o
-ENGINES_ASM_OBJ= 
-PERLASM_SCHEME= elf
-
-# KRB5 stuff
-KRB5_INCLUDES=
-LIBKRB5=
-
-# Zlib stuff
-ZLIB_INCLUDE=
-LIBZLIB=
-
-# TOP level FIPS install directory.
-FIPSDIR=/usr/local/ssl/fips-2.0
-
-# This is the location of fipscanister.o and friends.
-# The FIPS module build will place it $(INSTALLTOP)/lib
-# but since $(INSTALLTOP) can only take the default value
-# when the module is built it will be in /usr/local/ssl/lib
-# $(INSTALLTOP) for this build may be different so hard
-# code the path.
-
-FIPSLIBDIR=
-
-# The location of the library which contains fipscanister.o
-# normally it will be libcrypto unless fipsdso is set in which
-# case it will be libfips. If not compiling in FIPS mode at all
-# this is empty making it a useful test for a FIPS compile.
-
-FIPSCANLIB=
-
-# Shared library base address. Currently only used on Windows.
-#
-
-BASEADDR=0xFB00000
-
-DIRS=   crypto ssl engines apps test tools
-ENGDIRS= ccgost
-SHLIBDIRS= crypto ssl
-
-# dirs in crypto to build
-SDIRS=  \
-	objects \
-	md4 md5 sha mdc2 hmac ripemd whrlpool \
-	des aes rc2 rc4 idea bf cast camellia seed modes \
-	bn ec rsa dsa ecdsa dh ecdh dso engine \
-	buffer bio stack lhash rand err \
-	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	cms pqueue ts srp cmac
-# keep in mind that the above list is adjusted by ./Configure
-# according to no-xxx arguments...
-
-# tests to perform.  "alltests" is a special word indicating that all tests
-# should be performed.
-TESTS = alltests
-
-MAKEFILE= Makefile
-
-MANDIR=$(OPENSSLDIR)/man
-MAN1=1
-MAN3=3
-MANSUFFIX=
-HTMLSUFFIX=html
-HTMLDIR=$(OPENSSLDIR)/html
-SHELL=/bin/sh
-
-TOP=    .
-ONEDIRS=out tmp
-EDIRS=  times doc bugs util include certs ms shlib mt demos perl sf dep VMS
-WDIRS=  windows
-LIBS=   libcrypto.a libssl.a
-SHARED_CRYPTO=libcrypto$(SHLIB_EXT)
-SHARED_SSL=libssl$(SHLIB_EXT)
-SHARED_LIBS=
-SHARED_LIBS_LINK_EXTS=.so.$(SHLIB_MAJOR) .so
-SHARED_LDFLAGS=-m64
-
-GENERAL=        Makefile
-BASENAME=       openssl
-NAME=           $(BASENAME)-$(VERSION)
-TARFILE=        ../$(NAME).tar
-EXHEADER=       e_os2.h
-HEADER=         e_os.h
-
-all: Makefile build_all
-
-# as we stick to -e, CLEARENV ensures that local variables in lower
-# Makefiles remain local and variable. $${VAR+VAR} is tribute to Korn
-# shell, which [annoyingly enough] terminates unset with error if VAR
-# is not present:-( TOP= && unset TOP is tribute to HP-UX /bin/sh,
-# which terminates unset with error if no variable was present:-(
-CLEARENV=	TOP= && unset TOP $${LIB+LIB} $${LIBS+LIBS}	\
-		$${INCLUDE+INCLUDE} $${INCLUDES+INCLUDES}	\
-		$${DIR+DIR} $${DIRS+DIRS} $${SRC+SRC}		\
-		$${LIBSRC+LIBSRC} $${LIBOBJ+LIBOBJ} $${ALL+ALL}	\
-		$${EXHEADER+EXHEADER} $${HEADER+HEADER}		\
-		$${GENERAL+GENERAL} $${CFLAGS+CFLAGS}		\
-		$${ASFLAGS+ASFLAGS} $${AFLAGS+AFLAGS}		\
-		$${LDCMD+LDCMD} $${LDFLAGS+LDFLAGS} $${SCRIPTS+SCRIPTS}	\
-		$${SHAREDCMD+SHAREDCMD} $${SHAREDFLAGS+SHAREDFLAGS}	\
-		$${SHARED_LIB+SHARED_LIB} $${LIBEXTRAS+LIBEXTRAS}
-
-# LC_ALL=C ensures that error [and other] messages are delivered in
-# same language for uniform treatment.
-BUILDENV=	LC_ALL=C PLATFORM='$(PLATFORM)' PROCESSOR='$(PROCESSOR)'\
-		CC='$(CC)' CFLAG='$(CFLAG)' 			\
-		AS='$(CC)' ASFLAG='$(CFLAG) -c'			\
-		AR='$(AR)' NM='$(NM)' RANLIB='$(RANLIB)'	\
-		CROSS_COMPILE='$(CROSS_COMPILE)'	\
-		PERL='$(PERL)' ENGDIRS='$(ENGDIRS)'		\
-		SDIRS='$(SDIRS)' LIBRPATH='$(INSTALLTOP)/$(LIBDIR)'	\
-		INSTALL_PREFIX='$(INSTALL_PREFIX)'		\
-		INSTALLTOP='$(INSTALLTOP)' OPENSSLDIR='$(OPENSSLDIR)'	\
-		LIBDIR='$(LIBDIR)'				\
-		MAKEDEPEND='$$$${TOP}/util/domd $$$${TOP} -MD $(MAKEDEPPROG)' \
-		DEPFLAG='-DOPENSSL_NO_DEPRECATED $(DEPFLAG)'	\
-		MAKEDEPPROG='$(MAKEDEPPROG)'			\
-		SHARED_LDFLAGS='$(SHARED_LDFLAGS)'		\
-		KRB5_INCLUDES='$(KRB5_INCLUDES)' LIBKRB5='$(LIBKRB5)'	\
-		ZLIB_INCLUDE='$(ZLIB_INCLUDE)' LIBZLIB='$(LIBZLIB)'	\
-		EXE_EXT='$(EXE_EXT)' SHARED_LIBS='$(SHARED_LIBS)'	\
-		SHLIB_EXT='$(SHLIB_EXT)' SHLIB_TARGET='$(SHLIB_TARGET)'	\
-		PEX_LIBS='$(PEX_LIBS)' EX_LIBS='$(EX_LIBS)'	\
-		CPUID_OBJ='$(CPUID_OBJ)' BN_ASM='$(BN_ASM)'	\
-		EC_ASM='$(EC_ASM)' DES_ENC='$(DES_ENC)' 	\
-		AES_ENC='$(AES_ENC)' CMLL_ENC='$(CMLL_ENC)'	\
-		BF_ENC='$(BF_ENC)' CAST_ENC='$(CAST_ENC)'	\
-		RC4_ENC='$(RC4_ENC)' RC5_ENC='$(RC5_ENC)'	\
-		SHA1_ASM_OBJ='$(SHA1_ASM_OBJ)'			\
-		MD5_ASM_OBJ='$(MD5_ASM_OBJ)'			\
-		RMD160_ASM_OBJ='$(RMD160_ASM_OBJ)'		\
-		WP_ASM_OBJ='$(WP_ASM_OBJ)'			\
-		MODES_ASM_OBJ='$(MODES_ASM_OBJ)'		\
-		ENGINES_ASM_OBJ='$(ENGINES_ASM_OBJ)'		\
-		PERLASM_SCHEME='$(PERLASM_SCHEME)'		\
-		FIPSLIBDIR='${FIPSLIBDIR}'			\
-		FIPSDIR='${FIPSDIR}'				\
-		FIPSCANLIB="$${FIPSCANLIB:-$(FIPSCANLIB)}"	\
-		THIS=$${THIS:-$@} MAKEFILE=Makefile MAKEOVERRIDES=
-# MAKEOVERRIDES= effectively "equalizes" GNU-ish and SysV-ish make flavors,
-# which in turn eliminates ambiguities in variable treatment with -e.
-
-# BUILD_CMD is a generic macro to build a given target in a given
-# subdirectory.  The target must be given through the shell variable
-# `target' and the subdirectory to build in must be given through `dir'.
-# This macro shouldn't be used directly, use RECURSIVE_BUILD_CMD or
-# BUILD_ONE_CMD instead.
-#
-# BUILD_ONE_CMD is a macro to build a given target in a given
-# subdirectory if that subdirectory is part of $(DIRS).  It requires
-# exactly the same shell variables as BUILD_CMD.
-#
-# RECURSIVE_BUILD_CMD is a macro to build a given target in all
-# subdirectories defined in $(DIRS).  It requires that the target
-# is given through the shell variable `target'.
-BUILD_CMD=  if [ -d "$$dir" ]; then \
-	    (	cd $$dir && echo "making $$target in $$dir..." && \
-		$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. DIR=$$dir $$target \
-	    ) || exit 1; \
-	    fi
-RECURSIVE_BUILD_CMD=for dir in $(DIRS); do $(BUILD_CMD); done
-BUILD_ONE_CMD=\
-	if expr " $(DIRS) " : ".* $$dir " >/dev/null 2>&1; then \
-		$(BUILD_CMD); \
-	fi
-
-reflect:
-	@[ -n "$(THIS)" ] && $(CLEARENV) && $(MAKE) $(THIS) -e $(BUILDENV)
-
-sub_all: build_all
-
-build_all: build_libs build_apps build_tests build_tools
-
-build_libs: build_libcrypto build_libssl openssl.pc
-
-build_libcrypto: build_crypto build_engines libcrypto.pc
-build_libssl: build_ssl libssl.pc
-
-build_crypto:
-	@dir=crypto; target=all; $(BUILD_ONE_CMD)
-build_ssl: build_crypto
-	@dir=ssl; target=all; $(BUILD_ONE_CMD)
-build_engines: build_crypto
-	@dir=engines; target=all; $(BUILD_ONE_CMD)
-build_apps: build_libs
-	@dir=apps; target=all; $(BUILD_ONE_CMD)
-build_tests: build_libs
-	@dir=test; target=all; $(BUILD_ONE_CMD)
-build_tools: build_libs
-	@dir=tools; target=all; $(BUILD_ONE_CMD)
-
-all_testapps: build_libs build_testapps
-build_testapps:
-	@dir=crypto; target=testapps; $(BUILD_ONE_CMD)
-
-fips_premain_dso$(EXE_EXT): libcrypto.a
-	[ -z "$(FIPSCANLIB)" ] || $(CC) $(CFLAG) -Iinclude \
-		-DFINGERPRINT_PREMAIN_DSO_LOAD -o $@  \
-		$(FIPSLIBDIR)fips_premain.c $(FIPSLIBDIR)fipscanister.o \
-		libcrypto.a $(EX_LIBS)
-
-libcrypto$(SHLIB_EXT): libcrypto.a fips_premain_dso$(EXE_EXT)
-	@if [ "$(SHLIB_TARGET)" != "" ]; then \
-		if [ "$(FIPSCANLIB)" = "libcrypto" ]; then \
-			FIPSLD_LIBCRYPTO=libcrypto.a ; \
-			FIPSLD_CC="$(CC)"; CC=$(FIPSDIR)/bin/fipsld; \
-			export CC FIPSLD_CC FIPSLD_LIBCRYPTO; \
-		fi; \
-		$(MAKE) -e SHLIBDIRS=crypto  CC="$${CC:-$(CC)}" build-shared && \
-		(touch -c fips_premain_dso$(EXE_EXT) || :); \
-	else \
-		echo "There's no support for shared libraries on this platform" >&2; \
-		exit 1; \
-	fi
-
-libssl$(SHLIB_EXT): libcrypto$(SHLIB_EXT) libssl.a
-	@if [ "$(SHLIB_TARGET)" != "" ]; then \
-		$(MAKE) SHLIBDIRS=ssl SHLIBDEPS='-lcrypto' build-shared; \
-	else \
-		echo "There's no support for shared libraries on this platform" >&2; \
-		exit 1; \
-	fi
-
-clean-shared:
-	@set -e; for i in $(SHLIBDIRS); do \
-		if [ -n "$(SHARED_LIBS_LINK_EXTS)" ]; then \
-			tmp="$(SHARED_LIBS_LINK_EXTS)"; \
-			for j in $${tmp:-x}; do \
-				( set -x; rm -f lib$$i$$j ); \
-			done; \
-		fi; \
-		( set -x; rm -f lib$$i$(SHLIB_EXT) ); \
-		if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
-			( set -x; rm -f cyg$$i$(SHLIB_EXT) lib$$i$(SHLIB_EXT).a ); \
-		fi; \
-	done
-
-link-shared:
-	@ set -e; for i in $(SHLIBDIRS); do \
-		$(MAKE) -f $(HERE)/Makefile.shared -e $(BUILDENV) \
-			LIBNAME=$$i LIBVERSION=$(SHLIB_MAJOR).$(SHLIB_MINOR) \
-			LIBCOMPATVERSIONS=";$(SHLIB_VERSION_HISTORY)" \
-			symlink.$(SHLIB_TARGET); \
-		libs="$$libs -l$$i"; \
-	done
-
-build-shared: do_$(SHLIB_TARGET) link-shared
-
-do_$(SHLIB_TARGET):
-	@ set -e; libs='-L. $(SHLIBDEPS)'; for i in $(SHLIBDIRS); do \
-		if [ "$$i" = "ssl" -a -n "$(LIBKRB5)" ]; then \
-			libs="$(LIBKRB5) $$libs"; \
-		fi; \
-		$(CLEARENV) && $(MAKE) -f Makefile.shared -e $(BUILDENV) \
-			LIBNAME=$$i LIBVERSION=$(SHLIB_MAJOR).$(SHLIB_MINOR) \
-			LIBCOMPATVERSIONS=";$(SHLIB_VERSION_HISTORY)" \
-			LIBDEPS="$$libs $(EX_LIBS)" \
-			link_a.$(SHLIB_TARGET); \
-		libs="-l$$i $$libs"; \
-	done
-
-libcrypto.pc: Makefile
-	@ ( echo 'prefix=$(INSTALLTOP)'; \
-	    echo 'exec_prefix=$${prefix}'; \
-	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
-	    echo 'includedir=$${prefix}/include'; \
-	    echo ''; \
-	    echo 'Name: OpenSSL-libcrypto'; \
-	    echo 'Description: OpenSSL cryptography library'; \
-	    echo 'Version: '$(VERSION); \
-	    echo 'Requires: '; \
-	    echo 'Libs: -L$${libdir} -lcrypto'; \
-	    echo 'Libs.private: $(EX_LIBS)'; \
-	    echo 'Cflags: -I$${includedir} $(KRB5_INCLUDES)' ) > libcrypto.pc
-
-libssl.pc: Makefile
-	@ ( echo 'prefix=$(INSTALLTOP)'; \
-	    echo 'exec_prefix=$${prefix}'; \
-	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
-	    echo 'includedir=$${prefix}/include'; \
-	    echo ''; \
-	    echo 'Name: OpenSSL-libssl'; \
-	    echo 'Description: Secure Sockets Layer and cryptography libraries'; \
-	    echo 'Version: '$(VERSION); \
-	    echo 'Requires.private: libcrypto'; \
-	    echo 'Libs: -L$${libdir} -lssl'; \
-	    echo 'Libs.private: $(EX_LIBS)'; \
-	    echo 'Cflags: -I$${includedir} $(KRB5_INCLUDES)' ) > libssl.pc
-
-openssl.pc: Makefile
-	@ ( echo 'prefix=$(INSTALLTOP)'; \
-	    echo 'exec_prefix=$${prefix}'; \
-	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
-	    echo 'includedir=$${prefix}/include'; \
-	    echo ''; \
-	    echo 'Name: OpenSSL'; \
-	    echo 'Description: Secure Sockets Layer and cryptography libraries and tools'; \
-	    echo 'Version: '$(VERSION); \
-	    echo 'Requires: libssl libcrypto' ) > openssl.pc
-
-Makefile: Makefile.org Configure config
-	@echo "Makefile is older than Makefile.org, Configure or config."
-	@echo "Reconfigure the source tree (via './config' or 'perl Configure'), please."
-	@false
-
-libclean:
-	rm -f *.map *.so *.so.* *.dylib *.dll engines/*.so engines/*.dll engines/*.dylib *.a engines/*.a */lib */*/lib
-
-clean:	libclean
-	rm -f shlib/*.o *.o core a.out fluff rehash.time testlog make.log cctest cctest.c
-	@set -e; target=clean; $(RECURSIVE_BUILD_CMD)
-	rm -f $(LIBS)
-	rm -f openssl.pc libssl.pc libcrypto.pc
-	rm -f speed.* .pure
-	rm -f $(TARFILE)
-	@set -e; for i in $(ONEDIRS) ;\
-	do \
-	rm -fr $$i/*; \
-	done
-
-makefile.one: files
-	$(PERL) util/mk1mf.pl >makefile.one; \
-	sh util/do_ms.sh
-
-files:
-	$(PERL) $(TOP)/util/files.pl Makefile > $(TOP)/MINFO
-	@set -e; target=files; $(RECURSIVE_BUILD_CMD)
-
-links:
-	@$(PERL) $(TOP)/util/mkdir-p.pl include/openssl
-	@$(PERL) $(TOP)/util/mklink.pl include/openssl $(EXHEADER)
-	@set -e; target=links; $(RECURSIVE_BUILD_CMD)
-
-gentests:
-	@(cd test && echo "generating dummy tests (if needed)..." && \
-	$(CLEARENV) && $(MAKE) -e $(BUILDENV) TESTS='$(TESTS)' OPENSSL_DEBUG_MEMORY=on generate );
-
-dclean:
-	rm -rf *.bak include/openssl certs/.0
-	@set -e; target=dclean; $(RECURSIVE_BUILD_CMD)
-
-rehash: rehash.time
-rehash.time: certs apps
-	@if [ -z "$(CROSS_COMPILE)" ]; then \
-		(OPENSSL="`pwd`/util/opensslwrap.sh"; \
-		[ -x "apps/openssl.exe" ] && OPENSSL="apps/openssl.exe" || :; \
-		OPENSSL_DEBUG_MEMORY=on; \
-		export OPENSSL OPENSSL_DEBUG_MEMORY; \
-		$(PERL) tools/c_rehash certs/demo) && \
-		touch rehash.time; \
-	else :; fi
-
-test:   tests
-
-tests: rehash
-	@(cd test && echo "testing..." && \
-	$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. TESTS='$(TESTS)' OPENSSL_DEBUG_MEMORY=on OPENSSL_CONF=../apps/openssl.cnf tests );
-	OPENSSL_CONF=apps/openssl.cnf util/opensslwrap.sh version -a
-
-report:
-	@$(PERL) util/selftest.pl
-
-update: errors stacks util/libeay.num util/ssleay.num TABLE
-	@set -e; target=update; $(RECURSIVE_BUILD_CMD)
-
-depend:
-	@set -e; target=depend; $(RECURSIVE_BUILD_CMD)
-
-lint:
-	@set -e; target=lint; $(RECURSIVE_BUILD_CMD)
-
-tags:
-	rm -f TAGS
-	find . -name '[^.]*.[ch]' | xargs etags -a
-
-errors:
-	$(PERL) util/ck_errf.pl -strict */*.c */*/*.c
-	$(PERL) util/mkerr.pl -recurse -write
-	(cd engines; $(MAKE) PERL=$(PERL) errors)
-
-stacks:
-	$(PERL) util/mkstack.pl -write
-
-util/libeay.num::
-	$(PERL) util/mkdef.pl crypto update
-
-util/ssleay.num::
-	$(PERL) util/mkdef.pl ssl update
-
-TABLE: Configure
-	(echo 'Output of `Configure TABLE'"':"; \
-	$(PERL) Configure TABLE) > TABLE
-
-# Build distribution tar-file. As the list of files returned by "find" is
-# pretty long, on several platforms a "too many arguments" error or similar
-# would occur. Therefore the list of files is temporarily stored into a file
-# and read directly, requiring GNU-Tar. Call "make TAR=gtar dist" if the normal
-# tar does not support the --files-from option.
-TAR_COMMAND=$(TAR) $(TARFLAGS) --files-from $(TARFILE).list \
-	                       --owner 0 --group 0 \
-			       --transform 's|^|$(NAME)/|' \
-			       -cvf -
-
-$(TARFILE).list:
-	find * \! -name STATUS \! -name TABLE \! -name '*.o' \! -name '*.a' \
-	       \! -name '*.so' \! -name '*.so.*'  \! -name 'openssl' \
-	       \( \! -name '*test' -o -name bctest -o -name pod2mantest \) \
-	       \! -name '.#*' \! -name '*~' \! -type l \
-	    | sort > $(TARFILE).list
-
-tar: $(TARFILE).list
-	find . -type d -print | xargs chmod 755
-	find . -type f -print | xargs chmod a+r
-	find . -type f -perm -0100 -print | xargs chmod a+x
-	$(TAR_COMMAND) | gzip --best > $(TARFILE).gz
-	rm -f $(TARFILE).list
-	ls -l $(TARFILE).gz
-
-tar-snap: $(TARFILE).list
-	$(TAR_COMMAND) > $(TARFILE)
-	rm -f $(TARFILE).list
-	ls -l $(TARFILE)
-
-dist:   
-	$(PERL) Configure dist
-	@$(MAKE) SDIRS='$(SDIRS)' clean
-	@$(MAKE) TAR='$(TAR)' TARFLAGS='$(TARFLAGS)' $(DISTTARVARS) tar
-
-install: all install_docs install_sw
-
-install_sw:
-	@$(PERL) $(TOP)/util/mkdir-p.pl $(INSTALL_PREFIX)$(INSTALLTOP)/bin \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR) \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl \
-		$(INSTALL_PREFIX)$(OPENSSLDIR)/misc \
-		$(INSTALL_PREFIX)$(OPENSSLDIR)/certs \
-		$(INSTALL_PREFIX)$(OPENSSLDIR)/private
-	@set -e; headerlist="$(EXHEADER)"; for i in $$headerlist;\
-	do \
-	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
-	done;
-	@set -e; target=install; $(RECURSIVE_BUILD_CMD)
-	@set -e; liblist="$(LIBS)"; for i in $$liblist ;\
-	do \
-		if [ -f "$$i" ]; then \
-		(       echo installing $$i; \
-			cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-			$(RANLIB) $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-			chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-			mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i ); \
-		fi; \
-	done;
-	@set -e; if [ -n "$(SHARED_LIBS)" ]; then \
-		tmp="$(SHARED_LIBS)"; \
-		for i in $${tmp:-x}; \
-		do \
-			if [ -f "$$i" -o -f "$$i.a" ]; then \
-			(       echo installing $$i; \
-				if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
-					c=`echo $$i | sed 's/^lib\(.*\)\.dll\.a/cyg\1-$(SHLIB_VERSION_NUMBER).dll/'`; \
-					cp $$c $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new; \
-					chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new; \
-					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c; \
-					cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i; \
-				else \
-					cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
-					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i; \
-				fi ); \
-				if expr $(PLATFORM) : 'mingw' > /dev/null; then \
-				(	case $$i in \
-						*crypto*) i=libeay32.dll;; \
-						*ssl*)    i=ssleay32.dll;; \
-					esac; \
-					echo installing $$i; \
-	 				cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
-	 				chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
-	 				mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i ); \
-				fi; \
-			fi; \
-		done; \
-		(	here="`pwd`"; \
-			cd $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR); \
-			$(MAKE) -f $$here/Makefile HERE="$$here" link-shared ); \
-		if [ "$(INSTALLTOP)" != "/usr" ]; then \
-			echo 'OpenSSL shared libraries have been installed in:'; \
-			echo '  $(INSTALLTOP)'; \
-			echo ''; \
-			sed -e '1,/^$$/d' doc/openssl-shared.txt; \
-		fi; \
-	fi
-	cp libcrypto.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libcrypto.pc
-	cp libssl.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libssl.pc
-	cp openssl.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
-	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/openssl.pc
-
-install_html_docs:
-	here="`pwd`"; \
-	filecase=; \
-	case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
-		filecase=-i; \
-	esac; \
-	for subdir in apps crypto ssl; do \
-		mkdir -p $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir; \
-		for i in doc/$$subdir/*.pod; do \
-			fn=`basename $$i .pod`; \
-			echo "installing html/$$fn.$(HTMLSUFFIX)"; \
-			cat $$i \
-			| sed -r 's/L<([^)]*)(\([0-9]\))?\|([^)]*)(\([0-9]\))?>/L<\1|\3>/g' \
-			| pod2html --podroot=doc --htmlroot=.. --podpath=apps:crypto:ssl \
-			| sed -r 's/<!DOCTYPE.*//g' \
-			> $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir/$$fn.$(HTMLSUFFIX); \
-			$(PERL) util/extract-names.pl < $$i | \
-				grep -v $$filecase "^$$fn\$$" | \
-				(cd $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir; \
-				 while read n; do \
-					PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$(HTMLSUFFIX) "$$n".$(HTMLSUFFIX); \
-				 done); \
-		done; \
-	done
-
-install_docs:
-	@$(PERL) $(TOP)/util/mkdir-p.pl \
-		$(INSTALL_PREFIX)$(MANDIR)/man1 \
-		$(INSTALL_PREFIX)$(MANDIR)/man3 \
-		$(INSTALL_PREFIX)$(MANDIR)/man5 \
-		$(INSTALL_PREFIX)$(MANDIR)/man7
-	@pod2man="`cd ./util; ./pod2mantest $(PERL)`"; \
-	here="`pwd`"; \
-	filecase=; \
-	case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
-		filecase=-i; \
-	esac; \
-	set -e; for i in doc/apps/*.pod; do \
-		fn=`basename $$i .pod`; \
-		sec=`$(PERL) util/extract-section.pl 1 < $$i`; \
-		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
-		(cd `$(PERL) util/dirname.pl $$i`; \
-		sh -c "$$pod2man \
-			--section=$$sec --center=OpenSSL \
-			--release=$(VERSION) `basename $$i`") \
-			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
-		$(PERL) util/extract-names.pl < $$i | \
-			(grep -v $$filecase "^$$fn\$$"; true) | \
-			(grep -v "[	]"; true) | \
-			(cd $(INSTALL_PREFIX)$(MANDIR)/man$$sec/; \
-			 while read n; do \
-				PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$${sec}$(MANSUFFIX) "$$n".$${sec}$(MANSUFFIX); \
-			 done); \
-	done; \
-	set -e; for i in doc/crypto/*.pod doc/ssl/*.pod; do \
-		fn=`basename $$i .pod`; \
-		sec=`$(PERL) util/extract-section.pl 3 < $$i`; \
-		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
-		(cd `$(PERL) util/dirname.pl $$i`; \
-		sh -c "$$pod2man \
-			--section=$$sec --center=OpenSSL \
-			--release=$(VERSION) `basename $$i`") \
-			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
-		$(PERL) util/extract-names.pl < $$i | \
-			(grep -v $$filecase "^$$fn\$$"; true) | \
-			(grep -v "[	]"; true) | \
-			(cd $(INSTALL_PREFIX)$(MANDIR)/man$$sec/; \
-			 while read n; do \
-				PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$${sec}$(MANSUFFIX) "$$n".$${sec}$(MANSUFFIX); \
-			 done); \
-	done
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur original/openssl-1.0.2g/Makefile.org sidh/openssl-1.0.2g/Makefile.org
--- original/openssl-1.0.2g/Makefile.org	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/Makefile.org	2016-07-20 08:28:03.355200610 -0700
@@ -145,7 +145,7 @@
 	objects \
 	md2 md4 md5 sha mdc2 hmac ripemd whrlpool \
 	des aes rc2 rc4 rc5 idea bf cast camellia seed modes \
-	bn ec rsa dsa ecdsa dh ecdh dso engine \
+	bn ec rsa dsa ecdsa dh ecdh sidh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
 	cms pqueue ts jpake srp store cmac
diff -Naur original/openssl-1.0.2g/README.SIDH sidh/openssl-1.0.2g/README.SIDH
--- original/openssl-1.0.2g/README.SIDH	1969-12-31 16:00:00.000000000 -0800
+++ sidh/openssl-1.0.2g/README.SIDH	2016-07-20 08:28:03.299200611 -0700
@@ -0,0 +1,46 @@
+Supersingular Isogeny-based Diffie-Hellman (SIDH) key exchange
+--------------------------------------------------------------
+
+This version of OpenSSL has been modified to support the Supersingular Isogeny-based 
+Diffie-Hellman (SIDH) key exchange [1], using the implementation of Microsoft Research [2].
+This scheme provides approximately 128 bits of quantum security and 192 bits of classical 
+security.
+
+ABOUT THE INTEGRATION
+---------------------
+
+The library specifies four ciphersuites
+* SIDH-ECDSA-AES128-GCM-SHA256
+* SIDH-RSA-AES128-GCM-SHA256
+* SIDH-ECDHE-ECDSA-AES128-GCM-SHA256
+* SIDH-ECDHE-RSA-AES128-GCM-SHA256
+
+The first two consist of a SIDH key exchange, as described in [1], authentication based on 
+ECDSA or RSA digital signatures, authenticated encryption (with associated data) (AEAD) 
+based on AES-128 in GCM (Galois Counter Mode); and key derivation and hashing based on 
+SHA-256. The last two offer hybrid ciphersuites that are as above, except the key exchange 
+includes both SIDH and ECDH key exchange; the pre-master secret is the concatenation of the 
+ECDH shared secret and the SIDH shared secret. All these ciphersuites require TLSv1.2 because 
+of the use of AES-GCM.
+
+BUILDING THE LIBRARY
+--------------------
+
+The library is built normally, as explained in INSTALL. The SIDH code can be compiled out 
+using the OPENSSL_NO_SIDH flag.
+
+The SIDH code can make use of the assembly implementation, by declaring the SIDH_ASM flag:
+
+./config -DSIDH_ASM
+
+USING THE SIDH CIPHERSUITES
+---------------------------
+
+To use the SIDH ciphersuites, simply specify the suite identifier as you normally would.
+
+REFERENCES
+----------
+
+[1] Craig Costello, Patrick Longa, and Michael Naehrig (Microsoft Research). "Efficient algorithms for
+supersingular isogeny Diffe-Hellman." https://eprint.iacr.org/2016/413.pdf.
+[2] http://research.microsoft.com/en-us/projects/sidh/
diff -Naur original/openssl-1.0.2g/ssl/Makefile sidh/openssl-1.0.2g/ssl/Makefile
--- original/openssl-1.0.2g/ssl/Makefile	2016-03-01 05:36:51.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/Makefile	2016-07-20 08:28:03.303200611 -0700
@@ -107,38 +107,40 @@
 # DO NOT DELETE THIS LINE -- make depend depends on it.
 
 bio_ssl.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-bio_ssl.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-bio_ssl.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-bio_ssl.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-bio_ssl.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-bio_ssl.o: ../include/openssl/err.h ../include/openssl/evp.h
-bio_ssl.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-bio_ssl.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-bio_ssl.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-bio_ssl.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-bio_ssl.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-bio_ssl.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-bio_ssl.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+bio_ssl.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+bio_ssl.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+bio_ssl.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+bio_ssl.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+bio_ssl.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+bio_ssl.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+bio_ssl.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+bio_ssl.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+bio_ssl.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+bio_ssl.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+bio_ssl.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+bio_ssl.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+bio_ssl.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 bio_ssl.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 bio_ssl.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 bio_ssl.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 bio_ssl.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 bio_ssl.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h bio_ssl.c
 d1_both.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_both.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_both.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_both.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_both.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_both.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_both.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_both.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_both.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_both.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_both.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_both.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_both.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-d1_both.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-d1_both.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+d1_both.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_both.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_both.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_both.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_both.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_both.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_both.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_both.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_both.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_both.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_both.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_both.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_both.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+d1_both.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_both.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 d1_both.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 d1_both.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 d1_both.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -160,26 +162,27 @@
 d1_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 d1_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 d1_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-d1_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-d1_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-d1_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-d1_clnt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-d1_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_clnt.c
-d1_clnt.o: kssl_lcl.h ssl_locl.h
+d1_clnt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+d1_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+d1_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+d1_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+d1_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+d1_clnt.o: ../include/openssl/x509_vfy.h d1_clnt.c kssl_lcl.h ssl_locl.h
 d1_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-d1_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+d1_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 d1_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 d1_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 d1_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -187,19 +190,20 @@
 d1_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_lib.c
 d1_lib.o: ssl_locl.h
 d1_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-d1_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+d1_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 d1_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 d1_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 d1_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -207,39 +211,41 @@
 d1_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_meth.c
 d1_meth.o: ssl_locl.h
 d1_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-d1_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-d1_pkt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+d1_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_pkt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+d1_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_pkt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 d1_pkt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 d1_pkt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 d1_pkt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 d1_pkt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 d1_pkt.o: ../include/openssl/x509_vfy.h d1_pkt.c ssl_locl.h
 d1_srtp.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-d1_srtp.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-d1_srtp.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-d1_srtp.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-d1_srtp.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-d1_srtp.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-d1_srtp.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-d1_srtp.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-d1_srtp.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-d1_srtp.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-d1_srtp.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-d1_srtp.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-d1_srtp.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-d1_srtp.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+d1_srtp.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+d1_srtp.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+d1_srtp.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+d1_srtp.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+d1_srtp.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+d1_srtp.o: ../include/openssl/err.h ../include/openssl/evp.h
+d1_srtp.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+d1_srtp.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+d1_srtp.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+d1_srtp.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+d1_srtp.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+d1_srtp.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+d1_srtp.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+d1_srtp.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 d1_srtp.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 d1_srtp.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 d1_srtp.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -262,17 +268,18 @@
 d1_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 d1_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 d1_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-d1_srvr.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-d1_srvr.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-d1_srvr.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-d1_srvr.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-d1_srvr.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h d1_srvr.c
-d1_srvr.o: ssl_locl.h
+d1_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+d1_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+d1_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+d1_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+d1_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+d1_srvr.o: ../include/openssl/x509_vfy.h d1_srvr.c ssl_locl.h
 kssl.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-kssl.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-kssl.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-kssl.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-kssl.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+kssl.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+kssl.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+kssl.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+kssl.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+kssl.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
 kssl.o: ../include/openssl/evp.h ../include/openssl/hmac.h
 kssl.o: ../include/openssl/krb5_asn.h ../include/openssl/kssl.h
 kssl.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
@@ -281,46 +288,48 @@
 kssl.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 kssl.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 kssl.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-kssl.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-kssl.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-kssl.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-kssl.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-kssl.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl.c
-kssl.o: kssl_lcl.h
+kssl.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+kssl.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+kssl.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+kssl.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+kssl.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+kssl.o: ../include/openssl/x509_vfy.h kssl.c kssl_lcl.h
 s23_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_clnt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_clnt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s23_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s23_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s23_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_clnt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_clnt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s23_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_clnt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s23_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s23_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s23_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s23_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s23_clnt.o: ../include/openssl/x509_vfy.h s23_clnt.c ssl_locl.h
 s23_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s23_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s23_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s23_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s23_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s23_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -328,19 +337,20 @@
 s23_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s23_lib.c
 s23_lib.o: ssl_locl.h
 s23_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s23_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s23_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s23_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s23_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s23_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -348,19 +358,20 @@
 s23_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s23_meth.c
 s23_meth.o: ssl_locl.h
 s23_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s23_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s23_pkt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s23_pkt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s23_pkt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s23_pkt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -368,39 +379,41 @@
 s23_pkt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s23_pkt.c
 s23_pkt.o: ssl_locl.h
 s23_srvr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s23_srvr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s23_srvr.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s23_srvr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s23_srvr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s23_srvr.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s23_srvr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s23_srvr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s23_srvr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s23_srvr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s23_srvr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s23_srvr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s23_srvr.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s23_srvr.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s23_srvr.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s23_srvr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s23_srvr.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s23_srvr.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s23_srvr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s23_srvr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s23_srvr.o: ../include/openssl/err.h ../include/openssl/evp.h
+s23_srvr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s23_srvr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s23_srvr.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s23_srvr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s23_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s23_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s23_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s23_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s23_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s23_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s23_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s23_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s23_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s23_srvr.o: ../include/openssl/x509_vfy.h s23_srvr.c ssl_locl.h
 s2_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_clnt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_clnt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_clnt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_clnt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_clnt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -408,19 +421,20 @@
 s2_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_clnt.c
 s2_clnt.o: ssl_locl.h
 s2_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_enc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_enc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_enc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_enc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_enc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_enc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_enc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_enc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_enc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_enc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_enc.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_enc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_enc.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_enc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_enc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_enc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_enc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_enc.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_enc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_enc.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_enc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_enc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_enc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_enc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_enc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_enc.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_enc.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_enc.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_enc.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -428,19 +442,20 @@
 s2_enc.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_enc.c
 s2_enc.o: ssl_locl.h
 s2_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -448,19 +463,20 @@
 s2_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_lib.c
 s2_lib.o: ssl_locl.h
 s2_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -468,19 +484,20 @@
 s2_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_meth.c
 s2_meth.o: ssl_locl.h
 s2_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_pkt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_pkt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_pkt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_pkt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -488,19 +505,20 @@
 s2_pkt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_pkt.c
 s2_pkt.o: ssl_locl.h
 s2_srvr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s2_srvr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s2_srvr.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s2_srvr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s2_srvr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s2_srvr.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s2_srvr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s2_srvr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s2_srvr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s2_srvr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s2_srvr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s2_srvr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s2_srvr.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s2_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s2_srvr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s2_srvr.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s2_srvr.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s2_srvr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s2_srvr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s2_srvr.o: ../include/openssl/err.h ../include/openssl/evp.h
+s2_srvr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s2_srvr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s2_srvr.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s2_srvr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s2_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s2_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s2_srvr.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s2_srvr.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s2_srvr.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s2_srvr.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s2_srvr.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -508,40 +526,42 @@
 s2_srvr.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s2_srvr.c
 s2_srvr.o: ssl_locl.h
 s3_both.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_both.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_both.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_both.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_both.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_both.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_both.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_both.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_both.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_both.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_both.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_both.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_both.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s3_both.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_both.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_both.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_both.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_both.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_both.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_both.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_both.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_both.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_both.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s3_both.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_both.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_both.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_both.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_both.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s3_both.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_both.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s3_both.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s3_both.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s3_both.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s3_both.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s3_both.o: ../include/openssl/x509_vfy.h s3_both.c ssl_locl.h
 s3_cbc.o: ../crypto/constant_time_locl.h ../e_os.h ../include/openssl/asn1.h
-s3_cbc.o: ../include/openssl/bio.h ../include/openssl/buffer.h
-s3_cbc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
-s3_cbc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-s3_cbc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-s3_cbc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-s3_cbc.o: ../include/openssl/err.h ../include/openssl/evp.h
-s3_cbc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-s3_cbc.o: ../include/openssl/lhash.h ../include/openssl/md5.h
-s3_cbc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_cbc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_cbc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_cbc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_cbc.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s3_cbc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_cbc.o: ../include/openssl/bio.h ../include/openssl/bn.h
+s3_cbc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+s3_cbc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
+s3_cbc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+s3_cbc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+s3_cbc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+s3_cbc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s3_cbc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s3_cbc.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
+s3_cbc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_cbc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_cbc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_cbc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_cbc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_cbc.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s3_cbc.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s3_cbc.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s3_cbc.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -564,47 +584,50 @@
 s3_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 s3_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
 s3_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
-s3_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-s3_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-s3_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-s3_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-s3_clnt.o: ../include/openssl/x509_vfy.h kssl_lcl.h s3_clnt.c ssl_locl.h
+s3_clnt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+s3_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+s3_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+s3_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+s3_clnt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+s3_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
+s3_clnt.o: s3_clnt.c ssl_locl.h
 s3_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_enc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_enc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_enc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_enc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_enc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_enc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_enc.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
-s3_enc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-s3_enc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-s3_enc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-s3_enc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-s3_enc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_enc.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_enc.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_enc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_enc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_enc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_enc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_enc.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_enc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_enc.o: ../include/openssl/lhash.h ../include/openssl/md5.h
+s3_enc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+s3_enc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+s3_enc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+s3_enc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+s3_enc.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
+s3_enc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_enc.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s3_enc.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s3_enc.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s3_enc.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 s3_enc.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 s3_enc.o: ../include/openssl/x509_vfy.h s3_enc.c ssl_locl.h
 s3_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_lib.o: ../include/openssl/crypto.h ../include/openssl/dh.h
-s3_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-s3_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-s3_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-s3_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
-s3_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-s3_lib.o: ../include/openssl/lhash.h ../include/openssl/md5.h
-s3_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_lib.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s3_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_lib.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_lib.o: ../include/openssl/dh.h ../include/openssl/dsa.h
+s3_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+s3_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+s3_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+s3_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s3_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+s3_lib.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
+s3_lib.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_lib.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s3_lib.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s3_lib.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s3_lib.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -612,19 +635,20 @@
 s3_lib.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
 s3_lib.o: s3_lib.c ssl_locl.h
 s3_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-s3_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s3_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 s3_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 s3_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 s3_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -632,20 +656,21 @@
 s3_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s3_meth.c
 s3_meth.o: ssl_locl.h
 s3_pkt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-s3_pkt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-s3_pkt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-s3_pkt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_pkt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_pkt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-s3_pkt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-s3_pkt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_pkt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-s3_pkt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-s3_pkt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-s3_pkt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-s3_pkt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-s3_pkt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-s3_pkt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_pkt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+s3_pkt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+s3_pkt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_pkt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_pkt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_pkt.o: ../include/openssl/err.h ../include/openssl/evp.h
+s3_pkt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+s3_pkt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+s3_pkt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+s3_pkt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+s3_pkt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+s3_pkt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+s3_pkt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+s3_pkt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+s3_pkt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 s3_pkt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 s3_pkt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 s3_pkt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -668,26 +693,27 @@
 s3_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 s3_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 s3_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-s3_srvr.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-s3_srvr.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-s3_srvr.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-s3_srvr.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-s3_srvr.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
-s3_srvr.o: s3_srvr.c ssl_locl.h
+s3_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+s3_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+s3_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+s3_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+s3_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+s3_srvr.o: ../include/openssl/x509_vfy.h kssl_lcl.h s3_srvr.c ssl_locl.h
 ssl_algs.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_algs.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_algs.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_algs.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_algs.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_algs.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_algs.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_algs.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_algs.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_algs.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_algs.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_algs.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_algs.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_algs.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_algs.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_algs.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_algs.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_algs.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_algs.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_algs.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_algs.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_algs.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_algs.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_algs.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_algs.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_algs.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_algs.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_algs.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_algs.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_algs.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_algs.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -695,20 +721,21 @@
 ssl_algs.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_algs.c
 ssl_algs.o: ssl_locl.h
 ssl_asn1.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/asn1_mac.h
-ssl_asn1.o: ../include/openssl/bio.h ../include/openssl/buffer.h
-ssl_asn1.o: ../include/openssl/comp.h ../include/openssl/crypto.h
-ssl_asn1.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-ssl_asn1.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssl_asn1.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssl_asn1.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_asn1.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_asn1.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_asn1.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_asn1.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_asn1.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_asn1.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_asn1.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssl_asn1.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_asn1.o: ../include/openssl/bio.h ../include/openssl/bn.h
+ssl_asn1.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+ssl_asn1.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
+ssl_asn1.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssl_asn1.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssl_asn1.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+ssl_asn1.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_asn1.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_asn1.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_asn1.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_asn1.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_asn1.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_asn1.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
+ssl_asn1.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_asn1.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssl_asn1.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssl_asn1.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssl_asn1.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -730,47 +757,50 @@
 ssl_cert.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 ssl_cert.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
 ssl_cert.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-ssl_cert.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-ssl_cert.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-ssl_cert.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-ssl_cert.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-ssl_cert.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-ssl_cert.o: ../include/openssl/x509v3.h ssl_cert.c ssl_locl.h
+ssl_cert.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+ssl_cert.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ssl_cert.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ssl_cert.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ssl_cert.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+ssl_cert.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h
+ssl_cert.o: ssl_cert.c ssl_locl.h
 ssl_ciph.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_ciph.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_ciph.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_ciph.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_ciph.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_ciph.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ssl_ciph.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_ciph.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_ciph.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_ciph.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_ciph.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_ciph.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_ciph.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_ciph.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssl_ciph.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_ciph.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_ciph.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_ciph.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_ciph.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_ciph.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_ciph.o: ../include/openssl/engine.h ../include/openssl/err.h
+ssl_ciph.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_ciph.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_ciph.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_ciph.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_ciph.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_ciph.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_ciph.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
+ssl_ciph.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_ciph.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssl_ciph.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssl_ciph.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssl_ciph.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 ssl_ciph.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 ssl_ciph.o: ../include/openssl/x509_vfy.h ssl_ciph.c ssl_locl.h
 ssl_conf.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_conf.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_conf.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-ssl_conf.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-ssl_conf.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_conf.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_conf.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_conf.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_conf.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_conf.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_conf.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_conf.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_conf.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_conf.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_conf.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_conf.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_conf.o: ../include/openssl/comp.h ../include/openssl/conf.h
+ssl_conf.o: ../include/openssl/crypto.h ../include/openssl/dh.h
+ssl_conf.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_conf.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_conf.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_conf.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_conf.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_conf.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_conf.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_conf.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_conf.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_conf.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_conf.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_conf.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_conf.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_conf.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_conf.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -778,58 +808,61 @@
 ssl_conf.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_conf.c
 ssl_conf.o: ssl_locl.h
 ssl_err.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_err.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_err.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-ssl_err.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssl_err.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssl_err.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_err.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_err.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_err.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_err.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_err.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_err.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_err.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_err.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_err.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_err.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssl_err.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssl_err.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+ssl_err.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_err.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_err.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_err.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_err.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_err.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_err.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+ssl_err.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_err.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_err.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_err.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 ssl_err.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_err.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_err.c
 ssl_err2.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_err2.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_err2.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-ssl_err2.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-ssl_err2.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-ssl_err2.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_err2.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_err2.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_err2.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_err2.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_err2.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_err2.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_err2.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_err2.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_err2.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_err2.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+ssl_err2.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+ssl_err2.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+ssl_err2.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_err2.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_err2.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_err2.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_err2.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_err2.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_err2.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+ssl_err2.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_err2.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_err2.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_err2.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 ssl_err2.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssl_err2.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_err2.c
 ssl_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_lib.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-ssl_lib.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-ssl_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_lib.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ssl_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_lib.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-ssl_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_lib.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-ssl_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssl_lib.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_lib.o: ../include/openssl/comp.h ../include/openssl/conf.h
+ssl_lib.o: ../include/openssl/crypto.h ../include/openssl/dh.h
+ssl_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_lib.o: ../include/openssl/engine.h ../include/openssl/err.h
+ssl_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_lib.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+ssl_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_lib.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+ssl_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_lib.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 ssl_lib.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 ssl_lib.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 ssl_lib.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -837,19 +870,20 @@
 ssl_lib.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h kssl_lcl.h
 ssl_lib.o: ssl_lib.c ssl_locl.h
 ssl_rsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_rsa.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_rsa.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_rsa.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_rsa.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_rsa.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_rsa.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_rsa.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_rsa.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_rsa.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_rsa.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_rsa.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_rsa.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_rsa.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_rsa.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_rsa.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_rsa.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_rsa.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_rsa.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_rsa.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_rsa.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_rsa.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_rsa.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_rsa.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_rsa.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_rsa.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_rsa.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_rsa.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_rsa.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_rsa.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_rsa.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -857,20 +891,21 @@
 ssl_rsa.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_rsa.o: ssl_rsa.c
 ssl_sess.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_sess.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_sess.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_sess.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_sess.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_sess.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-ssl_sess.o: ../include/openssl/err.h ../include/openssl/evp.h
-ssl_sess.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-ssl_sess.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-ssl_sess.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-ssl_sess.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-ssl_sess.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-ssl_sess.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-ssl_sess.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-ssl_sess.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_sess.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_sess.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_sess.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_sess.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_sess.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_sess.o: ../include/openssl/engine.h ../include/openssl/err.h
+ssl_sess.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssl_sess.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssl_sess.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssl_sess.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssl_sess.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssl_sess.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssl_sess.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
+ssl_sess.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_sess.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_sess.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_sess.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_sess.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -878,19 +913,20 @@
 ssl_sess.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_sess.o: ssl_sess.c
 ssl_stat.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_stat.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_stat.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_stat.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_stat.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_stat.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_stat.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_stat.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_stat.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_stat.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_stat.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_stat.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_stat.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_stat.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_stat.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_stat.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_stat.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_stat.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_stat.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_stat.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_stat.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_stat.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_stat.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_stat.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_stat.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_stat.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_stat.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_stat.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_stat.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_stat.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_stat.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -898,19 +934,20 @@
 ssl_stat.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_stat.o: ssl_stat.c
 ssl_txt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_txt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_txt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_txt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_txt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_txt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_txt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_txt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_txt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_txt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_txt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_txt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_txt.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_txt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_txt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_txt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_txt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_txt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_txt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_txt.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_txt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_txt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_txt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_txt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_txt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_txt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_txt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_txt.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_txt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_txt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_txt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -918,19 +955,20 @@
 ssl_txt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_txt.o: ssl_txt.c
 ssl_utst.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-ssl_utst.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_utst.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_utst.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_utst.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_utst.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_utst.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_utst.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_utst.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_utst.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_utst.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_utst.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_utst.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_utst.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+ssl_utst.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+ssl_utst.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+ssl_utst.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_utst.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_utst.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_utst.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_utst.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_utst.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_utst.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_utst.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_utst.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_utst.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_utst.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_utst.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 ssl_utst.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 ssl_utst.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 ssl_utst.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -938,40 +976,42 @@
 ssl_utst.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 ssl_utst.o: ssl_utst.c
 t1_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_clnt.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_clnt.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-t1_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-t1_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+t1_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_clnt.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_clnt.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+t1_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_clnt.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 t1_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 t1_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 t1_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 t1_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 t1_clnt.o: ../include/openssl/x509_vfy.h ssl_locl.h t1_clnt.c
 t1_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_enc.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_enc.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_enc.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_enc.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_enc.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_enc.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_enc.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
-t1_enc.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-t1_enc.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-t1_enc.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-t1_enc.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-t1_enc.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-t1_enc.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_enc.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_enc.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_enc.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_enc.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_enc.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_enc.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_enc.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_enc.o: ../include/openssl/lhash.h ../include/openssl/md5.h
+t1_enc.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+t1_enc.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+t1_enc.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+t1_enc.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+t1_enc.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
+t1_enc.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_enc.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_enc.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_enc.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_enc.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -979,19 +1019,20 @@
 t1_enc.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_enc.o: t1_enc.c
 t1_ext.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_ext.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_ext.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_ext.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_ext.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_ext.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_ext.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_ext.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_ext.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_ext.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_ext.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_ext.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_ext.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_ext.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_ext.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_ext.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_ext.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_ext.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_ext.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_ext.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_ext.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_ext.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_ext.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_ext.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_ext.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_ext.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_ext.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_ext.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_ext.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_ext.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_ext.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -999,21 +1040,22 @@
 t1_ext.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_ext.o: t1_ext.c
 t1_lib.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_lib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_lib.o: ../include/openssl/conf.h ../include/openssl/crypto.h
-t1_lib.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
-t1_lib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-t1_lib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-t1_lib.o: ../include/openssl/err.h ../include/openssl/evp.h
-t1_lib.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-t1_lib.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-t1_lib.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
-t1_lib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_lib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_lib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_lib.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-t1_lib.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-t1_lib.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+t1_lib.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_lib.o: ../include/openssl/comp.h ../include/openssl/conf.h
+t1_lib.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
+t1_lib.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+t1_lib.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+t1_lib.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+t1_lib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+t1_lib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+t1_lib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+t1_lib.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+t1_lib.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_lib.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_lib.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_lib.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+t1_lib.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_lib.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 t1_lib.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 t1_lib.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 t1_lib.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
@@ -1021,19 +1063,20 @@
 t1_lib.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h ssl_locl.h
 t1_lib.o: t1_lib.c
 t1_meth.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_meth.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_meth.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_meth.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_meth.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_meth.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_meth.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_meth.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_meth.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_meth.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_meth.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_meth.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_meth.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_meth.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_meth.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_meth.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_meth.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_meth.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_meth.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_meth.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_meth.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_meth.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_meth.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_meth.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_meth.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_meth.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_meth.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_meth.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_meth.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_meth.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_meth.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -1041,19 +1084,20 @@
 t1_meth.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_meth.o: t1_meth.c
 t1_reneg.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_reneg.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_reneg.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_reneg.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_reneg.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_reneg.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_reneg.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_reneg.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_reneg.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_reneg.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_reneg.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_reneg.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_reneg.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_reneg.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_reneg.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_reneg.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_reneg.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_reneg.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_reneg.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_reneg.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_reneg.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_reneg.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_reneg.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_reneg.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_reneg.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_reneg.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_reneg.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_reneg.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_reneg.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_reneg.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_reneg.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -1061,39 +1105,41 @@
 t1_reneg.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
 t1_reneg.o: t1_reneg.c
 t1_srvr.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_srvr.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_srvr.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_srvr.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_srvr.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_srvr.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_srvr.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_srvr.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_srvr.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_srvr.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_srvr.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_srvr.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_srvr.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
-t1_srvr.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-t1_srvr.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+t1_srvr.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_srvr.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_srvr.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_srvr.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_srvr.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_srvr.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_srvr.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_srvr.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_srvr.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_srvr.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_srvr.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_srvr.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_srvr.o: ../include/openssl/rand.h ../include/openssl/rsa.h
+t1_srvr.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_srvr.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
 t1_srvr.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
 t1_srvr.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
 t1_srvr.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 t1_srvr.o: ../include/openssl/tls1.h ../include/openssl/x509.h
 t1_srvr.o: ../include/openssl/x509_vfy.h ssl_locl.h t1_srvr.c
 t1_trce.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-t1_trce.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-t1_trce.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-t1_trce.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-t1_trce.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-t1_trce.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-t1_trce.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-t1_trce.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-t1_trce.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-t1_trce.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-t1_trce.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-t1_trce.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-t1_trce.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-t1_trce.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+t1_trce.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+t1_trce.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+t1_trce.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+t1_trce.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+t1_trce.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+t1_trce.o: ../include/openssl/err.h ../include/openssl/evp.h
+t1_trce.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+t1_trce.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+t1_trce.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+t1_trce.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+t1_trce.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+t1_trce.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+t1_trce.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+t1_trce.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 t1_trce.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 t1_trce.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 t1_trce.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
@@ -1115,9 +1161,10 @@
 tls_srp.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 tls_srp.o: ../include/openssl/rand.h ../include/openssl/rsa.h
 tls_srp.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-tls_srp.o: ../include/openssl/srp.h ../include/openssl/srtp.h
-tls_srp.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-tls_srp.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-tls_srp.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-tls_srp.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-tls_srp.o: ../include/openssl/x509_vfy.h ssl_locl.h tls_srp.c
+tls_srp.o: ../include/openssl/sidh.h ../include/openssl/srp.h
+tls_srp.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+tls_srp.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+tls_srp.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+tls_srp.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+tls_srp.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
+tls_srp.o: tls_srp.c
diff -Naur original/openssl-1.0.2g/ssl/s3_clnt.c sidh/openssl-1.0.2g/ssl/s3_clnt.c
--- original/openssl-1.0.2g/ssl/s3_clnt.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/s3_clnt.c	2016-07-20 08:28:03.299200611 -0700
@@ -1385,6 +1385,10 @@
     int curve_nid = 0;
     int encoded_pt_len = 0;
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PUB *srvr_sidhpub = NULL;
+    int encoded_sidhpub_len = 0;
+#endif
 
     EVP_MD_CTX_init(&md_ctx);
 
@@ -1448,6 +1452,13 @@
             s->session->sess_cert->peer_ecdh_tmp = NULL;
         }
 #endif
+#ifndef OPENSSL_NO_SIDH
+	if (s->session->sess_cert->peer_sidhpub_tmp)
+	  {
+	    SIDH_PUB_free(s->session->sess_cert->peer_sidhpub_tmp);
+	    s->session->sess_cert->peer_sidhpub_tmp=NULL;
+	  }
+#endif
     } else {
         s->session->sess_cert = ssl_sess_cert_new();
     }
@@ -1788,8 +1799,46 @@
     }
 #endif                          /* !OPENSSL_NO_DH */
 
+#ifndef OPENSSL_NO_SIDH
+    else if ((alg_k & SSL_kSIDH) && !(alg_k & SSL_kEECDH))
+      {
+	/* Get the encoded SIDH public key  */
+	if ((srvr_sidhpub = SIDH_PUB_new()) == NULL)
+	  {
+	    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+	    goto err;
+	  }
+	
+	encoded_sidhpub_len = (p[0] << 8) | p[1];
+	p += 2;
+	n -= 2;
+	if ((encoded_sidhpub_len >= n) ||
+	    (o2i_SIDH_PUB(&srvr_sidhpub, p, encoded_sidhpub_len) == NULL))
+	  {
+	    al=SSL_AD_DECODE_ERROR;
+	    SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIDH_PUB);
+	    goto f_err;
+	  }
+
+	n-=encoded_sidhpub_len;
+	p+=encoded_sidhpub_len;
+	param_len = 2 + encoded_sidhpub_len;
+
+	if (0) ;
+#ifndef OPENSSL_NO_RSA
+	else if (alg_a & SSL_aRSA)
+	  pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+#endif
+#ifndef OPENSSL_NO_ECDSA
+	else if (alg_a & SSL_aECDSA)
+	  pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
+#endif
+	s->session->sess_cert->peer_sidhpub_tmp=srvr_sidhpub;
+		}
+#endif /* !OPENSSL_NO_SIDH */
+
 #ifndef OPENSSL_NO_ECDH
-    else if (alg_k & SSL_kEECDH) {
+    else if (alg_k & SSL_kEECDH || alg_k & SSL_kSIDHECDHEHYBRID) {
         EC_GROUP *ngroup;
         const EC_GROUP *group;
 
@@ -1874,6 +1923,31 @@
         n -= param_len;
         p += encoded_pt_len;
 
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	  /* Get the encoded SIDH public */
+	  if ((srvr_sidhpub = SIDH_PUB_new()) == NULL)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+	      goto err;
+	    }
+
+	  encoded_sidhpub_len = (p[0] << 8) | p[1];
+	  p += 2;
+	  n -= 2;
+	  if ((encoded_sidhpub_len >= n) ||
+	      (o2i_SIDH_PUB(&srvr_sidhpub, p, encoded_sidhpub_len) == NULL))
+	    {
+	      al=SSL_AD_DECODE_ERROR;
+	      SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIDH_PUB);
+	      goto f_err;
+	    }
+
+	  n-=encoded_sidhpub_len;
+	  p+=encoded_sidhpub_len;
+	  param_len += 2 + encoded_sidhpub_len;
+	  s->session->sess_cert->peer_sidhpub_tmp=srvr_sidhpub;
+	}
+
         /*
          * The ECC/TLS specification does not mention the use of DSA to sign
          * ECParameters in the server key exchange message. We do support RSA
@@ -2041,6 +2115,9 @@
     if (ecdh != NULL)
         EC_KEY_free(ecdh);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PUB_free(srvr_sidhpub);
+#endif
     EVP_MD_CTX_cleanup(&md_ctx);
     s->state = SSL_ST_ERR;
     return (-1);
@@ -2457,6 +2534,8 @@
 {
     unsigned char *p;
     int n;
+    unsigned char *pprime;
+    int nprime;
     unsigned long alg_k;
 #ifndef OPENSSL_NO_RSA
     unsigned char *q;
@@ -2473,7 +2552,13 @@
     int encoded_pt_len = 0;
     BN_CTX *bn_ctx = NULL;
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PAIR *clnt_sidh = NULL;
+    const SIDH_PUB *srvr_sidhpub = NULL;
+    unsigned char *encoded_sidhpub = NULL;
+    int encoded_sidhpub_len = 0;
+#endif
+ 
     if (s->state == SSL3_ST_CW_KEY_EXCH_A) {
         p = ssl_handshake_start(s);
 
@@ -2767,7 +2852,7 @@
 #endif
 
 #ifndef OPENSSL_NO_ECDH
-        else if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)) {
+		else if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) {
             const EC_GROUP *srvr_group = NULL;
             EC_KEY *tkey;
             int ecdh_clnt_cert = 0;
@@ -2785,7 +2870,7 @@
              * computation as part of client certificate? If so, set
              * ecdh_clnt_cert to 1.
              */
-            if ((alg_k & (SSL_kECDHr | SSL_kECDHe)) && (s->cert != NULL)) {
+			if ((alg_k & (SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) && (s->cert != NULL)) {
                 /*-
                  * XXX: For now, we do not support client
                  * authentication using ECDH certificates.
@@ -2888,6 +2973,58 @@
                 goto err;
             }
 
+	    if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	      srvr_sidhpub = s->session->sess_cert->peer_sidhpub_tmp;
+
+	      if (srvr_sidhpub == NULL)
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+			 ERR_R_INTERNAL_ERROR);
+		  goto err;
+		}
+
+	      if ((clnt_sidh=SIDH_PAIR_new()) == NULL) 
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+		  goto err;
+		}
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+
+	      /* Generate a new SIDH key pair */
+	      if (!(SIDH_PAIR_generate_key_client(clnt_sidh, s->s3->tmp.sidh_ctx)))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      /* use the 'pprime' buffer for the SIDH shared key, but
+	       * make sure to clear it out afterwards
+	       */
+
+	      if ((pprime = OPENSSL_malloc(SIDH_PUBKEY_LEN)) == NULL) {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+		goto err;					
+	      }
+
+	      nprime = SIDH_compute_key_client(pprime, SIDH_PUBKEY_LEN, srvr_sidhpub, clnt_sidh, NULL, s->s3->tmp.sidh_ctx);
+	      if (nprime <= 0)
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      // FIXME: double-check if p is big enough
+	      memcpy(p + n, pprime, nprime);
+	      n += nprime;
+	      OPENSSL_free(pprime);
+	    }
+
             /* generate master key from the result */
             s->session->master_key_length =
                 s->method->ssl3_enc->generate_master_secret(s,
@@ -2931,10 +3068,29 @@
                 p += 1;
                 /* copy the point */
                 memcpy((unsigned char *)p, encodedPoint, n);
+		p += n;
                 /* increment n to account for length field */
                 n += 1;
             }
 
+	    if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	      /* Encode the public key */
+	      encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(clnt_sidh), &encoded_sidhpub);
+	      
+	      p[0] = (encoded_sidhpub_len >> 8) & 0xFF;
+	      p[1] =  encoded_sidhpub_len       & 0xFF;
+	      p += 2;
+	      memcpy((unsigned char *)p, encoded_sidhpub, encoded_sidhpub_len);
+	      p += encoded_sidhpub_len;
+	      
+	      n += 2 + encoded_sidhpub_len;
+	      
+	      /* Free allocated memory */
+	      SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+	      OPENSSL_free(encoded_sidhpub);
+	      SIDH_PAIR_free(clnt_sidh);
+	    }
+
             /* Free allocated memory */
             BN_CTX_free(bn_ctx);
             if (encodedPoint != NULL)
@@ -2944,6 +3100,75 @@
             EVP_PKEY_free(srvr_pub_pkey);
         }
 #endif                          /* !OPENSSL_NO_ECDH */
+#ifndef OPENSSL_NO_SIDH
+	else if ((alg_k & SSL_kSIDH) && !(alg_k & SSL_kEECDH))
+	  {
+	    srvr_sidhpub = s->session->sess_cert->peer_sidhpub_tmp;
+	    if (srvr_sidhpub == NULL)
+	      {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+		       ERR_R_INTERNAL_ERROR);
+		goto err;
+	      }
+
+	    if ((clnt_sidh=SIDH_PAIR_new()) == NULL)
+	      {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+		goto err;
+	      }
+
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+
+	      /* Generate a new SIDH key pair */
+	      if (!(SIDH_PAIR_generate_key_client(clnt_sidh, s->s3->tmp.sidh_ctx)))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	    /* use the 'p' buffer for the SIDH shared key, but
+	     * make sure to clear it out afterwards
+	     */
+
+	    n = SIDH_compute_key_client(p, SIDH_PUBKEY_LEN, srvr_sidhpub, clnt_sidh, NULL, s->s3->tmp.sidh_ctx);
+	    if (n <= 0)
+	      {
+		SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		goto err;
+	      }
+
+	    /* generate master key from the result */
+	    s->session->master_key_length = s->method->ssl3_enc \
+	      -> generate_master_secret(s,
+					s->session->master_key,
+					p, n);
+
+	    memset(p, 0, n); /* clean up */
+
+	    /* Encode the public key */
+	    encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(clnt_sidh), &encoded_sidhpub);
+
+	    p[0] = (encoded_sidhpub_len >> 8) & 0xFF;
+	    p[1] =  encoded_sidhpub_len       & 0xFF;
+	    p += 2;
+	    memcpy((unsigned char *)p, encoded_sidhpub, encoded_sidhpub_len);
+	    p += encoded_sidhpub_len;
+
+	    n = 2 + encoded_sidhpub_len;
+
+	    /* Free allocated memory */
+	    SIDH_CTX_free(s->s3->tmp.sidh_ctx); 
+	    OPENSSL_free(encoded_sidhpub);
+	    SIDH_PAIR_free(clnt_sidh);
+	  }
+#endif /* !OPENSSL_NO_SIDH */
         else if (alg_k & SSL_kGOST) {
             /* GOST key exchange message creation */
             EVP_PKEY_CTX *pkey_ctx;
@@ -3214,6 +3439,11 @@
         EC_KEY_free(clnt_ecdh);
     EVP_PKEY_free(srvr_pub_pkey);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+    OPENSSL_free(encoded_sidhpub);
+    SIDH_PAIR_free(clnt_sidh);
+#endif
     s->state = SSL_ST_ERR;
     return (-1);
 }
diff -Naur original/openssl-1.0.2g/ssl/s3_lib.c sidh/openssl-1.0.2g/ssl/s3_lib.c
--- original/openssl-1.0.2g/ssl/s3_lib.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/s3_lib.c	2016-07-20 08:28:03.303200611 -0700
@@ -2888,6 +2888,72 @@
 
 #endif                          /* OPENSSL_NO_ECDH */
 
+#ifndef OPENSSL_NO_SIDH
+	/* Cipher E010 */
+	{
+	1,
+	TLS1_TXT_SIDH_RSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_RSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDH,
+	SSL_aRSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+
+	/* Cipher E011 */
+	{
+	1,
+	TLS1_TXT_SIDH_ECDSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_ECDSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDH,
+	SSL_aECDSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+
+	/* Cipher E012 */
+	{
+	1,
+	TLS1_TXT_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDHECDHEHYBRID,
+	SSL_aRSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+
+	/* Cipher E013 */
+	{
+	1,
+	TLS1_TXT_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+	TLS1_CK_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+	SSL_kSIDHECDHEHYBRID,
+	SSL_aECDSA,
+	SSL_AES128GCM,
+	SSL_AEAD,
+	SSL_TLSV1_2,
+	SSL_NOT_EXP|SSL_HIGH,
+	SSL_HANDSHAKE_MAC_SHA256|TLS1_PRF_SHA256,
+	128,
+	128,
+	},
+#endif
+
 #ifdef TEMP_GOST_TLS
 /* Cipher FF00 */
     {
@@ -4194,7 +4260,7 @@
          * if we are considering an ECC cipher suite that uses an ephemeral
          * EC key check it
          */
-        if (alg_k & SSL_kEECDH)
+		if (alg_k & SSL_kEECDH || alg_k & SSL_kSIDHECDHEHYBRID)
             ok = ok && tls1_check_ec_tmp_key(s, c->id);
 #  endif                        /* OPENSSL_NO_ECDH */
 # endif                         /* OPENSSL_NO_EC */
@@ -4303,7 +4369,7 @@
         p[ret++] = SSL3_CT_DSS_SIGN;
 #endif
 #ifndef OPENSSL_NO_ECDH
-    if ((alg_k & (SSL_kECDHr | SSL_kECDHe)) && (s->version >= TLS1_VERSION)) {
+	if ((alg_k & (SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) && (s->version >= TLS1_VERSION)) {
         if (nostrict || have_rsa_sign)
             p[ret++] = TLS_CT_RSA_FIXED_ECDH;
         if (nostrict || have_ecdsa_sign)
diff -Naur original/openssl-1.0.2g/ssl/s3_srvr.c sidh/openssl-1.0.2g/ssl/s3_srvr.c
--- original/openssl-1.0.2g/ssl/s3_srvr.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/s3_srvr.c	2016-07-20 08:28:03.303200611 -0700
@@ -478,6 +478,8 @@
 #endif
                 || (alg_k & SSL_kEDH)
                 || (alg_k & SSL_kEECDH)
+                || (alg_k & SSL_kSIDH)
+				|| (alg_k & SSL_kSIDHECDHEHYBRID)
                 || ((alg_k & SSL_kRSA)
                     && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
                         || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
@@ -1609,6 +1611,11 @@
     int curve_id = 0;
     BN_CTX *bn_ctx = NULL;
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PAIR *sidh=NULL;
+    unsigned char *encoded_sidhpub = NULL;
+    int encoded_sidhpub_len = 0;
+#endif
     EVP_PKEY *pkey;
     const EVP_MD *md = NULL;
     unsigned char *p, *d;
@@ -1697,7 +1704,7 @@
         } else
 #endif
 #ifndef OPENSSL_NO_ECDH
-        if (type & SSL_kEECDH) {
+        if (type & SSL_kEECDH || type & SSL_kSIDHECDHEHYBRID) {
             const EC_GROUP *group;
 
             ecdhp = cert->ecdh_tmp;
@@ -1823,8 +1830,92 @@
             r[1] = NULL;
             r[2] = NULL;
             r[3] = NULL;
+
+	    if (type & SSL_kSIDHECDHEHYBRID) {
+	      // generate the SIDH keypair
+	      sidh = SIDH_PAIR_new();
+	      if (sidh == NULL)	{
+		al = SSL_AD_HANDSHAKE_FAILURE;
+		SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		goto err;
+	      }
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  al = SSL_AD_HANDSHAKE_FAILURE;
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+	      if (!SIDH_PAIR_generate_key_server(sidh, s->s3->tmp.sidh_ctx))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      // save the SIDH keypair
+	      s->s3->tmp.sidh = sidh;
+
+	      encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(sidh), &encoded_sidhpub);
+
+	      if (encoded_sidhpub_len == 0) 
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      n += 2 + encoded_sidhpub_len;
+	    }
         } else
 #endif                          /* !OPENSSL_NO_ECDH */
+#ifndef OPENSSL_NO_SIDH
+	    if (type & SSL_kSIDH || type & SSL_kSIDHECDHEHYBRID)
+	    {
+	      // generate the SIDH keypair
+	      sidh = SIDH_PAIR_new();
+	      if (sidh == NULL) 		{
+		al = SSL_AD_HANDSHAKE_FAILURE;
+		SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		goto err;
+	      }
+	      if (s->s3->tmp.sidh_ctx == NULL) {
+		/* initialize SIDH context */
+		s->s3->tmp.sidh_ctx = SIDH_CTX_new();
+		if (s->s3->tmp.sidh_ctx == NULL) {
+		  al = SSL_AD_HANDSHAKE_FAILURE;
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+	      }
+	      if (!SIDH_PAIR_generate_key_server(sidh, s->s3->tmp.sidh_ctx))
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      // save the SIDH keypair
+	      s->s3->tmp.sidh = sidh;
+
+	      encoded_sidhpub_len = i2o_SIDH_PUB(SIDH_PAIR_get_publickey(sidh), &encoded_sidhpub);
+
+	      if (encoded_sidhpub_len == 0) 
+		{
+		  SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_SIDH_LIB);
+		  goto err;
+		}
+
+	      n = 2 + encoded_sidhpub_len;
+
+	      /* We'll generate the serverKeyExchange message
+	       * explicitly so we can set these to NULLs
+	       */
+	      r[0]=NULL;
+	      r[1]=NULL;
+	      r[2]=NULL;
+	      r[3]=NULL;
+	    }
+		else
+#endif /* !OPENSSL_NO_SIDH */
 #ifndef OPENSSL_NO_PSK
         if (type & SSL_kPSK) {
             /*
@@ -1896,7 +1987,7 @@
         }
 
 #ifndef OPENSSL_NO_ECDH
-        if (type & SSL_kEECDH) {
+		if (type & SSL_kEECDH || type & SSL_kSIDHECDHEHYBRID) {
             /*
              * XXX: For now, we only support named (not generic) curves. In
              * this situation, the serverKeyExchange message has: [1 byte
@@ -1918,7 +2009,19 @@
             p += encodedlen;
         }
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+	if (type & SSL_kSIDH || type & SSL_kSIDHECDHEHYBRID) 
+	  {
+	    p[0] = (encoded_sidhpub_len >> 8) & 0xFF;
+	    p[1] =  encoded_sidhpub_len       & 0xFF;
+	    p += 2;
+	    memcpy((unsigned char*)p, (unsigned char *)encoded_sidhpub, encoded_sidhpub_len);
+	    OPENSSL_free(encoded_sidhpub);
+	    encoded_sidhpub = NULL;
+	    p += encoded_sidhpub_len;
+	  }
+#endif
+ 
 #ifndef OPENSSL_NO_PSK
         if (type & SSL_kPSK) {
             /* copy PSK identity hint */
@@ -2024,6 +2127,9 @@
         OPENSSL_free(encodedPoint);
     BN_CTX_free(bn_ctx);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    if (encoded_sidhpub != NULL) OPENSSL_free(encoded_sidhpub);
+#endif
     EVP_MD_CTX_cleanup(&md_ctx);
     s->state = SSL_ST_ERR;
     return (-1);
@@ -2129,6 +2235,8 @@
     long n;
     unsigned long alg_k;
     unsigned char *p;
+    unsigned char *pprime;
+    long nprime;
 #ifndef OPENSSL_NO_RSA
     RSA *rsa = NULL;
     EVP_PKEY *pkey = NULL;
@@ -2147,11 +2255,18 @@
     EC_POINT *clnt_ecpoint = NULL;
     BN_CTX *bn_ctx = NULL;
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PAIR *srvr_sidh = NULL;
+    SIDH_PUB *clnt_sidh_pub = NULL;
+    unsigned int clnt_sidh_pub_len;
+#endif
+ 
     n = s->method->ssl_get_message(s,
                                    SSL3_ST_SR_KEY_EXCH_A,
                                    SSL3_ST_SR_KEY_EXCH_B,
-                                   SSL3_MT_CLIENT_KEY_EXCHANGE, 2048, &ok);
+                                   SSL3_MT_CLIENT_KEY_EXCHANGE, 
+				   2048, // FIXME: is that too much?
+				   &ok);
 
     if (!ok)
         return ((int)n);
@@ -2589,7 +2704,7 @@
 #endif                          /* OPENSSL_NO_KRB5 */
 
 #ifndef OPENSSL_NO_ECDH
-    if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)) {
+    if (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)) {
         int ret = 1;
         int field_size = 0;
         const EC_KEY *tkey;
@@ -2675,7 +2790,7 @@
             /* Get encoded point length */
             i = *p;
             p += 1;
-            if (n != 1 + i) {
+            if (n < 1 + i) {
                 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
                 goto err;
             }
@@ -2683,13 +2798,39 @@
                 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
                 goto err;
             }
-            /*
-             * p is pointing to somewhere in the buffer currently, so set it
-             * to the start
-             */
-            p = (unsigned char *)s->init_buf->data;
+	    p += i;
+	    n -= 1 + i;
         }
 
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	  srvr_sidh = s->s3->tmp.sidh;
+	  
+	  /* Parse client public key */
+	  if (n < 2)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  clnt_sidh_pub_len = (p[0] << 8) | p[1];
+	  p += 2;
+	  if (n < 2 + clnt_sidh_pub_len)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  if (o2i_SIDH_PUB(&clnt_sidh_pub, p, clnt_sidh_pub_len) == 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  p += clnt_sidh_pub_len;
+	}
+
+	/* p is pointing to somewhere in the buffer
+	 * currently, so set it to the start 
+	 */ 
+	p=(unsigned char *)s->init_buf->data;
+
         /* Compute the shared pre-master secret */
         field_size = EC_GROUP_get_degree(group);
         if (field_size <= 0) {
@@ -2709,6 +2850,30 @@
         BN_CTX_free(bn_ctx);
         EC_KEY_free(s->s3->tmp.ecdh);
         s->s3->tmp.ecdh = NULL;
+ 
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+	  /* Compute the shared pre-master secret */
+	  if ((pprime = OPENSSL_malloc(SIDH_PUBKEY_LEN)) == NULL) {
+	    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
+	    goto err;
+	  }
+	  nprime = SIDH_compute_key_server(pprime, SIDH_PUBKEY_LEN, clnt_sidh_pub, srvr_sidh, NULL, s->s3->tmp.sidh_ctx);
+	  if (nprime <= 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  SIDH_PUB_free(clnt_sidh_pub);
+	  SIDH_PAIR_free(s->s3->tmp.sidh);
+	  s->s3->tmp.sidh = NULL; 
+	  SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+	  s->s3->tmp.sidh_ctx = NULL;
+
+	  // FIXME: double-check if p is big enough
+	  memcpy(p + i, pprime, nprime);
+	  i += nprime;
+	  OPENSSL_free(pprime);
+	}
 
         /* Compute the master secret */
         s->session->master_key_length =
@@ -2721,6 +2886,61 @@
         return (ret);
     } else
 #endif
+#ifndef OPENSSL_NO_SIDH
+      if ((alg_k & SSL_kSIDH) && !(alg_k & SSL_kEECDH))
+	{
+	  int ret = 1;
+	  srvr_sidh = s->s3->tmp.sidh;
+
+	  /* Parse client public key */
+	  if (n < 2)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  clnt_sidh_pub_len = (p[0] << 8) | p[1];
+	  p += 2;
+	  if (n < 2 + clnt_sidh_pub_len)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  if (o2i_SIDH_PUB(&clnt_sidh_pub, p, clnt_sidh_pub_len) == 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+	  p += clnt_sidh_pub_len;
+
+	  /* p is pointing to somewhere in the buffer
+	   * currently, so set it to the start 
+	   */ 
+	  p = (unsigned char *)s->init_buf->data;
+
+	  /* Compute the shared pre-master secret */
+
+	  n = SIDH_compute_key_server(p, SIDH_PUBKEY_LEN, clnt_sidh_pub, srvr_sidh, NULL, s->s3->tmp.sidh_ctx);
+	  if (n <= 0)
+	    {
+	      SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_SIDH_LIB);
+	      goto err;
+	    }
+
+	  SIDH_PUB_free(clnt_sidh_pub);
+	  SIDH_PAIR_free(s->s3->tmp.sidh);
+	  s->s3->tmp.sidh = NULL; 
+	  SIDH_CTX_free(s->s3->tmp.sidh_ctx);
+	  s->s3->tmp.sidh_ctx = NULL;
+
+	  /* Compute the master secret */
+	  s->session->master_key_length = s->method->ssl3_enc-> \
+	    generate_master_secret(s, s->session->master_key, p, n);
+		
+	  OPENSSL_cleanse(p, n);
+	  return (ret);
+	}
+      else
+#endif
 #ifndef OPENSSL_NO_PSK
     if (alg_k & SSL_kPSK) {
         unsigned char *t = NULL;
@@ -2934,7 +3154,7 @@
     return (1);
  f_err:
     ssl3_send_alert(s, SSL3_AL_FATAL, al);
-#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP)
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH) || defined(OPENSSL_NO_SRP) || !defined(OPENSSL_NO_SIDH)
  err:
 #endif
 #ifndef OPENSSL_NO_ECDH
@@ -2944,6 +3164,9 @@
         EC_KEY_free(srvr_ecdh);
     BN_CTX_free(bn_ctx);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    SIDH_PUB_free(clnt_sidh_pub);
+#endif
     s->state = SSL_ST_ERR;
     return (-1);
 }
diff -Naur original/openssl-1.0.2g/ssl/ssl3.h sidh/openssl-1.0.2g/ssl/ssl3.h
--- original/openssl-1.0.2g/ssl/ssl3.h	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl3.h	2016-07-20 08:28:03.303200611 -0700
@@ -123,6 +123,9 @@
 # include <openssl/buffer.h>
 # include <openssl/evp.h>
 # include <openssl/ssl.h>
+#ifndef OPENSSL_NO_SIDH
+#include <openssl/sidh.h>
+#endif
 
 #ifdef  __cplusplus
 extern "C" {
@@ -568,6 +571,10 @@
 #  ifndef OPENSSL_NO_ECDH
         EC_KEY *ecdh;           /* holds short lived ECDH key */
 #  endif
+#ifndef OPENSSL_NO_SIDH
+      SIDH_PAIR *sidh; /* holds short lived SIDH key */
+      SIDH_CTX *sidh_ctx; /* holds SIDH context */
+#endif
         /* used when SSL_ST_FLUSH_DATA is entered */
         int next_state;
         int reuse_message;
diff -Naur original/openssl-1.0.2g/ssl/ssl_cert.c sidh/openssl-1.0.2g/ssl/ssl_cert.c
--- original/openssl-1.0.2g/ssl/ssl_cert.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl_cert.c	2016-07-20 08:28:03.303200611 -0700
@@ -392,7 +392,7 @@
 
     return (ret);
 
-#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_ECDH)
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_ECDH) || !defined(OPENSSL_NO_SIDH)
  err:
 #endif
 #ifndef OPENSSL_NO_RSA
@@ -695,6 +695,10 @@
     if (sc->peer_ecdh_tmp != NULL)
         EC_KEY_free(sc->peer_ecdh_tmp);
 #endif
+#ifndef OPENSSL_NO_SIDH
+    if (sc->peer_sidhpub_tmp != NULL)
+      SIDH_PUB_free(sc->peer_sidhpub_tmp);
+#endif
 
     OPENSSL_free(sc);
 }
diff -Naur original/openssl-1.0.2g/ssl/ssl_ciph.c sidh/openssl-1.0.2g/ssl/ssl_ciph.c
--- original/openssl-1.0.2g/ssl/ssl_ciph.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl_ciph.c	2016-07-20 08:28:03.303200611 -0700
@@ -260,6 +260,7 @@
     {0, SSL_TXT_kECDH, 0, SSL_kECDHr | SSL_kECDHe, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_kEECDH, 0, SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_kECDHE, 0, SSL_kEECDH, 0, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_kSIDH, 0, SSL_kSIDH, 0, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_ECDH, 0, SSL_kECDHr | SSL_kECDHe | SSL_kEECDH, 0, 0, 0, 0, 0,
      0, 0, 0},
 
@@ -289,6 +290,7 @@
     {0, SSL_TXT_DHE, 0, SSL_kEDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_EECDH, 0, SSL_kEECDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_ECDHE, 0, SSL_kEECDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
+    {0, SSL_TXT_SIDH, 0, SSL_kSIDH, ~SSL_aNULL, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_NULL, 0, 0, 0, SSL_eNULL, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_KRB5, 0, SSL_kKRB5, SSL_aKRB5, 0, 0, 0, 0, 0, 0, 0},
     {0, SSL_TXT_RSA, 0, SSL_kRSA, SSL_aRSA, 0, 0, 0, 0, 0, 0, 0},
@@ -1728,6 +1730,9 @@
     case SSL_kEECDH:
         kx = "ECDH";
         break;
+    case SSL_kSIDH:
+        kx="SIDH";
+	break;
     case SSL_kPSK:
         kx = "PSK";
         break;
diff -Naur original/openssl-1.0.2g/ssl/ssl_err.c sidh/openssl-1.0.2g/ssl/ssl_err.c
--- original/openssl-1.0.2g/ssl/ssl_err.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl_err.c	2016-07-20 08:28:03.303200611 -0700
@@ -410,6 +410,7 @@
     {ERR_REASON(SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH),
      "bad psk identity hint length"},
     {ERR_REASON(SSL_R_BAD_RESPONSE_ARGUMENT), "bad response argument"},
+    {ERR_REASON(SSL_R_BAD_SIDH_PUB), "bad sidh pub"},
     {ERR_REASON(SSL_R_BAD_RSA_DECRYPT), "bad rsa decrypt"},
     {ERR_REASON(SSL_R_BAD_RSA_ENCRYPT), "bad rsa encrypt"},
     {ERR_REASON(SSL_R_BAD_RSA_E_LENGTH), "bad rsa e length"},
diff -Naur original/openssl-1.0.2g/ssl/ssl.h sidh/openssl-1.0.2g/ssl/ssl.h
--- original/openssl-1.0.2g/ssl/ssl.h	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl.h	2016-07-20 08:28:03.303200611 -0700
@@ -253,6 +253,7 @@
 # define SSL_TXT_kECDH           "kECDH"
 # define SSL_TXT_kEECDH          "kEECDH"
 # define SSL_TXT_kECDHE          "kECDHE"/* alias for kEECDH */
+# define SSL_TXT_kSIDH		 "kSIDH"
 # define SSL_TXT_kPSK            "kPSK"
 # define SSL_TXT_kGOST           "kGOST"
 # define SSL_TXT_kSRP            "kSRP"
@@ -280,6 +281,7 @@
 # define SSL_TXT_ECDHE           "ECDHE"/* alias for ECDHE" */
 # define SSL_TXT_AECDH           "AECDH"
 # define SSL_TXT_ECDSA           "ECDSA"
+# define SSL_TXT_SIDH		 "SIDH" /* same as "kSIDH" */
 # define SSL_TXT_KRB5            "KRB5"
 # define SSL_TXT_PSK             "PSK"
 # define SSL_TXT_SRP             "SRP"
@@ -2867,6 +2869,7 @@
 # define SSL_R_BAD_PROTOCOL_VERSION_NUMBER                116
 # define SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH               316
 # define SSL_R_BAD_RESPONSE_ARGUMENT                      117
+# define SSL_R_BAD_SIDH_PUB				  373
 # define SSL_R_BAD_RSA_DECRYPT                            118
 # define SSL_R_BAD_RSA_ENCRYPT                            119
 # define SSL_R_BAD_RSA_E_LENGTH                           120
diff -Naur original/openssl-1.0.2g/ssl/ssl_lib.c sidh/openssl-1.0.2g/ssl/ssl_lib.c
--- original/openssl-1.0.2g/ssl/ssl_lib.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl_lib.c	2016-07-20 08:28:03.303200611 -0700
@@ -2424,7 +2424,13 @@
         emask_k |= SSL_kEECDH;
     }
 #endif
-
+#ifndef OPENSSL_NO_SIDH
+    mask_k|=SSL_kSIDH;
+    emask_k|=SSL_kSIDH;
+	mask_k |= SSL_kSIDHECDHEHYBRID;
+	emask_k |= SSL_kSIDHECDHEHYBRID;
+#endif
+ 
 #ifndef OPENSSL_NO_PSK
     mask_k |= SSL_kPSK;
     mask_a |= SSL_aPSK;
diff -Naur original/openssl-1.0.2g/ssl/ssl_locl.h sidh/openssl-1.0.2g/ssl/ssl_locl.h
--- original/openssl-1.0.2g/ssl/ssl_locl.h	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/ssl_locl.h	2016-07-20 08:28:03.299200611 -0700
@@ -161,6 +161,9 @@
 # ifndef OPENSSL_NO_DSA
 #  include <openssl/dsa.h>
 # endif
+#ifndef OPENSSL_NO_SIDH
+#include <openssl/sidh.h>
+#endif
 # include <openssl/err.h>
 # include <openssl/ssl.h>
 # include <openssl/symhacks.h>
@@ -314,6 +317,9 @@
 # define SSL_kGOST       0x00000200L
 /* SRP */
 # define SSL_kSRP        0x00000400L
+/* SIDH */
+# define SSL_kSIDH	0x00001000L
+# define SSL_kSIDHECDHEHYBRID        0x00002000L
 
 /* Bits for algorithm_auth (server authentication) */
 /* RSA auth */
@@ -624,6 +630,7 @@
     /* Select ECDH parameters automatically */
     int ecdh_tmp_auto;
 # endif
+
     /* Flags related to certificates */
     unsigned int cert_flags;
     CERT_PKEY pkeys[SSL_PKEY_NUM];
@@ -709,6 +716,10 @@
 # ifndef OPENSSL_NO_ECDH
     EC_KEY *peer_ecdh_tmp;
 # endif
+#ifndef OPENSSL_NO_SIDH
+  SIDH_PUB *peer_sidhpub_tmp;
+#endif
+
     int references;             /* actually always 1 at the moment */
 } SESS_CERT;
 /* Structure containing decoded values of signature algorithms extension */
diff -Naur original/openssl-1.0.2g/ssl/t1_lib.c sidh/openssl-1.0.2g/ssl/t1_lib.c
--- original/openssl-1.0.2g/ssl/t1_lib.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/t1_lib.c	2016-07-20 08:28:03.299200611 -0700
@@ -1243,7 +1243,7 @@
 
             alg_k = c->algorithm_mkey;
             alg_a = c->algorithm_auth;
-            if ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)
+			if ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID)
                  || (alg_a & SSL_aECDSA))) {
                 using_ecc = 1;
                 break;
@@ -1612,7 +1612,7 @@
 # ifndef OPENSSL_NO_EC
     unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
     unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;
-    int using_ecc = (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe))
+	int using_ecc = (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID))
         || (alg_a & SSL_aECDSA);
     using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);
 # endif
@@ -3098,7 +3098,7 @@
         && (s->tlsext_ecpointformatlist_length > 0)
         && (s->session->tlsext_ecpointformatlist != NULL)
         && (s->session->tlsext_ecpointformatlist_length > 0)
-        && ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe))
+		&& ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe | SSL_kSIDHECDHEHYBRID))
             || (alg_a & SSL_aECDSA))) {
         /* we are using an ECC cipher */
         size_t i;
diff -Naur original/openssl-1.0.2g/ssl/t1_trce.c sidh/openssl-1.0.2g/ssl/t1_trce.c
--- original/openssl-1.0.2g/ssl/t1_trce.c	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/t1_trce.c	2016-07-20 08:28:03.303200611 -0700
@@ -813,7 +813,16 @@
         *pname = "GOST";
         return SSL_kGOST;
     }
-    *pname = "UNKNOWN";
+	if (alg_k & SSL_kSIDH) {
+		*pname = "SIDH";
+		return SSL_kSIDH;
+	}
+	if (alg_k & SSL_kSIDHECDHEHYBRID) {
+		*pname = "SIDH ECDH hybrid";
+		return SSL_kSIDHECDHEHYBRID;
+	}
+
+	*pname = "UNKNOWN";
     return 0;
 }
 
diff -Naur original/openssl-1.0.2g/ssl/tls1.h sidh/openssl-1.0.2g/ssl/tls1.h
--- original/openssl-1.0.2g/ssl/tls1.h	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/ssl/tls1.h	2016-07-20 08:28:03.303200611 -0700
@@ -563,6 +563,14 @@
 # define TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256        0x0300C031
 # define TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384        0x0300C032
 
+/* SIDH based ciphersuites */
+#ifndef OPENSSL_NO_SIDH
+#define TLS1_CK_SIDH_RSA_WITH_AES_128_GCM_SHA256        0x0300E010
+#define TLS1_CK_SIDH_ECDSA_WITH_AES_128_GCM_SHA256      0x0300E011
+#define TLS1_CK_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256        0x0300E012
+#define TLS1_CK_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256      0x0300E013
+#endif
+
 /*
  * XXX * Backward compatibility alert: + * Older versions of OpenSSL gave
  * some DHE ciphers names with "EDH" + * instead of "DHE".  Going forward, we
@@ -713,6 +721,13 @@
 # define TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256       "ECDH-RSA-AES128-GCM-SHA256"
 # define TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384       "ECDH-RSA-AES256-GCM-SHA384"
 
+#ifndef OPENSSL_NO_SIDH
+#define TLS1_TXT_SIDH_RSA_WITH_AES_128_GCM_SHA256        "SIDH-RSA-AES128-GCM-SHA256"
+#define TLS1_TXT_SIDH_ECDSA_WITH_AES_128_GCM_SHA256      "SIDH-ECDSA-AES128-GCM-SHA256"
+#define TLS1_TXT_SIDH_ECDHE_RSA_WITH_AES_128_GCM_SHA256        "SIDH-ECDHE-RSA-AES128-GCM-SHA256"
+#define TLS1_TXT_SIDH_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256      "SIDH-ECDHE-ECDSA-AES128-GCM-SHA256"
+#endif
+
 # define TLS_CT_RSA_SIGN                 1
 # define TLS_CT_DSS_SIGN                 2
 # define TLS_CT_RSA_FIXED_DH             3
diff -Naur original/openssl-1.0.2g/test/Makefile sidh/openssl-1.0.2g/test/Makefile
--- original/openssl-1.0.2g/test/Makefile	2016-03-01 05:36:53.000000000 -0800
+++ sidh/openssl-1.0.2g/test/Makefile	2016-07-20 08:28:03.359200609 -0700
@@ -33,6 +33,7 @@
 ECTEST=		ectest
 ECDSATEST=	ecdsatest
 ECDHTEST=	ecdhtest
+SIDHKEXTEST=	sidhkextest
 EXPTEST=	exptest
 IDEATEST=	ideatest
 SHATEST=	shatest
@@ -74,7 +75,7 @@
 
 TESTS=		alltests
 
-EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
+EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)$(EXE_EXT) $(SIDHKEXTEST)$(EXE_EXT) $(IDEATEST)$(EXE_EXT) \
 	$(MD2TEST)$(EXE_EXT)  $(MD4TEST)$(EXE_EXT) $(MD5TEST)$(EXE_EXT) $(HMACTEST)$(EXE_EXT) $(WPTEST)$(EXE_EXT) \
 	$(RC2TEST)$(EXE_EXT) $(RC4TEST)$(EXE_EXT) $(RC5TEST)$(EXE_EXT) \
 	$(DESTEST)$(EXE_EXT) $(SHATEST)$(EXE_EXT) $(SHA1TEST)$(EXE_EXT) $(SHA256TEST)$(EXE_EXT) $(SHA512TEST)$(EXE_EXT) \
@@ -88,7 +89,7 @@
 
 # $(METHTEST)$(EXE_EXT)
 
-OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATEST).o $(ECDHTEST).o $(IDEATEST).o \
+OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATEST).o $(ECDHTEST).o $(SIDHKEXTEST).o $(IDEATEST).o \
 	$(MD2TEST).o $(MD4TEST).o $(MD5TEST).o \
 	$(HMACTEST).o $(WPTEST).o \
 	$(RC2TEST).o $(RC4TEST).o $(RC5TEST).o \
@@ -100,7 +101,7 @@
 	$(HEARTBEATTEST).o $(CONSTTIMETEST).o $(VERIFYEXTRATEST).o \
 	$(CLIENTHELLOTEST).o  $(SSLV2CONFTEST).o
 
-SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
+SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(SIDHKEXTEST).c $(IDEATEST).c \
 	$(MD2TEST).c  $(MD4TEST).c $(MD5TEST).c \
 	$(HMACTEST).c $(WPTEST).c \
 	$(RC2TEST).c $(RC4TEST).c $(RC5TEST).c \
@@ -148,7 +149,7 @@
 	test_des test_idea test_sha test_md4 test_md5 test_hmac \
 	test_md2 test_mdc2 test_wp \
 	test_rmd test_rc2 test_rc4 test_rc5 test_bf test_cast test_aes \
-	test_rand test_bn test_ec test_ecdsa test_ecdh \
+	test_rand test_bn test_ec test_ecdsa test_ecdh test_sidhkex \
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_evp_extra test_ssl test_tsa test_ige \
@@ -262,6 +263,10 @@
 	@echo 'test ecdh'
 	../util/shlib_wrap.sh ./$(ECDHTEST)
 
+test_sidhkex: $(SIDHKEXTEST)$(EXE_EXT)
+	@echo 'test sidh'
+	../util/shlib_wrap.sh ./$(SIDHKEXTEST)
+
 test_verify: ../apps/openssl$(EXE_EXT)
 	@echo "The following command should have some OK's and some failures"
 	@echo "There are definitly a few expired certificates"
@@ -516,6 +521,9 @@
 $(ECDHTEST)$(EXE_EXT): $(ECDHTEST).o $(DLIBCRYPTO)
 	@target=$(ECDHTEST); $(BUILD_CMD)
 
+$(SIDHKEXTEST)$(EXE_EXT): $(SIDHKEXTEST).o $(DLIBCRYPTO)
+	@target=$(SIDHKEXTEST); $(BUILD_CMD)
+
 $(IGETEST)$(EXE_EXT): $(IGETEST).o $(DLIBCRYPTO)
 	@target=$(IGETEST); $(BUILD_CMD)
 
@@ -592,25 +600,25 @@
 casttest.o: ../e_os.h ../include/openssl/cast.h ../include/openssl/e_os2.h
 casttest.o: ../include/openssl/opensslconf.h casttest.c
 clienthellotest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-clienthellotest.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-clienthellotest.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-clienthellotest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-clienthellotest.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-clienthellotest.o: ../include/openssl/err.h ../include/openssl/evp.h
-clienthellotest.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-clienthellotest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-clienthellotest.o: ../include/openssl/objects.h
+clienthellotest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+clienthellotest.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+clienthellotest.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+clienthellotest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+clienthellotest.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+clienthellotest.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+clienthellotest.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+clienthellotest.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
 clienthellotest.o: ../include/openssl/opensslconf.h
 clienthellotest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 clienthellotest.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 clienthellotest.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 clienthellotest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-clienthellotest.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-clienthellotest.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-clienthellotest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-clienthellotest.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-clienthellotest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-clienthellotest.o: clienthellotest.c
+clienthellotest.o: ../include/openssl/sidh.h ../include/openssl/srtp.h
+clienthellotest.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+clienthellotest.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+clienthellotest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+clienthellotest.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+clienthellotest.o: ../include/openssl/x509_vfy.h clienthellotest.c
 constant_time_test.o: ../crypto/constant_time_locl.h ../e_os.h
 constant_time_test.o: ../include/openssl/e_os2.h
 constant_time_test.o: ../include/openssl/opensslconf.h constant_time_test.c
@@ -718,26 +726,26 @@
 exptest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
 exptest.o: ../include/openssl/symhacks.h exptest.c
 heartbeat_test.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
-heartbeat_test.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-heartbeat_test.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-heartbeat_test.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-heartbeat_test.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-heartbeat_test.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-heartbeat_test.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-heartbeat_test.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-heartbeat_test.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-heartbeat_test.o: ../include/openssl/opensslconf.h
+heartbeat_test.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+heartbeat_test.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+heartbeat_test.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+heartbeat_test.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+heartbeat_test.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+heartbeat_test.o: ../include/openssl/err.h ../include/openssl/evp.h
+heartbeat_test.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+heartbeat_test.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+heartbeat_test.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
 heartbeat_test.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 heartbeat_test.o: ../include/openssl/pem.h ../include/openssl/pem2.h
 heartbeat_test.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
 heartbeat_test.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-heartbeat_test.o: ../include/openssl/sha.h ../include/openssl/srtp.h
-heartbeat_test.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
-heartbeat_test.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
-heartbeat_test.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
-heartbeat_test.o: ../include/openssl/tls1.h ../include/openssl/x509.h
-heartbeat_test.o: ../include/openssl/x509_vfy.h ../ssl/ssl_locl.h
-heartbeat_test.o: ../test/testutil.h heartbeat_test.c
+heartbeat_test.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+heartbeat_test.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+heartbeat_test.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+heartbeat_test.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+heartbeat_test.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+heartbeat_test.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+heartbeat_test.o: ../ssl/ssl_locl.h ../test/testutil.h heartbeat_test.c
 hmactest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 hmactest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
 hmactest.o: ../include/openssl/evp.h ../include/openssl/hmac.h
@@ -826,6 +834,16 @@
 shatest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
 shatest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
 shatest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h shatest.c
+sidhkextest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
+sidhkextest.o: ../include/openssl/bn.h ../include/openssl/crypto.h
+sidhkextest.o: ../include/openssl/e_os2.h ../include/openssl/err.h
+sidhkextest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+sidhkextest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+sidhkextest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+sidhkextest.o: ../include/openssl/rand.h ../include/openssl/safestack.h
+sidhkextest.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+sidhkextest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+sidhkextest.o: sidhkextest.c
 srptest.o: ../include/openssl/bio.h ../include/openssl/bn.h
 srptest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
 srptest.o: ../include/openssl/err.h ../include/openssl/lhash.h
@@ -849,26 +867,27 @@
 ssltest.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
 ssltest.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
 ssltest.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
-ssltest.o: ../include/openssl/sha.h ../include/openssl/srp.h
-ssltest.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-ssltest.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-ssltest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-ssltest.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-ssltest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
-ssltest.o: ../include/openssl/x509v3.h ssltest.c
+ssltest.o: ../include/openssl/sha.h ../include/openssl/sidh.h
+ssltest.o: ../include/openssl/srp.h ../include/openssl/srtp.h
+ssltest.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ssltest.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ssltest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ssltest.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+ssltest.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h ssltest.c
 sslv2conftest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
-sslv2conftest.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-sslv2conftest.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
-sslv2conftest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
-sslv2conftest.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
-sslv2conftest.o: ../include/openssl/err.h ../include/openssl/evp.h
-sslv2conftest.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
-sslv2conftest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
-sslv2conftest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-sslv2conftest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-sslv2conftest.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-sslv2conftest.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-sslv2conftest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+sslv2conftest.o: ../include/openssl/bn.h ../include/openssl/buffer.h
+sslv2conftest.o: ../include/openssl/comp.h ../include/openssl/crypto.h
+sslv2conftest.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
+sslv2conftest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+sslv2conftest.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
+sslv2conftest.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+sslv2conftest.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+sslv2conftest.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+sslv2conftest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+sslv2conftest.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+sslv2conftest.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+sslv2conftest.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+sslv2conftest.o: ../include/openssl/sha.h ../include/openssl/sidh.h
 sslv2conftest.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
 sslv2conftest.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
 sslv2conftest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
diff -Naur original/openssl-1.0.2g/tools/c_rehash sidh/openssl-1.0.2g/tools/c_rehash
--- original/openssl-1.0.2g/tools/c_rehash	2016-03-01 05:36:56.000000000 -0800
+++ sidh/openssl-1.0.2g/tools/c_rehash	1969-12-31 16:00:00.000000000 -0800
@@ -1,210 +0,0 @@
-#!/usr/bin/perl
-
-# Perl c_rehash script, scan all files in a directory
-# and add symbolic links to their hash values.
-
-my $dir = "/usr/local/ssl";
-my $prefix = "/usr/local/ssl";
-
-my $openssl = $ENV{OPENSSL} || "openssl";
-my $pwd;
-my $x509hash = "-subject_hash";
-my $crlhash = "-hash";
-my $verbose = 0;
-my $symlink_exists=eval {symlink("",""); 1};
-my $removelinks = 1;
-
-##  Parse flags.
-while ( $ARGV[0] =~ /^-/ ) {
-    my $flag = shift @ARGV;
-    last if ( $flag eq '--');
-    if ( $flag eq '-old') {
-	    $x509hash = "-subject_hash_old";
-	    $crlhash = "-hash_old";
-    } elsif ( $flag eq '-h') {
-	    help();
-    } elsif ( $flag eq '-n' ) {
-	    $removelinks = 0;
-    } elsif ( $flag eq '-v' ) {
-	    $verbose++;
-    }
-    else {
-	    print STDERR "Usage error; try -help.\n";
-	    exit 1;
-    }
-}
-
-sub help {
-	print "Usage: c_rehash [-old] [-h] [-v] [dirs...]\n";
-	print "   -old use old-style digest\n";
-	print "   -h print this help text\n";
-	print "   -v print files removed and linked\n";
-	exit 0;
-}
-
-eval "require Cwd";
-if (defined(&Cwd::getcwd)) {
-	$pwd=Cwd::getcwd();
-} else {
-	$pwd=`pwd`;
-	chomp($pwd);
-}
-
-# DOS/Win32 or Unix delimiter?  Prefix our installdir, then search.
-my $path_delim = ($pwd =~ /^[a-z]\:/i) ? ';' : ':';
-$ENV{PATH} = "$prefix/bin" . ($ENV{PATH} ? $path_delim . $ENV{PATH} : "");
-
-if(! -x $openssl) {
-	my $found = 0;
-	foreach (split /$path_delim/, $ENV{PATH}) {
-		if(-x "$_/$openssl") {
-			$found = 1;
-			$openssl = "$_/$openssl";
-			last;
-		}	
-	}
-	if($found == 0) {
-		print STDERR "c_rehash: rehashing skipped ('openssl' program not available)\n";
-		exit 0;
-	}
-}
-
-if(@ARGV) {
-	@dirlist = @ARGV;
-} elsif($ENV{SSL_CERT_DIR}) {
-	@dirlist = split /$path_delim/, $ENV{SSL_CERT_DIR};
-} else {
-	$dirlist[0] = "$dir/certs";
-}
-
-if (-d $dirlist[0]) {
-	chdir $dirlist[0];
-	$openssl="$pwd/$openssl" if (!-x $openssl);
-	chdir $pwd;
-}
-
-foreach (@dirlist) {
-	if(-d $_ and -w $_) {
-		hash_dir($_);
-	}
-}
-
-sub hash_dir {
-	my %hashlist;
-	print "Doing $_[0]\n";
-	chdir $_[0];
-	opendir(DIR, ".");
-	my @flist = readdir(DIR);
-	closedir DIR;
-	if ( $removelinks ) {
-		# Delete any existing symbolic links
-		foreach (grep {/^[\da-f]+\.r{0,1}\d+$/} @flist) {
-			if(-l $_) {
-				unlink $_;
-				print "unlink $_" if $verbose;
-			}
-		}
-	}
-	FILE: foreach $fname (grep {/\.(pem)|(crt)|(cer)|(crl)$/} @flist) {
-		# Check to see if certificates and/or CRLs present.
-		my ($cert, $crl) = check_file($fname);
-		if(!$cert && !$crl) {
-			print STDERR "WARNING: $fname does not contain a certificate or CRL: skipping\n";
-			next;
-		}
-		link_hash_cert($fname) if($cert);
-		link_hash_crl($fname) if($crl);
-	}
-}
-
-sub check_file {
-	my ($is_cert, $is_crl) = (0,0);
-	my $fname = $_[0];
-	open IN, $fname;
-	while(<IN>) {
-		if(/^-----BEGIN (.*)-----/) {
-			my $hdr = $1;
-			if($hdr =~ /^(X509 |TRUSTED |)CERTIFICATE$/) {
-				$is_cert = 1;
-				last if($is_crl);
-			} elsif($hdr eq "X509 CRL") {
-				$is_crl = 1;
-				last if($is_cert);
-			}
-		}
-	}
-	close IN;
-	return ($is_cert, $is_crl);
-}
-
-
-# Link a certificate to its subject name hash value, each hash is of
-# the form <hash>.<n> where n is an integer. If the hash value already exists
-# then we need to up the value of n, unless its a duplicate in which
-# case we skip the link. We check for duplicates by comparing the
-# certificate fingerprints
-
-sub link_hash_cert {
-		my $fname = $_[0];
-		$fname =~ s/'/'\\''/g;
-		my ($hash, $fprint) = `"$openssl" x509 $x509hash -fingerprint -noout -in "$fname"`;
-		chomp $hash;
-		chomp $fprint;
-		$fprint =~ s/^.*=//;
-		$fprint =~ tr/://d;
-		my $suffix = 0;
-		# Search for an unused hash filename
-		while(exists $hashlist{"$hash.$suffix"}) {
-			# Hash matches: if fingerprint matches its a duplicate cert
-			if($hashlist{"$hash.$suffix"} eq $fprint) {
-				print STDERR "WARNING: Skipping duplicate certificate $fname\n";
-				return;
-			}
-			$suffix++;
-		}
-		$hash .= ".$suffix";
-		if ($symlink_exists) {
-			symlink $fname, $hash;
-			print "link $fname -> $hash\n" if $verbose;
-		} else {
-			open IN,"<$fname" or die "can't open $fname for read";
-			open OUT,">$hash" or die "can't open $hash for write";
-			print OUT <IN>;	# does the job for small text files
-			close OUT;
-			close IN;
-			print "copy $fname -> $hash\n" if $verbose;
-		}
-		$hashlist{$hash} = $fprint;
-}
-
-# Same as above except for a CRL. CRL links are of the form <hash>.r<n>
-
-sub link_hash_crl {
-		my $fname = $_[0];
-		$fname =~ s/'/'\\''/g;
-		my ($hash, $fprint) = `"$openssl" crl $crlhash -fingerprint -noout -in '$fname'`;
-		chomp $hash;
-		chomp $fprint;
-		$fprint =~ s/^.*=//;
-		$fprint =~ tr/://d;
-		my $suffix = 0;
-		# Search for an unused hash filename
-		while(exists $hashlist{"$hash.r$suffix"}) {
-			# Hash matches: if fingerprint matches its a duplicate cert
-			if($hashlist{"$hash.r$suffix"} eq $fprint) {
-				print STDERR "WARNING: Skipping duplicate CRL $fname\n";
-				return;
-			}
-			$suffix++;
-		}
-		$hash .= ".r$suffix";
-		if ($symlink_exists) {
-			symlink $fname, $hash;
-			print "link $fname -> $hash\n" if $verbose;
-		} else {
-			system ("cp", $fname, $hash);
-			print "cp $fname -> $hash\n" if $verbose;
-		}
-		$hashlist{$hash} = $fprint;
-}
-
diff -Naur original/openssl-1.0.2g/util/libeay.num sidh/openssl-1.0.2g/util/libeay.num
--- original/openssl-1.0.2g/util/libeay.num	2016-03-01 05:36:39.000000000 -0800
+++ sidh/openssl-1.0.2g/util/libeay.num	2016-07-20 08:28:03.363200609 -0700
@@ -4416,3 +4416,21 @@
 EC_GROUP_get_mont_data                  4772	EXIST::FUNCTION:EC
 i2d_re_X509_tbs                         4773	EXIST::FUNCTION:
 EVP_PKEY_asn1_set_item                  4774	EXIST::FUNCTION:
+SIDH_CTX_new				4775	EXIST::FUNCTION:SIDH
+SIDH_CTX_free				4776	EXIST::FUNCTION:SIDH
+SIDH_PUB_new				4777	EXIST::FUNCTION:SIDH
+SIDH_PUB_copy				4778	EXIST::FUNCTION:SIDH
+SIDH_PUB_free				4779	EXIST::FUNCTION:SIDH
+SIDH_PAIR_new				4780	EXIST::FUNCTION:SIDH
+SIDH_PAIR_copy				4781	EXIST::FUNCTION:SIDH
+SIDH_PAIR_dup				4782	EXIST::FUNCTION:SIDH
+SIDH_PAIR_free				4783	EXIST::FUNCTION:SIDH
+SIDH_PAIR_generate_key_server		4784	EXIST::FUNCTION:SIDH
+SIDH_PAIR_generate_key_client		4785	EXIST::FUNCTION:SIDH
+o2i_SIDH_PUB				4786	EXIST::FUNCTION:SIDH
+i2o_SIDH_PUB				4787	EXIST::FUNCTION:SIDH
+SIDH_PAIR_get_publickey			4788	EXIST::FUNCTION:SIDH
+SIDH_PAIR_has_privatekey		4789	EXIST::FUNCTION:SIDH
+SIDH_compute_key_server			4790	EXIST::FUNCTION:SIDH
+SIDH_compute_key_client			4791	EXIST::FUNCTION:SIDH
+ERR_load_SIDH_strings			4792	EXIST::FUNCTION:SIDH
diff -Naur original/openssl-1.0.2g/util/mk1mf.pl sidh/openssl-1.0.2g/util/mk1mf.pl
--- original/openssl-1.0.2g/util/mk1mf.pl	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/util/mk1mf.pl	2016-07-20 08:28:03.363200609 -0700
@@ -120,6 +120,7 @@
 	no-ec					- No EC
 	no-ecdsa				- No ECDSA
 	no-ecdh					- No ECDH
+	no-sidh				        - No SIDH
 	no-engine				- No engine
 	no-hw					- No hw
 	nasm 					- Use NASM for x86 asm
@@ -284,6 +285,7 @@
 $cflags.=" -DOPENSSL_NO_EC"   if $no_ec;
 $cflags.=" -DOPENSSL_NO_ECDSA" if $no_ecdsa;
 $cflags.=" -DOPENSSL_NO_ECDH" if $no_ecdh;
+$cflags.=" -DOPENSSL_NO_SIDH" if $no_sidh;
 $cflags.=" -DOPENSSL_NO_GOST" if $no_gost;
 $cflags.=" -DOPENSSL_NO_ENGINE"   if $no_engine;
 $cflags.=" -DOPENSSL_NO_HW"   if $no_hw;
@@ -1213,6 +1215,7 @@
 		"no-ec" => \$no_ec,
 		"no-ecdsa" => \$no_ecdsa,
 		"no-ecdh" => \$no_ecdh,
+		"no-sidh" => \$no_sidh,
 		"no-gost" => \$no_gost,
 		"no-engine" => \$no_engine,
 		"no-hw" => \$no_hw,
diff -Naur original/openssl-1.0.2g/util/mkdef.pl sidh/openssl-1.0.2g/util/mkdef.pl
--- original/openssl-1.0.2g/util/mkdef.pl	2016-03-01 05:35:53.000000000 -0800
+++ sidh/openssl-1.0.2g/util/mkdef.pl	2016-07-20 08:28:03.363200609 -0700
@@ -84,7 +84,7 @@
 my @known_algorithms = ( "RC2", "RC4", "RC5", "IDEA", "DES", "BF",
 			 "CAST", "MD2", "MD4", "MD5", "SHA", "SHA0", "SHA1",
 			 "SHA256", "SHA512", "RIPEMD",
-			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "ECDSA", "EC2M",
+			 "MDC2", "WHIRLPOOL", "RSA", "DSA", "DH", "EC", "ECDH", "SIDH", "ECDSA", "EC2M",
 			 "HMAC", "AES", "CAMELLIA", "SEED", "GOST",
 			 # EC_NISTP_64_GCC_128
 			 "EC_NISTP_64_GCC_128",
@@ -140,7 +140,7 @@
 my $no_cast; my $no_whirlpool; my $no_camellia; my $no_seed;
 my $no_md2; my $no_md4; my $no_md5; my $no_sha; my $no_ripemd; my $no_mdc2;
 my $no_rsa; my $no_dsa; my $no_dh; my $no_hmac=0; my $no_aes; my $no_krb5;
-my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_engine; my $no_hw;
+my $no_ec; my $no_ecdsa; my $no_ecdh; my $no_sidh; my $no_engine; my $no_hw;
 my $no_fp_api; my $no_static_engine=1; my $no_gmp; my $no_deprecated;
 my $no_rfc3779; my $no_psk; my $no_tlsext; my $no_cms; my $no_capieng;
 my $no_jpake; my $no_srp; my $no_ssl2; my $no_ec2m; my $no_nistp_gcc; 
@@ -216,6 +216,7 @@
 	elsif (/^no-ec$/)       { $no_ec=1; }
 	elsif (/^no-ecdsa$/)	{ $no_ecdsa=1; }
 	elsif (/^no-ecdh$/) 	{ $no_ecdh=1; }
+	elsif (/^no-sidh$/) 	{ $no_sidh=1; }
 	elsif (/^no-hmac$/)	{ $no_hmac=1; }
 	elsif (/^no-aes$/)	{ $no_aes=1; }
 	elsif (/^no-camellia$/)	{ $no_camellia=1; }
@@ -276,6 +277,7 @@
 	exit(1);
 	}
 
+
 %ssl_list=&load_numbers($ssl_num);
 $max_ssl = $max_num;
 %crypto_list=&load_numbers($crypto_num);
@@ -316,6 +318,7 @@
 $crypto.=" crypto/ec/ec.h" ; # unless $no_ec;
 $crypto.=" crypto/ecdsa/ecdsa.h" ; # unless $no_ecdsa;
 $crypto.=" crypto/ecdh/ecdh.h" ; # unless $no_ecdh;
+$crypto.=" crypto/sidh/sidh.h" ; # unless $no_sidh;
 $crypto.=" crypto/hmac/hmac.h" ; # unless $no_hmac;
 $crypto.=" crypto/cmac/cmac.h" ; # unless $no_hmac;
 
@@ -358,7 +361,6 @@
 
 my @ssl_symbols = &do_defs("SSLEAY", $ssl, $symhacks);
 my @crypto_symbols = &do_defs("LIBEAY", $crypto, $symhacks);
-
 if ($do_update) {
 
 if ($do_ssl == 1) {
@@ -466,6 +468,7 @@
 			my ($a1, $a2);
 
 			print STDERR "DEBUG: make_variant: Entered with ",$s,", ",$a,", ",(defined($p)?$p:""),", ",(defined($k)?$k:""),"\n" if $debug;
+
 			if (defined($p))
 			{
 				$a1 = join(",",$p,
@@ -1188,6 +1191,7 @@
 			if ($keyword eq "EC" && $no_ec) { return 0; }
 			if ($keyword eq "ECDSA" && $no_ecdsa) { return 0; }
 			if ($keyword eq "ECDH" && $no_ecdh) { return 0; }
+			if ($keyword eq "SIDH" && $no_sidh) { return 0; }
 			if ($keyword eq "HMAC" && $no_hmac) { return 0; }
 			if ($keyword eq "AES" && $no_aes) { return 0; }
 			if ($keyword eq "CAMELLIA" && $no_camellia) { return 0; }
diff -Naur original/openssl-1.0.2g/util/mkfiles.pl sidh/openssl-1.0.2g/util/mkfiles.pl
--- original/openssl-1.0.2g/util/mkfiles.pl	2016-03-01 05:35:05.000000000 -0800
+++ sidh/openssl-1.0.2g/util/mkfiles.pl	2016-07-20 08:28:03.363200609 -0700
@@ -35,6 +35,7 @@
 "crypto/dh",
 "crypto/ec",
 "crypto/ecdh",
+"crypto/sidh",
 "crypto/ecdsa",
 "crypto/buffer",
 "crypto/bio",
